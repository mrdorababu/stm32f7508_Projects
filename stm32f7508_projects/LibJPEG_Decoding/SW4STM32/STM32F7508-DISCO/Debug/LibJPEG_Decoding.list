
LibJPEG_Decoding.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  90000000  90000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005448  900001c8  900001c8  000101c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00004268  90005610  90005610  00015610  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  90009878  90009878  00019878  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  90009880  90009880  00019880  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  90009884  90009884  00019884  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         000000a0  20000000  90009888  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000524  200000a0  90009928  000200a0  2**2
                  ALLOC
  8 ._user_heap_stack 0000b004  200005c4  90009928  000205c4  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  000200a0  2**0
                  CONTENTS, READONLY
 10 .debug_line   0001e041  00000000  00000000  000200d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_info   000234d7  00000000  00000000  0003e111  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 000049f0  00000000  00000000  000615e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00001108  00000000  00000000  00065fd8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00102782  00000000  00000000  000670e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001d20  00000000  00000000  00169868  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_loc    00014ff7  00000000  00000000  0016b588  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000044b8  00000000  00000000  0018057f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000053  00000000  00000000  00184a37  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00003448  00000000  00000000  00184a8c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

900001c8 <__do_global_dtors_aux>:
900001c8:	b510      	push	{r4, lr}
900001ca:	4c05      	ldr	r4, [pc, #20]	; (900001e0 <__do_global_dtors_aux+0x18>)
900001cc:	7823      	ldrb	r3, [r4, #0]
900001ce:	b933      	cbnz	r3, 900001de <__do_global_dtors_aux+0x16>
900001d0:	4b04      	ldr	r3, [pc, #16]	; (900001e4 <__do_global_dtors_aux+0x1c>)
900001d2:	b113      	cbz	r3, 900001da <__do_global_dtors_aux+0x12>
900001d4:	4804      	ldr	r0, [pc, #16]	; (900001e8 <__do_global_dtors_aux+0x20>)
900001d6:	f3af 8000 	nop.w
900001da:	2301      	movs	r3, #1
900001dc:	7023      	strb	r3, [r4, #0]
900001de:	bd10      	pop	{r4, pc}
900001e0:	200000a0 	.word	0x200000a0
900001e4:	00000000 	.word	0x00000000
900001e8:	900055f8 	.word	0x900055f8

900001ec <frame_dummy>:
900001ec:	b508      	push	{r3, lr}
900001ee:	4b03      	ldr	r3, [pc, #12]	; (900001fc <frame_dummy+0x10>)
900001f0:	b11b      	cbz	r3, 900001fa <frame_dummy+0xe>
900001f2:	4903      	ldr	r1, [pc, #12]	; (90000200 <frame_dummy+0x14>)
900001f4:	4803      	ldr	r0, [pc, #12]	; (90000204 <frame_dummy+0x18>)
900001f6:	f3af 8000 	nop.w
900001fa:	bd08      	pop	{r3, pc}
900001fc:	00000000 	.word	0x00000000
90000200:	200000a4 	.word	0x200000a4
90000204:	900055f8 	.word	0x900055f8

90000208 <__aeabi_uldivmod>:
90000208:	b953      	cbnz	r3, 90000220 <__aeabi_uldivmod+0x18>
9000020a:	b94a      	cbnz	r2, 90000220 <__aeabi_uldivmod+0x18>
9000020c:	2900      	cmp	r1, #0
9000020e:	bf08      	it	eq
90000210:	2800      	cmpeq	r0, #0
90000212:	bf1c      	itt	ne
90000214:	f04f 31ff 	movne.w	r1, #4294967295
90000218:	f04f 30ff 	movne.w	r0, #4294967295
9000021c:	f000 b96e 	b.w	900004fc <__aeabi_idiv0>
90000220:	f1ad 0c08 	sub.w	ip, sp, #8
90000224:	e96d ce04 	strd	ip, lr, [sp, #-16]!
90000228:	f000 f806 	bl	90000238 <__udivmoddi4>
9000022c:	f8dd e004 	ldr.w	lr, [sp, #4]
90000230:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
90000234:	b004      	add	sp, #16
90000236:	4770      	bx	lr

90000238 <__udivmoddi4>:
90000238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000023c:	9d08      	ldr	r5, [sp, #32]
9000023e:	4604      	mov	r4, r0
90000240:	468c      	mov	ip, r1
90000242:	2b00      	cmp	r3, #0
90000244:	f040 8083 	bne.w	9000034e <__udivmoddi4+0x116>
90000248:	428a      	cmp	r2, r1
9000024a:	4617      	mov	r7, r2
9000024c:	d947      	bls.n	900002de <__udivmoddi4+0xa6>
9000024e:	fab2 f282 	clz	r2, r2
90000252:	b142      	cbz	r2, 90000266 <__udivmoddi4+0x2e>
90000254:	f1c2 0020 	rsb	r0, r2, #32
90000258:	fa24 f000 	lsr.w	r0, r4, r0
9000025c:	4091      	lsls	r1, r2
9000025e:	4097      	lsls	r7, r2
90000260:	ea40 0c01 	orr.w	ip, r0, r1
90000264:	4094      	lsls	r4, r2
90000266:	ea4f 4817 	mov.w	r8, r7, lsr #16
9000026a:	0c23      	lsrs	r3, r4, #16
9000026c:	fbbc f6f8 	udiv	r6, ip, r8
90000270:	fa1f fe87 	uxth.w	lr, r7
90000274:	fb08 c116 	mls	r1, r8, r6, ip
90000278:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
9000027c:	fb06 f10e 	mul.w	r1, r6, lr
90000280:	4299      	cmp	r1, r3
90000282:	d909      	bls.n	90000298 <__udivmoddi4+0x60>
90000284:	18fb      	adds	r3, r7, r3
90000286:	f106 30ff 	add.w	r0, r6, #4294967295
9000028a:	f080 8119 	bcs.w	900004c0 <__udivmoddi4+0x288>
9000028e:	4299      	cmp	r1, r3
90000290:	f240 8116 	bls.w	900004c0 <__udivmoddi4+0x288>
90000294:	3e02      	subs	r6, #2
90000296:	443b      	add	r3, r7
90000298:	1a5b      	subs	r3, r3, r1
9000029a:	b2a4      	uxth	r4, r4
9000029c:	fbb3 f0f8 	udiv	r0, r3, r8
900002a0:	fb08 3310 	mls	r3, r8, r0, r3
900002a4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
900002a8:	fb00 fe0e 	mul.w	lr, r0, lr
900002ac:	45a6      	cmp	lr, r4
900002ae:	d909      	bls.n	900002c4 <__udivmoddi4+0x8c>
900002b0:	193c      	adds	r4, r7, r4
900002b2:	f100 33ff 	add.w	r3, r0, #4294967295
900002b6:	f080 8105 	bcs.w	900004c4 <__udivmoddi4+0x28c>
900002ba:	45a6      	cmp	lr, r4
900002bc:	f240 8102 	bls.w	900004c4 <__udivmoddi4+0x28c>
900002c0:	3802      	subs	r0, #2
900002c2:	443c      	add	r4, r7
900002c4:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
900002c8:	eba4 040e 	sub.w	r4, r4, lr
900002cc:	2600      	movs	r6, #0
900002ce:	b11d      	cbz	r5, 900002d8 <__udivmoddi4+0xa0>
900002d0:	40d4      	lsrs	r4, r2
900002d2:	2300      	movs	r3, #0
900002d4:	e9c5 4300 	strd	r4, r3, [r5]
900002d8:	4631      	mov	r1, r6
900002da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900002de:	b902      	cbnz	r2, 900002e2 <__udivmoddi4+0xaa>
900002e0:	deff      	udf	#255	; 0xff
900002e2:	fab2 f282 	clz	r2, r2
900002e6:	2a00      	cmp	r2, #0
900002e8:	d150      	bne.n	9000038c <__udivmoddi4+0x154>
900002ea:	1bcb      	subs	r3, r1, r7
900002ec:	ea4f 4e17 	mov.w	lr, r7, lsr #16
900002f0:	fa1f f887 	uxth.w	r8, r7
900002f4:	2601      	movs	r6, #1
900002f6:	fbb3 fcfe 	udiv	ip, r3, lr
900002fa:	0c21      	lsrs	r1, r4, #16
900002fc:	fb0e 331c 	mls	r3, lr, ip, r3
90000300:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
90000304:	fb08 f30c 	mul.w	r3, r8, ip
90000308:	428b      	cmp	r3, r1
9000030a:	d907      	bls.n	9000031c <__udivmoddi4+0xe4>
9000030c:	1879      	adds	r1, r7, r1
9000030e:	f10c 30ff 	add.w	r0, ip, #4294967295
90000312:	d202      	bcs.n	9000031a <__udivmoddi4+0xe2>
90000314:	428b      	cmp	r3, r1
90000316:	f200 80e9 	bhi.w	900004ec <__udivmoddi4+0x2b4>
9000031a:	4684      	mov	ip, r0
9000031c:	1ac9      	subs	r1, r1, r3
9000031e:	b2a3      	uxth	r3, r4
90000320:	fbb1 f0fe 	udiv	r0, r1, lr
90000324:	fb0e 1110 	mls	r1, lr, r0, r1
90000328:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
9000032c:	fb08 f800 	mul.w	r8, r8, r0
90000330:	45a0      	cmp	r8, r4
90000332:	d907      	bls.n	90000344 <__udivmoddi4+0x10c>
90000334:	193c      	adds	r4, r7, r4
90000336:	f100 33ff 	add.w	r3, r0, #4294967295
9000033a:	d202      	bcs.n	90000342 <__udivmoddi4+0x10a>
9000033c:	45a0      	cmp	r8, r4
9000033e:	f200 80d9 	bhi.w	900004f4 <__udivmoddi4+0x2bc>
90000342:	4618      	mov	r0, r3
90000344:	eba4 0408 	sub.w	r4, r4, r8
90000348:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
9000034c:	e7bf      	b.n	900002ce <__udivmoddi4+0x96>
9000034e:	428b      	cmp	r3, r1
90000350:	d909      	bls.n	90000366 <__udivmoddi4+0x12e>
90000352:	2d00      	cmp	r5, #0
90000354:	f000 80b1 	beq.w	900004ba <__udivmoddi4+0x282>
90000358:	2600      	movs	r6, #0
9000035a:	e9c5 0100 	strd	r0, r1, [r5]
9000035e:	4630      	mov	r0, r6
90000360:	4631      	mov	r1, r6
90000362:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90000366:	fab3 f683 	clz	r6, r3
9000036a:	2e00      	cmp	r6, #0
9000036c:	d14a      	bne.n	90000404 <__udivmoddi4+0x1cc>
9000036e:	428b      	cmp	r3, r1
90000370:	d302      	bcc.n	90000378 <__udivmoddi4+0x140>
90000372:	4282      	cmp	r2, r0
90000374:	f200 80b8 	bhi.w	900004e8 <__udivmoddi4+0x2b0>
90000378:	1a84      	subs	r4, r0, r2
9000037a:	eb61 0103 	sbc.w	r1, r1, r3
9000037e:	2001      	movs	r0, #1
90000380:	468c      	mov	ip, r1
90000382:	2d00      	cmp	r5, #0
90000384:	d0a8      	beq.n	900002d8 <__udivmoddi4+0xa0>
90000386:	e9c5 4c00 	strd	r4, ip, [r5]
9000038a:	e7a5      	b.n	900002d8 <__udivmoddi4+0xa0>
9000038c:	f1c2 0320 	rsb	r3, r2, #32
90000390:	fa20 f603 	lsr.w	r6, r0, r3
90000394:	4097      	lsls	r7, r2
90000396:	fa01 f002 	lsl.w	r0, r1, r2
9000039a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
9000039e:	40d9      	lsrs	r1, r3
900003a0:	4330      	orrs	r0, r6
900003a2:	0c03      	lsrs	r3, r0, #16
900003a4:	fbb1 f6fe 	udiv	r6, r1, lr
900003a8:	fa1f f887 	uxth.w	r8, r7
900003ac:	fb0e 1116 	mls	r1, lr, r6, r1
900003b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
900003b4:	fb06 f108 	mul.w	r1, r6, r8
900003b8:	4299      	cmp	r1, r3
900003ba:	fa04 f402 	lsl.w	r4, r4, r2
900003be:	d909      	bls.n	900003d4 <__udivmoddi4+0x19c>
900003c0:	18fb      	adds	r3, r7, r3
900003c2:	f106 3cff 	add.w	ip, r6, #4294967295
900003c6:	f080 808d 	bcs.w	900004e4 <__udivmoddi4+0x2ac>
900003ca:	4299      	cmp	r1, r3
900003cc:	f240 808a 	bls.w	900004e4 <__udivmoddi4+0x2ac>
900003d0:	3e02      	subs	r6, #2
900003d2:	443b      	add	r3, r7
900003d4:	1a5b      	subs	r3, r3, r1
900003d6:	b281      	uxth	r1, r0
900003d8:	fbb3 f0fe 	udiv	r0, r3, lr
900003dc:	fb0e 3310 	mls	r3, lr, r0, r3
900003e0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
900003e4:	fb00 f308 	mul.w	r3, r0, r8
900003e8:	428b      	cmp	r3, r1
900003ea:	d907      	bls.n	900003fc <__udivmoddi4+0x1c4>
900003ec:	1879      	adds	r1, r7, r1
900003ee:	f100 3cff 	add.w	ip, r0, #4294967295
900003f2:	d273      	bcs.n	900004dc <__udivmoddi4+0x2a4>
900003f4:	428b      	cmp	r3, r1
900003f6:	d971      	bls.n	900004dc <__udivmoddi4+0x2a4>
900003f8:	3802      	subs	r0, #2
900003fa:	4439      	add	r1, r7
900003fc:	1acb      	subs	r3, r1, r3
900003fe:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
90000402:	e778      	b.n	900002f6 <__udivmoddi4+0xbe>
90000404:	f1c6 0c20 	rsb	ip, r6, #32
90000408:	fa03 f406 	lsl.w	r4, r3, r6
9000040c:	fa22 f30c 	lsr.w	r3, r2, ip
90000410:	431c      	orrs	r4, r3
90000412:	fa20 f70c 	lsr.w	r7, r0, ip
90000416:	fa01 f306 	lsl.w	r3, r1, r6
9000041a:	ea4f 4e14 	mov.w	lr, r4, lsr #16
9000041e:	fa21 f10c 	lsr.w	r1, r1, ip
90000422:	431f      	orrs	r7, r3
90000424:	0c3b      	lsrs	r3, r7, #16
90000426:	fbb1 f9fe 	udiv	r9, r1, lr
9000042a:	fa1f f884 	uxth.w	r8, r4
9000042e:	fb0e 1119 	mls	r1, lr, r9, r1
90000432:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
90000436:	fb09 fa08 	mul.w	sl, r9, r8
9000043a:	458a      	cmp	sl, r1
9000043c:	fa02 f206 	lsl.w	r2, r2, r6
90000440:	fa00 f306 	lsl.w	r3, r0, r6
90000444:	d908      	bls.n	90000458 <__udivmoddi4+0x220>
90000446:	1861      	adds	r1, r4, r1
90000448:	f109 30ff 	add.w	r0, r9, #4294967295
9000044c:	d248      	bcs.n	900004e0 <__udivmoddi4+0x2a8>
9000044e:	458a      	cmp	sl, r1
90000450:	d946      	bls.n	900004e0 <__udivmoddi4+0x2a8>
90000452:	f1a9 0902 	sub.w	r9, r9, #2
90000456:	4421      	add	r1, r4
90000458:	eba1 010a 	sub.w	r1, r1, sl
9000045c:	b2bf      	uxth	r7, r7
9000045e:	fbb1 f0fe 	udiv	r0, r1, lr
90000462:	fb0e 1110 	mls	r1, lr, r0, r1
90000466:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
9000046a:	fb00 f808 	mul.w	r8, r0, r8
9000046e:	45b8      	cmp	r8, r7
90000470:	d907      	bls.n	90000482 <__udivmoddi4+0x24a>
90000472:	19e7      	adds	r7, r4, r7
90000474:	f100 31ff 	add.w	r1, r0, #4294967295
90000478:	d22e      	bcs.n	900004d8 <__udivmoddi4+0x2a0>
9000047a:	45b8      	cmp	r8, r7
9000047c:	d92c      	bls.n	900004d8 <__udivmoddi4+0x2a0>
9000047e:	3802      	subs	r0, #2
90000480:	4427      	add	r7, r4
90000482:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
90000486:	eba7 0708 	sub.w	r7, r7, r8
9000048a:	fba0 8902 	umull	r8, r9, r0, r2
9000048e:	454f      	cmp	r7, r9
90000490:	46c6      	mov	lr, r8
90000492:	4649      	mov	r1, r9
90000494:	d31a      	bcc.n	900004cc <__udivmoddi4+0x294>
90000496:	d017      	beq.n	900004c8 <__udivmoddi4+0x290>
90000498:	b15d      	cbz	r5, 900004b2 <__udivmoddi4+0x27a>
9000049a:	ebb3 020e 	subs.w	r2, r3, lr
9000049e:	eb67 0701 	sbc.w	r7, r7, r1
900004a2:	fa07 fc0c 	lsl.w	ip, r7, ip
900004a6:	40f2      	lsrs	r2, r6
900004a8:	ea4c 0202 	orr.w	r2, ip, r2
900004ac:	40f7      	lsrs	r7, r6
900004ae:	e9c5 2700 	strd	r2, r7, [r5]
900004b2:	2600      	movs	r6, #0
900004b4:	4631      	mov	r1, r6
900004b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900004ba:	462e      	mov	r6, r5
900004bc:	4628      	mov	r0, r5
900004be:	e70b      	b.n	900002d8 <__udivmoddi4+0xa0>
900004c0:	4606      	mov	r6, r0
900004c2:	e6e9      	b.n	90000298 <__udivmoddi4+0x60>
900004c4:	4618      	mov	r0, r3
900004c6:	e6fd      	b.n	900002c4 <__udivmoddi4+0x8c>
900004c8:	4543      	cmp	r3, r8
900004ca:	d2e5      	bcs.n	90000498 <__udivmoddi4+0x260>
900004cc:	ebb8 0e02 	subs.w	lr, r8, r2
900004d0:	eb69 0104 	sbc.w	r1, r9, r4
900004d4:	3801      	subs	r0, #1
900004d6:	e7df      	b.n	90000498 <__udivmoddi4+0x260>
900004d8:	4608      	mov	r0, r1
900004da:	e7d2      	b.n	90000482 <__udivmoddi4+0x24a>
900004dc:	4660      	mov	r0, ip
900004de:	e78d      	b.n	900003fc <__udivmoddi4+0x1c4>
900004e0:	4681      	mov	r9, r0
900004e2:	e7b9      	b.n	90000458 <__udivmoddi4+0x220>
900004e4:	4666      	mov	r6, ip
900004e6:	e775      	b.n	900003d4 <__udivmoddi4+0x19c>
900004e8:	4630      	mov	r0, r6
900004ea:	e74a      	b.n	90000382 <__udivmoddi4+0x14a>
900004ec:	f1ac 0c02 	sub.w	ip, ip, #2
900004f0:	4439      	add	r1, r7
900004f2:	e713      	b.n	9000031c <__udivmoddi4+0xe4>
900004f4:	3802      	subs	r0, #2
900004f6:	443c      	add	r4, r7
900004f8:	e724      	b.n	90000344 <__udivmoddi4+0x10c>
900004fa:	bf00      	nop

900004fc <__aeabi_idiv0>:
900004fc:	4770      	bx	lr
900004fe:	bf00      	nop

90000500 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
90000500:	f8df d034 	ldr.w	sp, [pc, #52]	; 90000538 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
90000504:	2100      	movs	r1, #0
  b  LoopCopyDataInit
90000506:	e003      	b.n	90000510 <LoopCopyDataInit>

90000508 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
90000508:	4b0c      	ldr	r3, [pc, #48]	; (9000053c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
9000050a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
9000050c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
9000050e:	3104      	adds	r1, #4

90000510 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
90000510:	480b      	ldr	r0, [pc, #44]	; (90000540 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
90000512:	4b0c      	ldr	r3, [pc, #48]	; (90000544 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
90000514:	1842      	adds	r2, r0, r1
  cmp  r2, r3
90000516:	429a      	cmp	r2, r3
  bcc  CopyDataInit
90000518:	d3f6      	bcc.n	90000508 <CopyDataInit>
  ldr  r2, =_sbss
9000051a:	4a0b      	ldr	r2, [pc, #44]	; (90000548 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
9000051c:	e002      	b.n	90000524 <LoopFillZerobss>

9000051e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
9000051e:	2300      	movs	r3, #0
  str  r3, [r2], #4
90000520:	f842 3b04 	str.w	r3, [r2], #4

90000524 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
90000524:	4b09      	ldr	r3, [pc, #36]	; (9000054c <LoopFillZerobss+0x28>)
  cmp  r2, r3
90000526:	429a      	cmp	r2, r3
  bcc  FillZerobss
90000528:	d3f9      	bcc.n	9000051e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
9000052a:	f000 febd 	bl	900012a8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
9000052e:	f004 ff59 	bl	900053e4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
90000532:	f000 f80f 	bl	90000554 <main>
  bx  lr    
90000536:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
90000538:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
9000053c:	90009888 	.word	0x90009888
  ldr  r0, =_sdata
90000540:	20000000 	.word	0x20000000
  ldr  r3, =_edata
90000544:	200000a0 	.word	0x200000a0
  ldr  r2, =_sbss
90000548:	200000a0 	.word	0x200000a0
  ldr  r3, = _ebss
9000054c:	200005c4 	.word	0x200005c4

90000550 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
90000550:	e7fe      	b.n	90000550 <ADC_IRQHandler>
	...

90000554 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
90000554:	b570      	push	{r4, r5, r6, lr}
90000556:	f5ad 6d97 	sub.w	sp, sp, #1208	; 0x4b8
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
9000055a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
9000055e:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
90000562:	4b9a      	ldr	r3, [pc, #616]	; (900007cc <main+0x278>)
90000564:	2100      	movs	r1, #0
90000566:	f8c3 1250 	str.w	r1, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
9000056a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
9000056e:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
90000572:	695a      	ldr	r2, [r3, #20]
90000574:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
90000578:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
9000057a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
9000057e:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
90000582:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
90000586:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
9000058a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
9000058e:	f643 70e0 	movw	r0, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
90000592:	f3c2 01c9 	ubfx	r1, r2, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
90000596:	f3c2 324e 	ubfx	r2, r2, #13, #15
9000059a:	0152      	lsls	r2, r2, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
9000059c:	ea02 0600 	and.w	r6, r2, r0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
900005a0:	460d      	mov	r5, r1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900005a2:	ea46 7485 	orr.w	r4, r6, r5, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
900005a6:	3d01      	subs	r5, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900005a8:	f8c3 4260 	str.w	r4, [r3, #608]	; 0x260
      } while (ways-- != 0U);
900005ac:	d2f9      	bcs.n	900005a2 <main+0x4e>
    } while(sets-- != 0U);
900005ae:	3a20      	subs	r2, #32
900005b0:	f112 0f20 	cmn.w	r2, #32
900005b4:	d1f2      	bne.n	9000059c <main+0x48>
900005b6:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
900005ba:	695a      	ldr	r2, [r3, #20]
900005bc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900005c0:	615a      	str	r2, [r3, #20]
900005c2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
900005c6:	f3bf 8f6f 	isb	sy
         duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
         handled in milliseconds basis.
       - Set NVIC Group Priority to 4
       - Low Level Initialization
     */
  HAL_Init();
900005ca:	f000 feb7 	bl	9000133c <HAL_Init>
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
900005ce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
900005d2:	2101      	movs	r1, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
900005d4:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 400;
900005d6:	2019      	movs	r0, #25
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
900005d8:	94ab      	str	r4, [sp, #684]	; 0x2ac
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
900005da:	e9cd 13a1 	strd	r1, r3, [sp, #644]	; 0x284
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
900005de:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
900005e2:	e9cd 43a7 	strd	r4, r3, [sp, #668]	; 0x29c
  RCC_OscInitStruct.PLL.PLLN = 400;
900005e6:	f44f 73c8 	mov.w	r3, #400	; 0x190
900005ea:	e9cd 03a9 	strd	r0, r3, [sp, #676]	; 0x2a4
  RCC_OscInitStruct.PLL.PLLQ = 8;
900005ee:	2308      	movs	r3, #8
  
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
900005f0:	a8a1      	add	r0, sp, #644	; 0x284
  RCC_OscInitStruct.PLL.PLLQ = 8;
900005f2:	93ac      	str	r3, [sp, #688]	; 0x2b0
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
900005f4:	f001 fbf4 	bl	90001de0 <HAL_RCC_OscConfig>
  if(ret != HAL_OK)
900005f8:	b100      	cbz	r0, 900005fc <main+0xa8>
  {
    while(1) { ; }
900005fa:	e7fe      	b.n	900005fa <main+0xa6>
  }
  
  /* Activate the OverDrive to reach the 200 MHz Frequency */  
  ret = HAL_PWREx_EnableOverDrive();
900005fc:	f001 fbb8 	bl	90001d70 <HAL_PWREx_EnableOverDrive>
  if(ret != HAL_OK)
90000600:	b100      	cbz	r0, 90000604 <main+0xb0>
  {
    while(1) { ; }
90000602:	e7fe      	b.n	90000602 <main+0xae>
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
90000604:	230f      	movs	r3, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; 
90000606:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
9000060a:	9017      	str	r0, [sp, #92]	; 0x5c
  
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
9000060c:	2106      	movs	r1, #6
9000060e:	a815      	add	r0, sp, #84	; 0x54
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
90000610:	e9cd 3415 	strd	r3, r4, [sp, #84]	; 0x54
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; 
90000614:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90000618:	e9cd 2318 	strd	r2, r3, [sp, #96]	; 0x60
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
9000061c:	f001 fdcc 	bl	900021b8 <HAL_RCC_ClockConfig>
  if(ret != HAL_OK)
90000620:	4604      	mov	r4, r0
90000622:	b100      	cbz	r0, 90000626 <main+0xd2>
  {
    while(1) { ; }
90000624:	e7fe      	b.n	90000624 <main+0xd0>
  BSP_LCD_Init();
90000626:	f000 fb5b 	bl	90000ce0 <BSP_LCD_Init>
  BSP_LCD_LayerDefaultInit(0, LCD_FRAME_BUFFER);
9000062a:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
9000062e:	4620      	mov	r0, r4
90000630:	f000 f930 	bl	90000894 <BSP_LCD_LayerDefaultInit>
  BSP_LCD_SelectLayer(0);
90000634:	4620      	mov	r0, r4
90000636:	f000 f965 	bl	90000904 <BSP_LCD_SelectLayer>
  BSP_LCD_DisplayOn();  
9000063a:	f000 fa83 	bl	90000b44 <BSP_LCD_DisplayOn>
  BSP_LCD_SetLayerWindow(0, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
9000063e:	f44f 7388 	mov.w	r3, #272	; 0x110
90000642:	4622      	mov	r2, r4
90000644:	4621      	mov	r1, r4
90000646:	4620      	mov	r0, r4
90000648:	9300      	str	r3, [sp, #0]
9000064a:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
          BSP_LCD_SetTextColor(LCD_COLOR_RED);
9000064e:	4c60      	ldr	r4, [pc, #384]	; (900007d0 <main+0x27c>)
  BSP_LCD_SetLayerWindow(0, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
90000650:	f000 f95e 	bl	90000910 <BSP_LCD_SetLayerWindow>
  BSP_LCD_Clear(LCD_COLOR_WHITE);
90000654:	4628      	mov	r0, r5
          BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  Please insert SD Card                  ");
90000656:	4d5f      	ldr	r5, [pc, #380]	; (900007d4 <main+0x280>)
  BSP_LCD_Clear(LCD_COLOR_WHITE);
90000658:	f000 f97c 	bl	90000954 <BSP_LCD_Clear>
    BSP_SD_Init();
9000065c:	f000 fca2 	bl	90000fa4 <BSP_SD_Init>
    while(BSP_SD_IsDetected() != SD_PRESENT)
90000660:	f000 fb96 	bl	90000d90 <BSP_SD_IsDetected>
90000664:	2801      	cmp	r0, #1
90000666:	d12b      	bne.n	900006c0 <main+0x16c>
    BSP_LCD_Clear(LCD_COLOR_WHITE);
90000668:	f04f 30ff 	mov.w	r0, #4294967295
9000066c:	f000 f972 	bl	90000954 <BSP_LCD_Clear>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
90000670:	4857      	ldr	r0, [pc, #348]	; (900007d0 <main+0x27c>)
90000672:	f000 f965 	bl	90000940 <BSP_LCD_SetTextColor>
    BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  SD Card  Available                ");
90000676:	4958      	ldr	r1, [pc, #352]	; (900007d8 <main+0x284>)
90000678:	2008      	movs	r0, #8
9000067a:	f000 fa4f 	bl	90000b1c <BSP_LCD_DisplayStringAtLine>
    uint8_t wtext[] = "Test SD-Card interface with stm32f7";
9000067e:	4b57      	ldr	r3, [pc, #348]	; (900007dc <main+0x288>)
90000680:	aa0c      	add	r2, sp, #48	; 0x30
90000682:	f103 0520 	add.w	r5, r3, #32
90000686:	6818      	ldr	r0, [r3, #0]
90000688:	3308      	adds	r3, #8
9000068a:	f853 1c04 	ldr.w	r1, [r3, #-4]
9000068e:	4614      	mov	r4, r2
90000690:	42ab      	cmp	r3, r5
90000692:	c403      	stmia	r4!, {r0, r1}
90000694:	4622      	mov	r2, r4
90000696:	d1f6      	bne.n	90000686 <main+0x132>
90000698:	6818      	ldr	r0, [r3, #0]
    if(FATFS_LinkDriver(&SD_Driver, SDTxtPath)==0)
9000069a:	a903      	add	r1, sp, #12
    uint8_t wtext[] = "Test SD-Card interface with stm32f7";
9000069c:	6020      	str	r0, [r4, #0]
    if(FATFS_LinkDriver(&SD_Driver, SDTxtPath)==0)
9000069e:	4850      	ldr	r0, [pc, #320]	; (900007e0 <main+0x28c>)
900006a0:	f004 fdb2 	bl	90005208 <FATFS_LinkDriver>
900006a4:	4604      	mov	r4, r0
900006a6:	2800      	cmp	r0, #0
900006a8:	d150      	bne.n	9000074c <main+0x1f8>
  	       if(f_mount(&SDtxtFatFS, (TCHAR const*)SDTxtPath, 0)!=0)
900006aa:	4602      	mov	r2, r0
900006ac:	a903      	add	r1, sp, #12
900006ae:	a8a1      	add	r0, sp, #644	; 0x284
900006b0:	f004 fa6a 	bl	90004b88 <f_mount>
900006b4:	4605      	mov	r5, r0
900006b6:	b158      	cbz	r0, 900006d0 <main+0x17c>
}

static void Error_Handler(void)
{
  /* Turn LED1 on */
  BSP_LED_On(LED1);
900006b8:	4620      	mov	r0, r4
900006ba:	f000 f8a5 	bl	90000808 <BSP_LED_On>
  while(1)
900006be:	e7fe      	b.n	900006be <main+0x16a>
          BSP_LCD_SetTextColor(LCD_COLOR_RED);
900006c0:	4620      	mov	r0, r4
900006c2:	f000 f93d 	bl	90000940 <BSP_LCD_SetTextColor>
          BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  Please insert SD Card                  ");
900006c6:	4629      	mov	r1, r5
900006c8:	2008      	movs	r0, #8
900006ca:	f000 fa27 	bl	90000b1c <BSP_LCD_DisplayStringAtLine>
900006ce:	e7c7      	b.n	90000660 <main+0x10c>
  	    	   if(f_open(&MyTxtFile,"SdCard.txt", FA_CREATE_ALWAYS|FA_WRITE)!=FR_OK)
900006d0:	220a      	movs	r2, #10
900006d2:	4944      	ldr	r1, [pc, #272]	; (900007e4 <main+0x290>)
900006d4:	a815      	add	r0, sp, #84	; 0x54
900006d6:	f004 fa8b 	bl	90004bf0 <f_open>
900006da:	b118      	cbz	r0, 900006e4 <main+0x190>
  BSP_LED_On(LED1);
900006dc:	4628      	mov	r0, r5
900006de:	f000 f893 	bl	90000808 <BSP_LED_On>
  while(1)
900006e2:	e7fe      	b.n	900006e2 <main+0x18e>
  	    		   res=f_write(&MyTxtFile,wtext,sizeof(wtext)-1,(void*)&bytesWritten);
900006e4:	ab04      	add	r3, sp, #16
900006e6:	2223      	movs	r2, #35	; 0x23
900006e8:	a90c      	add	r1, sp, #48	; 0x30
900006ea:	a815      	add	r0, sp, #84	; 0x54
900006ec:	f004 fc4a 	bl	90004f84 <f_write>
  	    		   char buf[]="Hello World";
900006f0:	4a3d      	ldr	r2, [pc, #244]	; (900007e8 <main+0x294>)
900006f2:	ab05      	add	r3, sp, #20
900006f4:	6810      	ldr	r0, [r2, #0]
900006f6:	6851      	ldr	r1, [r2, #4]
900006f8:	c303      	stmia	r3!, {r0, r1}
900006fa:	6890      	ldr	r0, [r2, #8]
  	    		   res=f_write(&MyTxtFile,buf,sizeof(wtext)-1,(void*)&bytesWritten);
900006fc:	a905      	add	r1, sp, #20
900006fe:	2223      	movs	r2, #35	; 0x23
  	    		   char buf[]="Hello World";
90000700:	6018      	str	r0, [r3, #0]
  	    		   res=f_write(&MyTxtFile,buf,sizeof(wtext)-1,(void*)&bytesWritten);
90000702:	ab04      	add	r3, sp, #16
90000704:	a815      	add	r0, sp, #84	; 0x54
90000706:	f004 fc3d 	bl	90004f84 <f_write>
  	    		   char buf1[]="This is test";
9000070a:	4b38      	ldr	r3, [pc, #224]	; (900007ec <main+0x298>)
9000070c:	aa08      	add	r2, sp, #32
9000070e:	f103 0508 	add.w	r5, r3, #8
90000712:	6818      	ldr	r0, [r3, #0]
90000714:	3308      	adds	r3, #8
90000716:	f853 1c04 	ldr.w	r1, [r3, #-4]
9000071a:	4614      	mov	r4, r2
9000071c:	42ab      	cmp	r3, r5
9000071e:	c403      	stmia	r4!, {r0, r1}
90000720:	4622      	mov	r2, r4
90000722:	d1f6      	bne.n	90000712 <main+0x1be>
90000724:	6818      	ldr	r0, [r3, #0]
  	    		   res=f_write(&MyTxtFile,buf1,sizeof(wtext)-1,(void*)&bytesWritten);
90000726:	2223      	movs	r2, #35	; 0x23
  	    		   char buf1[]="This is test";
90000728:	791b      	ldrb	r3, [r3, #4]
  	    		   res=f_write(&MyTxtFile,buf1,sizeof(wtext)-1,(void*)&bytesWritten);
9000072a:	a908      	add	r1, sp, #32
  	    		   char buf1[]="This is test";
9000072c:	6020      	str	r0, [r4, #0]
  	    		   res=f_write(&MyTxtFile,buf1,sizeof(wtext)-1,(void*)&bytesWritten);
9000072e:	a815      	add	r0, sp, #84	; 0x54
  	    		   char buf1[]="This is test";
90000730:	7123      	strb	r3, [r4, #4]
  	    		   res=f_write(&MyTxtFile,buf1,sizeof(wtext)-1,(void*)&bytesWritten);
90000732:	ab04      	add	r3, sp, #16
90000734:	f004 fc26 	bl	90004f84 <f_write>
  	    		  if((bytesWritten==0)||(res!=FR_OK))
90000738:	9b04      	ldr	r3, [sp, #16]
9000073a:	b103      	cbz	r3, 9000073e <main+0x1ea>
9000073c:	b118      	cbz	r0, 90000746 <main+0x1f2>
  BSP_LED_On(LED1);
9000073e:	2000      	movs	r0, #0
90000740:	f000 f862 	bl	90000808 <BSP_LED_On>
  while(1)
90000744:	e7fe      	b.n	90000744 <main+0x1f0>
  	    			  f_close(&MyTxtFile);
90000746:	a815      	add	r0, sp, #84	; 0x54
90000748:	f004 fd2b 	bl	900051a2 <f_close>
    FATFS_UnLinkDriver(SDTxtPath);
9000074c:	a803      	add	r0, sp, #12
9000074e:	f004 fd77 	bl	90005240 <FATFS_UnLinkDriver>
    HAL_Delay(500);
90000752:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90000756:	f000 fe15 	bl	90001384 <HAL_Delay>
    BSP_LCD_SetTextColor(LCD_COLOR_RED);
9000075a:	481d      	ldr	r0, [pc, #116]	; (900007d0 <main+0x27c>)
9000075c:	f000 f8f0 	bl	90000940 <BSP_LCD_SetTextColor>
              BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  Data Written                  ");
90000760:	4923      	ldr	r1, [pc, #140]	; (900007f0 <main+0x29c>)
90000762:	2008      	movs	r0, #8
90000764:	f000 f9da 	bl	90000b1c <BSP_LCD_DisplayStringAtLine>
    	      res = f_open(&MyTxtFile, "SdCard.txt", FA_READ);
90000768:	2201      	movs	r2, #1
9000076a:	491e      	ldr	r1, [pc, #120]	; (900007e4 <main+0x290>)
9000076c:	a815      	add	r0, sp, #84	; 0x54
9000076e:	f004 fa3f 	bl	90004bf0 <f_open>
    	  f_read (&MyTxtFile, (void *)buffer, f_size(&MyTxtFile),(void *) &bytesRead);
90000772:	ab05      	add	r3, sp, #20
90000774:	9a18      	ldr	r2, [sp, #96]	; 0x60
90000776:	a815      	add	r0, sp, #84	; 0x54
90000778:	9908      	ldr	r1, [sp, #32]
9000077a:	f004 fb51 	bl	90004e20 <f_read>
    	      BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
9000077e:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90000782:	f000 f8dd 	bl	90000940 <BSP_LCD_SetTextColor>
    	      BSP_LCD_DisplayStringAtLine(8, (uint8_t*)(&buffer));
90000786:	a908      	add	r1, sp, #32
90000788:	2008      	movs	r0, #8
9000078a:	f000 f9c7 	bl	90000b1c <BSP_LCD_DisplayStringAtLine>
    	      HAL_Delay(2000);
9000078e:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
90000792:	f000 fdf7 	bl	90001384 <HAL_Delay>
    	      f_read (&MyTxtFile,(void *) buffer, f_size(&MyTxtFile)+1,(void *) &bytesRead);
90000796:	9a18      	ldr	r2, [sp, #96]	; 0x60
90000798:	ab05      	add	r3, sp, #20
9000079a:	9908      	ldr	r1, [sp, #32]
9000079c:	3201      	adds	r2, #1
9000079e:	a815      	add	r0, sp, #84	; 0x54
900007a0:	f004 fb3e 	bl	90004e20 <f_read>
    	      	      BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
900007a4:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
900007a8:	f000 f8ca 	bl	90000940 <BSP_LCD_SetTextColor>
    	      	      BSP_LCD_DisplayStringAtLine(8, (uint8_t*)(&buffer));
900007ac:	a908      	add	r1, sp, #32
900007ae:	2008      	movs	r0, #8
900007b0:	f000 f9b4 	bl	90000b1c <BSP_LCD_DisplayStringAtLine>
    	      	      HAL_Delay(2000);
900007b4:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
900007b8:	f000 fde4 	bl	90001384 <HAL_Delay>
    	      f_close(&MyTxtFile);
900007bc:	a815      	add	r0, sp, #84	; 0x54
900007be:	f004 fcf0 	bl	900051a2 <f_close>
    	      HAL_Delay(1000);
900007c2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
900007c6:	f000 fddd 	bl	90001384 <HAL_Delay>
  while (1)
900007ca:	e7fe      	b.n	900007ca <main+0x276>
900007cc:	e000ed00 	.word	0xe000ed00
900007d0:	ffff0000 	.word	0xffff0000
900007d4:	9000977a 	.word	0x9000977a
900007d8:	900097a4 	.word	0x900097a4
900007dc:	900097f5 	.word	0x900097f5
900007e0:	900093b8 	.word	0x900093b8
900007e4:	900097c9 	.word	0x900097c9
900007e8:	90009819 	.word	0x90009819
900007ec:	90009825 	.word	0x90009825
900007f0:	900097d4 	.word	0x900097d4

900007f4 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
900007f4:	4770      	bx	lr

900007f6 <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
900007f6:	e7fe      	b.n	900007f6 <HardFault_Handler>

900007f8 <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
900007f8:	e7fe      	b.n	900007f8 <MemManage_Handler>

900007fa <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
900007fa:	e7fe      	b.n	900007fa <BusFault_Handler>

900007fc <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
900007fc:	e7fe      	b.n	900007fc <UsageFault_Handler>

900007fe <SVC_Handler>:
900007fe:	4770      	bx	lr

90000800 <DebugMon_Handler>:
90000800:	4770      	bx	lr

90000802 <PendSV_Handler>:
90000802:	4770      	bx	lr

90000804 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
90000804:	f000 bdac 	b.w	90001360 <HAL_IncTick>

90000808 <BSP_LED_On>:
  */
void BSP_LED_On(Led_TypeDef Led)
{
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1)	/* Switch On LED connected to GPIO */
90000808:	b920      	cbnz	r0, 90000814 <BSP_LED_On+0xc>
  {
    gpio_led = LED1_GPIO_PORT;
    HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
9000080a:	2201      	movs	r2, #1
9000080c:	2102      	movs	r1, #2
9000080e:	4802      	ldr	r0, [pc, #8]	; (90000818 <BSP_LED_On+0x10>)
90000810:	f001 b930 	b.w	90001a74 <HAL_GPIO_WritePin>
  }
}
90000814:	4770      	bx	lr
90000816:	bf00      	nop
90000818:	40022000 	.word	0x40022000

9000081c <LL_FillBuffer>:
  * @param  OffLine: Offset
  * @param  ColorIndex: Color index
  * @retval None
  */
static void LL_FillBuffer(uint32_t LayerIndex, void *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t ColorIndex) 
{
9000081c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  /* Register to memory mode with ARGB8888 as color Mode */ 
  hDma2dHandler.Init.Mode         = DMA2D_R2M;
90000820:	4c19      	ldr	r4, [pc, #100]	; (90000888 <LL_FillBuffer+0x6c>)
{
90000822:	4698      	mov	r8, r3
  hDma2dHandler.Init.Mode         = DMA2D_R2M;
90000824:	f44f 3340 	mov.w	r3, #196608	; 0x30000
{
90000828:	460e      	mov	r6, r1
9000082a:	4617      	mov	r7, r2
  if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
9000082c:	2134      	movs	r1, #52	; 0x34
9000082e:	4a17      	ldr	r2, [pc, #92]	; (9000088c <LL_FillBuffer+0x70>)
{
90000830:	4681      	mov	r9, r0
  hDma2dHandler.Init.Mode         = DMA2D_R2M;
90000832:	6063      	str	r3, [r4, #4]
  hDma2dHandler.Init.OutputOffset = OffLine;      
  
  hDma2dHandler.Instance = DMA2D;
  
  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK) 
90000834:	4620      	mov	r0, r4
  if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
90000836:	6c23      	ldr	r3, [r4, #64]	; 0x40
{
90000838:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
  if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
9000083c:	fb01 2303 	mla	r3, r1, r3, r2
90000840:	6c9d      	ldr	r5, [r3, #72]	; 0x48
  hDma2dHandler.Init.OutputOffset = OffLine;      
90000842:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    hDma2dHandler.Init.ColorMode    = DMA2D_ARGB8888;
90000844:	2d02      	cmp	r5, #2
  hDma2dHandler.Init.OutputOffset = OffLine;      
90000846:	60e3      	str	r3, [r4, #12]
    hDma2dHandler.Init.ColorMode    = DMA2D_ARGB8888;
90000848:	bf18      	it	ne
9000084a:	2500      	movne	r5, #0
  hDma2dHandler.Instance = DMA2D;
9000084c:	4b10      	ldr	r3, [pc, #64]	; (90000890 <LL_FillBuffer+0x74>)
9000084e:	60a5      	str	r5, [r4, #8]
90000850:	6023      	str	r3, [r4, #0]
  if(HAL_DMA2D_Init(&hDma2dHandler) == HAL_OK) 
90000852:	f000 ff14 	bl	9000167e <HAL_DMA2D_Init>
90000856:	b9a0      	cbnz	r0, 90000882 <LL_FillBuffer+0x66>
  {
    if(HAL_DMA2D_ConfigLayer(&hDma2dHandler, LayerIndex) == HAL_OK) 
90000858:	4649      	mov	r1, r9
9000085a:	4620      	mov	r0, r4
9000085c:	f000 ffd6 	bl	9000180c <HAL_DMA2D_ConfigLayer>
90000860:	b978      	cbnz	r0, 90000882 <LL_FillBuffer+0x66>
    {
      if (HAL_DMA2D_Start(&hDma2dHandler, ColorIndex, (uint32_t)pDst, xSize, ySize) == HAL_OK)
90000862:	463b      	mov	r3, r7
90000864:	4632      	mov	r2, r6
90000866:	4651      	mov	r1, sl
90000868:	4620      	mov	r0, r4
9000086a:	f8cd 8000 	str.w	r8, [sp]
9000086e:	f000 ff32 	bl	900016d6 <HAL_DMA2D_Start>
90000872:	b930      	cbnz	r0, 90000882 <LL_FillBuffer+0x66>
      {
        /* Polling For DMA transfer */  
        HAL_DMA2D_PollForTransfer(&hDma2dHandler, 10);
90000874:	210a      	movs	r1, #10
90000876:	4620      	mov	r0, r4
      }
    }
  } 
}
90000878:	b002      	add	sp, #8
9000087a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        HAL_DMA2D_PollForTransfer(&hDma2dHandler, 10);
9000087e:	f000 bf44 	b.w	9000170a <HAL_DMA2D_PollForTransfer>
}
90000882:	b002      	add	sp, #8
90000884:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90000888:	200000bc 	.word	0x200000bc
9000088c:	20000450 	.word	0x20000450
90000890:	4002b000 	.word	0x4002b000

90000894 <BSP_LCD_LayerDefaultInit>:
{     
90000894:	b570      	push	{r4, r5, r6, lr}
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000896:	4d18      	ldr	r5, [pc, #96]	; (900008f8 <BSP_LCD_LayerDefaultInit+0x64>)
{     
90000898:	4604      	mov	r4, r0
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
9000089a:	2634      	movs	r6, #52	; 0x34
9000089c:	4817      	ldr	r0, [pc, #92]	; (900008fc <BSP_LCD_LayerDefaultInit+0x68>)
9000089e:	6c2a      	ldr	r2, [r5, #64]	; 0x40
{     
900008a0:	b08e      	sub	sp, #56	; 0x38
  layer_cfg.WindowX0 = 0;
900008a2:	2300      	movs	r3, #0
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
900008a4:	fb06 0202 	mla	r2, r6, r2, r0
  layer_cfg.FBStartAdress = FB_Address;
900008a8:	910a      	str	r1, [sp, #40]	; 0x28
  layer_cfg.Alpha = 255;
900008aa:	21ff      	movs	r1, #255	; 0xff
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
900008ac:	6e16      	ldr	r6, [r2, #96]	; 0x60
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
900008ae:	6e52      	ldr	r2, [r2, #100]	; 0x64
  layer_cfg.WindowX0 = 0;
900008b0:	9301      	str	r3, [sp, #4]
  layer_cfg.Backcolor.Blue = 0;
900008b2:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
  layer_cfg.Backcolor.Red = 0;
900008b6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
  layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
900008ba:	e9cd 2304 	strd	r2, r3, [sp, #16]
  layer_cfg.Alpha0 = 0;
900008be:	e9cd 1306 	strd	r1, r3, [sp, #24]
  layer_cfg.WindowY0 = 0;
900008c2:	e9cd 6302 	strd	r6, r3, [sp, #8]
  layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
900008c6:	f44f 61c0 	mov.w	r1, #1536	; 0x600
900008ca:	2307      	movs	r3, #7
  layer_cfg.ImageHeight = BSP_LCD_GetYSize();
900008cc:	e9cd 620b 	strd	r6, r2, [sp, #44]	; 0x2c
  layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
900008d0:	e9cd 1308 	strd	r1, r3, [sp, #32]
  HAL_LTDC_ConfigLayer(&hLtdcHandler, &layer_cfg, LayerIndex); 
900008d4:	4622      	mov	r2, r4
900008d6:	a901      	add	r1, sp, #4
900008d8:	f001 f9c4 	bl	90001c64 <HAL_LTDC_ConfigLayer>
  DrawProp[LayerIndex].BackColor = LCD_COLOR_WHITE;
900008dc:	200c      	movs	r0, #12
900008de:	f04f 33ff 	mov.w	r3, #4294967295
900008e2:	fb00 5004 	mla	r0, r0, r4, r5
900008e6:	6483      	str	r3, [r0, #72]	; 0x48
  DrawProp[LayerIndex].pFont     = &Font24;
900008e8:	4b05      	ldr	r3, [pc, #20]	; (90000900 <BSP_LCD_LayerDefaultInit+0x6c>)
900008ea:	64c3      	str	r3, [r0, #76]	; 0x4c
  DrawProp[LayerIndex].TextColor = LCD_COLOR_BLACK; 
900008ec:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
900008f0:	6443      	str	r3, [r0, #68]	; 0x44
}
900008f2:	b00e      	add	sp, #56	; 0x38
900008f4:	bd70      	pop	{r4, r5, r6, pc}
900008f6:	bf00      	nop
900008f8:	200000bc 	.word	0x200000bc
900008fc:	20000450 	.word	0x20000450
90000900:	20000000 	.word	0x20000000

90000904 <BSP_LCD_SelectLayer>:
  ActiveLayer = LayerIndex;
90000904:	4b01      	ldr	r3, [pc, #4]	; (9000090c <BSP_LCD_SelectLayer+0x8>)
90000906:	6418      	str	r0, [r3, #64]	; 0x40
} 
90000908:	4770      	bx	lr
9000090a:	bf00      	nop
9000090c:	200000bc 	.word	0x200000bc

90000910 <BSP_LCD_SetLayerWindow>:
{
90000910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_LTDC_SetWindowSize(&hLtdcHandler, Width, Height, LayerIndex);
90000914:	4f09      	ldr	r7, [pc, #36]	; (9000093c <BSP_LCD_SetLayerWindow+0x2c>)
{
90000916:	4604      	mov	r4, r0
90000918:	460d      	mov	r5, r1
9000091a:	4616      	mov	r6, r2
9000091c:	4619      	mov	r1, r3
  HAL_LTDC_SetWindowSize(&hLtdcHandler, Width, Height, LayerIndex);
9000091e:	f8bd 2018 	ldrh.w	r2, [sp, #24]
90000922:	4603      	mov	r3, r0
90000924:	4638      	mov	r0, r7
90000926:	f001 f9ca 	bl	90001cbe <HAL_LTDC_SetWindowSize>
  HAL_LTDC_SetWindowPosition(&hLtdcHandler, Xpos, Ypos, LayerIndex); 
9000092a:	4623      	mov	r3, r4
9000092c:	4632      	mov	r2, r6
9000092e:	4629      	mov	r1, r5
90000930:	4638      	mov	r0, r7
}
90000932:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_LTDC_SetWindowPosition(&hLtdcHandler, Xpos, Ypos, LayerIndex); 
90000936:	f001 b9ef 	b.w	90001d18 <HAL_LTDC_SetWindowPosition>
9000093a:	bf00      	nop
9000093c:	20000450 	.word	0x20000450

90000940 <BSP_LCD_SetTextColor>:
  DrawProp[ActiveLayer].TextColor = Color;
90000940:	4a03      	ldr	r2, [pc, #12]	; (90000950 <BSP_LCD_SetTextColor+0x10>)
90000942:	210c      	movs	r1, #12
90000944:	6c13      	ldr	r3, [r2, #64]	; 0x40
90000946:	fb01 2303 	mla	r3, r1, r3, r2
9000094a:	6458      	str	r0, [r3, #68]	; 0x44
}
9000094c:	4770      	bx	lr
9000094e:	bf00      	nop
90000950:	200000bc 	.word	0x200000bc

90000954 <BSP_LCD_Clear>:
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
90000954:	4b08      	ldr	r3, [pc, #32]	; (90000978 <BSP_LCD_Clear+0x24>)
{ 
90000956:	b513      	push	{r0, r1, r4, lr}
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
90000958:	6c1c      	ldr	r4, [r3, #64]	; 0x40
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
9000095a:	2134      	movs	r1, #52	; 0x34
9000095c:	4b07      	ldr	r3, [pc, #28]	; (9000097c <BSP_LCD_Clear+0x28>)
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
9000095e:	9001      	str	r0, [sp, #4]
90000960:	4620      	mov	r0, r4
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageHeight;
90000962:	fb01 3104 	mla	r1, r1, r4, r3
  LL_FillBuffer(ActiveLayer, (uint32_t *)(hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress), BSP_LCD_GetXSize(), BSP_LCD_GetYSize(), 0, Color);
90000966:	2300      	movs	r3, #0
90000968:	9300      	str	r3, [sp, #0]
9000096a:	e9d1 2318 	ldrd	r2, r3, [r1, #96]	; 0x60
9000096e:	6dc9      	ldr	r1, [r1, #92]	; 0x5c
90000970:	f7ff ff54 	bl	9000081c <LL_FillBuffer>
}
90000974:	b002      	add	sp, #8
90000976:	bd10      	pop	{r4, pc}
90000978:	200000bc 	.word	0x200000bc
9000097c:	20000450 	.word	0x20000450

90000980 <BSP_LCD_DrawPixel>:
  if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
90000980:	4b0a      	ldr	r3, [pc, #40]	; (900009ac <BSP_LCD_DrawPixel+0x2c>)
{
90000982:	b530      	push	{r4, r5, lr}
  if(hLtdcHandler.LayerCfg[ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
90000984:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90000986:	2534      	movs	r5, #52	; 0x34
90000988:	4c09      	ldr	r4, [pc, #36]	; (900009b0 <BSP_LCD_DrawPixel+0x30>)
9000098a:	fb05 4303 	mla	r3, r5, r3, r4
9000098e:	e9d3 4517 	ldrd	r4, r5, [r3, #92]	; 0x5c
90000992:	6c9b      	ldr	r3, [r3, #72]	; 0x48
90000994:	fb05 0101 	mla	r1, r5, r1, r0
90000998:	2b02      	cmp	r3, #2
9000099a:	d103      	bne.n	900009a4 <BSP_LCD_DrawPixel+0x24>
    *(__IO uint16_t*) (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + (2*(Ypos*BSP_LCD_GetXSize() + Xpos))) = (uint16_t)RGB_Code;
9000099c:	b292      	uxth	r2, r2
9000099e:	f824 2011 	strh.w	r2, [r4, r1, lsl #1]
}
900009a2:	bd30      	pop	{r4, r5, pc}
    *(__IO uint32_t*) (hLtdcHandler.LayerCfg[ActiveLayer].FBStartAdress + (4*(Ypos*BSP_LCD_GetXSize() + Xpos))) = RGB_Code;
900009a4:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
}
900009a8:	e7fb      	b.n	900009a2 <BSP_LCD_DrawPixel+0x22>
900009aa:	bf00      	nop
900009ac:	200000bc 	.word	0x200000bc
900009b0:	20000450 	.word	0x20000450

900009b4 <BSP_LCD_DisplayChar>:
{
900009b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
900009b8:	b085      	sub	sp, #20
  DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
900009ba:	f1a2 0520 	sub.w	r5, r2, #32
  for(i = 0; i < height; i++)
900009be:	f04f 0800 	mov.w	r8, #0
{
900009c2:	e9cd 0100 	strd	r0, r1, [sp]
  DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
900009c6:	4828      	ldr	r0, [pc, #160]	; (90000a68 <BSP_LCD_DisplayChar+0xb4>)
900009c8:	210c      	movs	r1, #12
900009ca:	f8d0 b040 	ldr.w	fp, [r0, #64]	; 0x40
900009ce:	fb01 010b 	mla	r1, r1, fp, r0
900009d2:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
    DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
900009d4:	f8b1 9004 	ldrh.w	r9, [r1, #4]
900009d8:	f8b1 a006 	ldrh.w	sl, [r1, #6]
900009dc:	f109 0607 	add.w	r6, r9, #7
900009e0:	680a      	ldr	r2, [r1, #0]
  DrawChar(Xpos, Ypos, &DrawProp[ActiveLayer].pFont->table[(Ascii-' ') *\
900009e2:	fb0a f505 	mul.w	r5, sl, r5
    DrawProp[ActiveLayer].pFont->Height * ((DrawProp[ActiveLayer].pFont->Width + 7) / 8)]);
900009e6:	10f6      	asrs	r6, r6, #3
  offset =  8 *((width + 7)/8) -  width ;
900009e8:	ebc9 00c6 	rsb	r0, r9, r6, lsl #3
  for(i = 0; i < height; i++)
900009ec:	fb06 2505 	mla	r5, r6, r5, r2
      if(line & (1 << (width- j + offset- 1))) 
900009f0:	f109 32ff 	add.w	r2, r9, #4294967295
900009f4:	fa52 f380 	uxtab	r3, r2, r0
900009f8:	9302      	str	r3, [sp, #8]
900009fa:	9b01      	ldr	r3, [sp, #4]
  for(i = 0; i < height; i++)
900009fc:	45d0      	cmp	r8, sl
900009fe:	eb03 0108 	add.w	r1, r3, r8
90000a02:	b289      	uxth	r1, r1
90000a04:	d302      	bcc.n	90000a0c <BSP_LCD_DisplayChar+0x58>
}
90000a06:	b005      	add	sp, #20
90000a08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch(((width + 7)/8))
90000a0c:	2e01      	cmp	r6, #1
90000a0e:	782c      	ldrb	r4, [r5, #0]
90000a10:	d004      	beq.n	90000a1c <BSP_LCD_DisplayChar+0x68>
90000a12:	2e02      	cmp	r6, #2
90000a14:	d109      	bne.n	90000a2a <BSP_LCD_DisplayChar+0x76>
      line =  (pchar[0]<< 8) | pchar[1];      
90000a16:	882c      	ldrh	r4, [r5, #0]
90000a18:	ba64      	rev16	r4, r4
90000a1a:	b2a4      	uxth	r4, r4
    for (j = 0; j < width; j++)
90000a1c:	2700      	movs	r7, #0
90000a1e:	45b9      	cmp	r9, r7
90000a20:	d80a      	bhi.n	90000a38 <BSP_LCD_DisplayChar+0x84>
  for(i = 0; i < height; i++)
90000a22:	f108 0801 	add.w	r8, r8, #1
90000a26:	4435      	add	r5, r6
90000a28:	e7e7      	b.n	900009fa <BSP_LCD_DisplayChar+0x46>
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];      
90000a2a:	786a      	ldrb	r2, [r5, #1]
90000a2c:	0424      	lsls	r4, r4, #16
90000a2e:	ea44 2402 	orr.w	r4, r4, r2, lsl #8
90000a32:	78aa      	ldrb	r2, [r5, #2]
90000a34:	4314      	orrs	r4, r2
      break;
90000a36:	e7f1      	b.n	90000a1c <BSP_LCD_DisplayChar+0x68>
      if(line & (1 << (width- j + offset- 1))) 
90000a38:	9b00      	ldr	r3, [sp, #0]
90000a3a:	2201      	movs	r2, #1
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].BackColor);
90000a3c:	9103      	str	r1, [sp, #12]
90000a3e:	19d8      	adds	r0, r3, r7
      if(line & (1 << (width- j + offset- 1))) 
90000a40:	9b02      	ldr	r3, [sp, #8]
90000a42:	eba3 0c07 	sub.w	ip, r3, r7
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
90000a46:	4b08      	ldr	r3, [pc, #32]	; (90000a68 <BSP_LCD_DisplayChar+0xb4>)
90000a48:	b280      	uxth	r0, r0
    for (j = 0; j < width; j++)
90000a4a:	3701      	adds	r7, #1
      if(line & (1 << (width- j + offset- 1))) 
90000a4c:	fa02 f20c 	lsl.w	r2, r2, ip
90000a50:	4222      	tst	r2, r4
90000a52:	f04f 020c 	mov.w	r2, #12
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].TextColor);
90000a56:	fb02 320b 	mla	r2, r2, fp, r3
90000a5a:	bf14      	ite	ne
90000a5c:	6c52      	ldrne	r2, [r2, #68]	; 0x44
        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp[ActiveLayer].BackColor);
90000a5e:	6c92      	ldreq	r2, [r2, #72]	; 0x48
90000a60:	f7ff ff8e 	bl	90000980 <BSP_LCD_DrawPixel>
90000a64:	9903      	ldr	r1, [sp, #12]
    for (j = 0; j < width; j++)
90000a66:	e7da      	b.n	90000a1e <BSP_LCD_DisplayChar+0x6a>
90000a68:	200000bc 	.word	0x200000bc

90000a6c <BSP_LCD_DisplayStringAt>:
{
90000a6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
90000a70:	4605      	mov	r5, r0
90000a72:	468a      	mov	sl, r1
90000a74:	4616      	mov	r6, r2
  while (*ptr++) size ++ ;
90000a76:	4614      	mov	r4, r2
90000a78:	f812 0b01 	ldrb.w	r0, [r2], #1
90000a7c:	2800      	cmp	r0, #0
90000a7e:	d1fa      	bne.n	90000a76 <BSP_LCD_DisplayStringAt+0xa>
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000a80:	4824      	ldr	r0, [pc, #144]	; (90000b14 <BSP_LCD_DisplayStringAt+0xa8>)
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
90000a82:	220c      	movs	r2, #12
  switch (Mode)
90000a84:	2b01      	cmp	r3, #1
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000a86:	6c01      	ldr	r1, [r0, #64]	; 0x40
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
90000a88:	fb02 0201 	mla	r2, r2, r1, r0
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000a8c:	f04f 0034 	mov.w	r0, #52	; 0x34
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
90000a90:	6cd7      	ldr	r7, [r2, #76]	; 0x4c
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000a92:	4a21      	ldr	r2, [pc, #132]	; (90000b18 <BSP_LCD_DisplayStringAt+0xac>)
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
90000a94:	f8b7 e004 	ldrh.w	lr, [r7, #4]
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000a98:	fb00 2001 	mla	r0, r0, r1, r2
  xsize = (BSP_LCD_GetXSize()/DrawProp[ActiveLayer].pFont->Width);
90000a9c:	6e00      	ldr	r0, [r0, #96]	; 0x60
90000a9e:	fbb0 f0fe 	udiv	r0, r0, lr
  switch (Mode)
90000aa2:	d021      	beq.n	90000ae8 <BSP_LCD_DisplayStringAt+0x7c>
90000aa4:	2b02      	cmp	r3, #2
90000aa6:	d027      	beq.n	90000af8 <BSP_LCD_DisplayStringAt+0x8c>
  if ((ref_column < 1) || (ref_column >= 0x8000))
90000aa8:	b22b      	sxth	r3, r5
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000aaa:	f04f 0834 	mov.w	r8, #52	; 0x34
    ref_column = 1;
90000aae:	f04f 0900 	mov.w	r9, #0
90000ab2:	2b00      	cmp	r3, #0
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000ab4:	fb08 2801 	mla	r8, r8, r1, r2
    ref_column = 1;
90000ab8:	bfd8      	it	le
90000aba:	2501      	movle	r5, #1
  while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
90000abc:	88bc      	ldrh	r4, [r7, #4]
90000abe:	fa1f f389 	uxth.w	r3, r9
90000ac2:	f8d8 0060 	ldr.w	r0, [r8, #96]	; 0x60
90000ac6:	f816 2009 	ldrb.w	r2, [r6, r9]
  return hLtdcHandler.LayerCfg[ActiveLayer].ImageWidth;
90000aca:	f109 0901 	add.w	r9, r9, #1
  while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp[ActiveLayer].pFont->Width)) & 0xFFFF) >= DrawProp[ActiveLayer].pFont->Width))
90000ace:	fb04 0313 	mls	r3, r4, r3, r0
90000ad2:	b29b      	uxth	r3, r3
90000ad4:	42a3      	cmp	r3, r4
90000ad6:	bf34      	ite	cc
90000ad8:	2300      	movcc	r3, #0
90000ada:	2301      	movcs	r3, #1
90000adc:	2a00      	cmp	r2, #0
90000ade:	bf08      	it	eq
90000ae0:	2300      	moveq	r3, #0
90000ae2:	b97b      	cbnz	r3, 90000b04 <BSP_LCD_DisplayStringAt+0x98>
}
90000ae4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      ref_column = Xpos + ((xsize - size)* DrawProp[ActiveLayer].pFont->Width) / 2;
90000ae8:	1b34      	subs	r4, r6, r4
90000aea:	4404      	add	r4, r0
90000aec:	fb0e f404 	mul.w	r4, lr, r4
90000af0:	eb05 0054 	add.w	r0, r5, r4, lsr #1
      ref_column = - Xpos + ((xsize - size)*DrawProp[ActiveLayer].pFont->Width);
90000af4:	b285      	uxth	r5, r0
      break;
90000af6:	e7d7      	b.n	90000aa8 <BSP_LCD_DisplayStringAt+0x3c>
      ref_column = - Xpos + ((xsize - size)*DrawProp[ActiveLayer].pFont->Width);
90000af8:	1b34      	subs	r4, r6, r4
90000afa:	4404      	add	r4, r0
90000afc:	fb14 f40e 	smulbb	r4, r4, lr
90000b00:	1b60      	subs	r0, r4, r5
90000b02:	e7f7      	b.n	90000af4 <BSP_LCD_DisplayStringAt+0x88>
    BSP_LCD_DisplayChar(ref_column, Ypos, *Text);
90000b04:	4628      	mov	r0, r5
90000b06:	4651      	mov	r1, sl
90000b08:	f7ff ff54 	bl	900009b4 <BSP_LCD_DisplayChar>
    ref_column += DrawProp[ActiveLayer].pFont->Width;
90000b0c:	88b8      	ldrh	r0, [r7, #4]
90000b0e:	4428      	add	r0, r5
90000b10:	b285      	uxth	r5, r0
    i++;
90000b12:	e7d3      	b.n	90000abc <BSP_LCD_DisplayStringAt+0x50>
90000b14:	200000bc 	.word	0x200000bc
90000b18:	20000450 	.word	0x20000450

90000b1c <BSP_LCD_DisplayStringAtLine>:
{  
90000b1c:	b410      	push	{r4}
  return DrawProp[ActiveLayer].pFont;
90000b1e:	4c08      	ldr	r4, [pc, #32]	; (90000b40 <BSP_LCD_DisplayStringAtLine+0x24>)
{  
90000b20:	460a      	mov	r2, r1
  return DrawProp[ActiveLayer].pFont;
90000b22:	210c      	movs	r1, #12
90000b24:	6c23      	ldr	r3, [r4, #64]	; 0x40
90000b26:	fb01 4303 	mla	r3, r1, r3, r4
}
90000b2a:	f85d 4b04 	ldr.w	r4, [sp], #4
  BSP_LCD_DisplayStringAt(0, LINE(Line), ptr, LEFT_MODE);
90000b2e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90000b30:	88db      	ldrh	r3, [r3, #6]
90000b32:	fb13 f000 	smulbb	r0, r3, r0
90000b36:	2303      	movs	r3, #3
90000b38:	b281      	uxth	r1, r0
90000b3a:	2000      	movs	r0, #0
90000b3c:	f7ff bf96 	b.w	90000a6c <BSP_LCD_DisplayStringAt>
90000b40:	200000bc 	.word	0x200000bc

90000b44 <BSP_LCD_DisplayOn>:
{
90000b44:	b508      	push	{r3, lr}
  __HAL_LTDC_ENABLE(&hLtdcHandler);
90000b46:	4b09      	ldr	r3, [pc, #36]	; (90000b6c <BSP_LCD_DisplayOn+0x28>)
  HAL_GPIO_WritePin(LCD_DISP_GPIO_PORT, LCD_DISP_PIN, GPIO_PIN_SET);        /* Assert LCD_DISP pin */
90000b48:	f44f 5180 	mov.w	r1, #4096	; 0x1000
90000b4c:	4808      	ldr	r0, [pc, #32]	; (90000b70 <BSP_LCD_DisplayOn+0x2c>)
  __HAL_LTDC_ENABLE(&hLtdcHandler);
90000b4e:	681a      	ldr	r2, [r3, #0]
90000b50:	6993      	ldr	r3, [r2, #24]
90000b52:	f043 0301 	orr.w	r3, r3, #1
90000b56:	6193      	str	r3, [r2, #24]
  HAL_GPIO_WritePin(LCD_DISP_GPIO_PORT, LCD_DISP_PIN, GPIO_PIN_SET);        /* Assert LCD_DISP pin */
90000b58:	2201      	movs	r2, #1
90000b5a:	f000 ff8b 	bl	90001a74 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_PORT, LCD_BL_CTRL_PIN, GPIO_PIN_SET);  /* Assert LCD_BL_CTRL pin */
90000b5e:	2201      	movs	r2, #1
90000b60:	2108      	movs	r1, #8
90000b62:	4804      	ldr	r0, [pc, #16]	; (90000b74 <BSP_LCD_DisplayOn+0x30>)
}
90000b64:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_PORT, LCD_BL_CTRL_PIN, GPIO_PIN_SET);  /* Assert LCD_BL_CTRL pin */
90000b68:	f000 bf84 	b.w	90001a74 <HAL_GPIO_WritePin>
90000b6c:	20000450 	.word	0x20000450
90000b70:	40022000 	.word	0x40022000
90000b74:	40022800 	.word	0x40022800

90000b78 <BSP_LCD_MspInit>:
  __HAL_RCC_LTDC_CLK_ENABLE();
90000b78:	4b4b      	ldr	r3, [pc, #300]	; (90000ca8 <BSP_LCD_MspInit+0x130>)
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
90000b7a:	484c      	ldr	r0, [pc, #304]	; (90000cac <BSP_LCD_MspInit+0x134>)
  __HAL_RCC_LTDC_CLK_ENABLE();
90000b7c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
90000b7e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
{
90000b82:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_RCC_LTDC_CLK_ENABLE();
90000b84:	645a      	str	r2, [r3, #68]	; 0x44
{
90000b86:	b08f      	sub	sp, #60	; 0x3c
  __HAL_RCC_LTDC_CLK_ENABLE();
90000b88:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90000b8a:	2402      	movs	r4, #2
  gpio_init_structure.Alternate = GPIO_AF14_LTDC;  
90000b8c:	250e      	movs	r5, #14
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
90000b8e:	a909      	add	r1, sp, #36	; 0x24
  __HAL_RCC_LTDC_CLK_ENABLE();
90000b90:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
  gpio_init_structure.Pin       = GPIO_PIN_12;
90000b94:	f44f 5780 	mov.w	r7, #4096	; 0x1000
  HAL_GPIO_Init(GPIOI, &gpio_init_structure);
90000b98:	4e45      	ldr	r6, [pc, #276]	; (90000cb0 <BSP_LCD_MspInit+0x138>)
  __HAL_RCC_LTDC_CLK_ENABLE();
90000b9a:	9200      	str	r2, [sp, #0]
90000b9c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_DMA2D_CLK_ENABLE();
90000b9e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000ba0:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
90000ba4:	631a      	str	r2, [r3, #48]	; 0x30
90000ba6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000ba8:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
90000bac:	9201      	str	r2, [sp, #4]
90000bae:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOE_CLK_ENABLE();
90000bb0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bb2:	f042 0210 	orr.w	r2, r2, #16
90000bb6:	631a      	str	r2, [r3, #48]	; 0x30
90000bb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bba:	f002 0210 	and.w	r2, r2, #16
90000bbe:	9202      	str	r2, [sp, #8]
90000bc0:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
90000bc2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bc4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
90000bc8:	631a      	str	r2, [r3, #48]	; 0x30
90000bca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bcc:	f002 0240 	and.w	r2, r2, #64	; 0x40
90000bd0:	9203      	str	r2, [sp, #12]
90000bd2:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOI_CLK_ENABLE();
90000bd4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bd6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
90000bda:	631a      	str	r2, [r3, #48]	; 0x30
90000bdc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bde:	f402 7280 	and.w	r2, r2, #256	; 0x100
90000be2:	9204      	str	r2, [sp, #16]
90000be4:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
90000be6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000be8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
90000bec:	631a      	str	r2, [r3, #48]	; 0x30
90000bee:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bf0:	f402 7200 	and.w	r2, r2, #512	; 0x200
90000bf4:	9205      	str	r2, [sp, #20]
90000bf6:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOK_CLK_ENABLE();
90000bf8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000bfa:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
90000bfe:	631a      	str	r2, [r3, #48]	; 0x30
90000c00:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000c02:	f402 6280 	and.w	r2, r2, #1024	; 0x400
90000c06:	9206      	str	r2, [sp, #24]
90000c08:	9a06      	ldr	r2, [sp, #24]
  LCD_DISP_GPIO_CLK_ENABLE();
90000c0a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000c0c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
90000c10:	631a      	str	r2, [r3, #48]	; 0x30
90000c12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000c14:	f402 7280 	and.w	r2, r2, #256	; 0x100
90000c18:	9207      	str	r2, [sp, #28]
90000c1a:	9a07      	ldr	r2, [sp, #28]
  LCD_BL_CTRL_GPIO_CLK_ENABLE();
90000c1c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000c1e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
90000c22:	631a      	str	r2, [r3, #48]	; 0x30
90000c24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  gpio_init_structure.Alternate = GPIO_AF14_LTDC;  
90000c26:	950d      	str	r5, [sp, #52]	; 0x34
  LCD_BL_CTRL_GPIO_CLK_ENABLE();
90000c28:	f403 6380 	and.w	r3, r3, #1024	; 0x400
90000c2c:	9308      	str	r3, [sp, #32]
90000c2e:	9b08      	ldr	r3, [sp, #32]
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90000c30:	2310      	movs	r3, #16
90000c32:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
  gpio_init_structure.Pull      = GPIO_NOPULL;
90000c36:	2300      	movs	r3, #0
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
90000c38:	e9cd 340b 	strd	r3, r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
90000c3c:	f000 fe2e 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Alternate = GPIO_AF9_LTDC;
90000c40:	2309      	movs	r3, #9
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
90000c42:	a909      	add	r1, sp, #36	; 0x24
90000c44:	481b      	ldr	r0, [pc, #108]	; (90000cb4 <BSP_LCD_MspInit+0x13c>)
  gpio_init_structure.Alternate = GPIO_AF9_LTDC;
90000c46:	930d      	str	r3, [sp, #52]	; 0x34
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90000c48:	e9cd 7409 	strd	r7, r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
90000c4c:	f000 fe26 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin       = GPIO_PIN_9 | GPIO_PIN_10 | \
90000c50:	f44f 4366 	mov.w	r3, #58880	; 0xe600
  HAL_GPIO_Init(GPIOI, &gpio_init_structure);
90000c54:	a909      	add	r1, sp, #36	; 0x24
90000c56:	4630      	mov	r0, r6
  gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90000c58:	950d      	str	r5, [sp, #52]	; 0x34
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90000c5a:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOI, &gpio_init_structure);
90000c5e:	f000 fe1d 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | \
90000c62:	f64e 73ff 	movw	r3, #61439	; 0xefff
  HAL_GPIO_Init(GPIOJ, &gpio_init_structure);  
90000c66:	a909      	add	r1, sp, #36	; 0x24
90000c68:	4813      	ldr	r0, [pc, #76]	; (90000cb8 <BSP_LCD_MspInit+0x140>)
  gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90000c6a:	950d      	str	r5, [sp, #52]	; 0x34
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90000c6c:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOJ, &gpio_init_structure);  
90000c70:	f000 fe14 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_4 | \
90000c74:	23f7      	movs	r3, #247	; 0xf7
  HAL_GPIO_Init(GPIOK, &gpio_init_structure);
90000c76:	a909      	add	r1, sp, #36	; 0x24
  gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90000c78:	950d      	str	r5, [sp, #52]	; 0x34
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
90000c7a:	2501      	movs	r5, #1
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90000c7c:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOK, &gpio_init_structure);
90000c80:	4c0e      	ldr	r4, [pc, #56]	; (90000cbc <BSP_LCD_MspInit+0x144>)
90000c82:	4620      	mov	r0, r4
90000c84:	f000 fe0a 	bl	9000189c <HAL_GPIO_Init>
  HAL_GPIO_Init(LCD_DISP_GPIO_PORT, &gpio_init_structure);
90000c88:	a909      	add	r1, sp, #36	; 0x24
90000c8a:	4630      	mov	r0, r6
  gpio_init_structure.Pin       = LCD_DISP_PIN;     /* LCD_DISP pin has to be manually controlled */
90000c8c:	9709      	str	r7, [sp, #36]	; 0x24
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
90000c8e:	950a      	str	r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(LCD_DISP_GPIO_PORT, &gpio_init_structure);
90000c90:	f000 fe04 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin       = LCD_BL_CTRL_PIN;  /* LCD_BL_CTRL pin has to be manually controlled */
90000c94:	2308      	movs	r3, #8
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_PORT, &gpio_init_structure);
90000c96:	a909      	add	r1, sp, #36	; 0x24
90000c98:	4620      	mov	r0, r4
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
90000c9a:	e9cd 3509 	strd	r3, r5, [sp, #36]	; 0x24
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_PORT, &gpio_init_structure);
90000c9e:	f000 fdfd 	bl	9000189c <HAL_GPIO_Init>
}
90000ca2:	b00f      	add	sp, #60	; 0x3c
90000ca4:	bdf0      	pop	{r4, r5, r6, r7, pc}
90000ca6:	bf00      	nop
90000ca8:	40023800 	.word	0x40023800
90000cac:	40021000 	.word	0x40021000
90000cb0:	40022000 	.word	0x40022000
90000cb4:	40021800 	.word	0x40021800
90000cb8:	40022400 	.word	0x40022400
90000cbc:	40022800 	.word	0x40022800

90000cc0 <BSP_LCD_ClockConfig>:
  periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
90000cc0:	4806      	ldr	r0, [pc, #24]	; (90000cdc <BSP_LCD_ClockConfig+0x1c>)
90000cc2:	2308      	movs	r3, #8
90000cc4:	65c3      	str	r3, [r0, #92]	; 0x5c
  periph_clk_init_struct.PLLSAI.PLLSAIN = 192;
90000cc6:	23c0      	movs	r3, #192	; 0xc0
  HAL_RCCEx_PeriphCLKConfig(&periph_clk_init_struct);
90000cc8:	305c      	adds	r0, #92	; 0x5c
  periph_clk_init_struct.PLLSAI.PLLSAIN = 192;
90000cca:	6143      	str	r3, [r0, #20]
  periph_clk_init_struct.PLLSAI.PLLSAIR = RK043FN48H_FREQUENCY_DIVIDER;
90000ccc:	2305      	movs	r3, #5
90000cce:	61c3      	str	r3, [r0, #28]
  periph_clk_init_struct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
90000cd0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
90000cd4:	62c3      	str	r3, [r0, #44]	; 0x2c
  HAL_RCCEx_PeriphCLKConfig(&periph_clk_init_struct);
90000cd6:	f001 bb0f 	b.w	900022f8 <HAL_RCCEx_PeriphCLKConfig>
90000cda:	bf00      	nop
90000cdc:	200000bc 	.word	0x200000bc

90000ce0 <BSP_LCD_Init>:
{    
90000ce0:	b510      	push	{r4, lr}
  hLtdcHandler.Init.VerticalSync = (RK043FN48H_VSYNC - 1);
90000ce2:	2228      	movs	r2, #40	; 0x28
  hLtdcHandler.Init.HorizontalSync = (RK043FN48H_HSYNC - 1);
90000ce4:	4c24      	ldr	r4, [pc, #144]	; (90000d78 <BSP_LCD_Init+0x98>)
  hLtdcHandler.Init.VerticalSync = (RK043FN48H_VSYNC - 1);
90000ce6:	2309      	movs	r3, #9
  hLtdcHandler.Init.AccumulatedVBP = (RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
90000ce8:	2135      	movs	r1, #53	; 0x35
  hLtdcHandler.Init.AccumulatedActiveW = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
90000cea:	f240 101b 	movw	r0, #283	; 0x11b
  hLtdcHandler.Init.TotalWidth = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP + RK043FN48H_HFP - 1);
90000cee:	f240 1c1d 	movw	ip, #285	; 0x11d
  hLtdcHandler.Init.VerticalSync = (RK043FN48H_VSYNC - 1);
90000cf2:	e9c4 2305 	strd	r2, r3, [r4, #20]
  hLtdcHandler.Init.AccumulatedVBP = (RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
90000cf6:	230b      	movs	r3, #11
90000cf8:	e9c4 1307 	strd	r1, r3, [r4, #28]
  hLtdcHandler.Init.AccumulatedActiveW = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
90000cfc:	f240 2315 	movw	r3, #533	; 0x215
  BSP_LCD_ClockConfig(&hLtdcHandler, NULL);
90000d00:	2100      	movs	r1, #0
  hLtdcHandler.Init.AccumulatedActiveW = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
90000d02:	e9c4 3009 	strd	r3, r0, [r4, #36]	; 0x24
  hLtdcHandler.Init.TotalWidth = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP + RK043FN48H_HFP - 1);
90000d06:	f240 2335 	movw	r3, #565	; 0x235
  BSP_LCD_ClockConfig(&hLtdcHandler, NULL);
90000d0a:	4620      	mov	r0, r4
  hLtdcHandler.Init.TotalWidth = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP + RK043FN48H_HFP - 1);
90000d0c:	e9c4 3c0b 	strd	r3, ip, [r4, #44]	; 0x2c
  BSP_LCD_ClockConfig(&hLtdcHandler, NULL);
90000d10:	f7ff ffd6 	bl	90000cc0 <BSP_LCD_ClockConfig>
  hLtdcHandler.LayerCfg->ImageHeight = RK043FN48H_HEIGHT;
90000d14:	f44f 7ef0 	mov.w	lr, #480	; 0x1e0
90000d18:	f44f 7388 	mov.w	r3, #272	; 0x110
  if(HAL_LTDC_GetState(&hLtdcHandler) == HAL_LTDC_STATE_RESET)
90000d1c:	4620      	mov	r0, r4
  hLtdcHandler.LayerCfg->ImageHeight = RK043FN48H_HEIGHT;
90000d1e:	e9c4 e318 	strd	lr, r3, [r4, #96]	; 0x60
  hLtdcHandler.Init.Backcolor.Blue = 0;
90000d22:	2300      	movs	r3, #0
90000d24:	86a3      	strh	r3, [r4, #52]	; 0x34
  hLtdcHandler.Init.Backcolor.Red = 0;
90000d26:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
  hLtdcHandler.Init.VSPolarity = LTDC_VSPOLARITY_AL; 
90000d2a:	e9c4 3301 	strd	r3, r3, [r4, #4]
  hLtdcHandler.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
90000d2e:	e9c4 3303 	strd	r3, r3, [r4, #12]
  hLtdcHandler.Instance = LTDC;
90000d32:	4b12      	ldr	r3, [pc, #72]	; (90000d7c <BSP_LCD_Init+0x9c>)
90000d34:	6023      	str	r3, [r4, #0]
  if(HAL_LTDC_GetState(&hLtdcHandler) == HAL_LTDC_STATE_RESET)
90000d36:	f001 f818 	bl	90001d6a <HAL_LTDC_GetState>
90000d3a:	4601      	mov	r1, r0
90000d3c:	b910      	cbnz	r0, 90000d44 <BSP_LCD_Init+0x64>
    BSP_LCD_MspInit(&hLtdcHandler, NULL);
90000d3e:	4620      	mov	r0, r4
90000d40:	f7ff ff1a 	bl	90000b78 <BSP_LCD_MspInit>
  HAL_LTDC_Init(&hLtdcHandler);
90000d44:	480c      	ldr	r0, [pc, #48]	; (90000d78 <BSP_LCD_Init+0x98>)
90000d46:	f000 ff21 	bl	90001b8c <HAL_LTDC_Init>
  HAL_GPIO_WritePin(LCD_DISP_GPIO_PORT, LCD_DISP_PIN, GPIO_PIN_SET);
90000d4a:	2201      	movs	r2, #1
90000d4c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
90000d50:	480b      	ldr	r0, [pc, #44]	; (90000d80 <BSP_LCD_Init+0xa0>)
90000d52:	f000 fe8f 	bl	90001a74 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_PORT, LCD_BL_CTRL_PIN, GPIO_PIN_SET);
90000d56:	2201      	movs	r2, #1
90000d58:	2108      	movs	r1, #8
90000d5a:	480a      	ldr	r0, [pc, #40]	; (90000d84 <BSP_LCD_Init+0xa4>)
90000d5c:	f000 fe8a 	bl	90001a74 <HAL_GPIO_WritePin>
  BSP_SDRAM_Init();
90000d60:	f000 fa64 	bl	9000122c <BSP_SDRAM_Init>
  DrawProp[ActiveLayer].pFont = fonts;
90000d64:	4a08      	ldr	r2, [pc, #32]	; (90000d88 <BSP_LCD_Init+0xa8>)
90000d66:	210c      	movs	r1, #12
}
90000d68:	2000      	movs	r0, #0
  DrawProp[ActiveLayer].pFont = fonts;
90000d6a:	6c13      	ldr	r3, [r2, #64]	; 0x40
90000d6c:	fb01 2303 	mla	r3, r1, r3, r2
90000d70:	4a06      	ldr	r2, [pc, #24]	; (90000d8c <BSP_LCD_Init+0xac>)
90000d72:	64da      	str	r2, [r3, #76]	; 0x4c
}
90000d74:	bd10      	pop	{r4, pc}
90000d76:	bf00      	nop
90000d78:	20000450 	.word	0x20000450
90000d7c:	40016800 	.word	0x40016800
90000d80:	40022000 	.word	0x40022000
90000d84:	40022800 	.word	0x40022800
90000d88:	200000bc 	.word	0x200000bc
90000d8c:	20000000 	.word	0x20000000

90000d90 <BSP_SD_IsDetected>:
  * @brief  Detects if SD card is correctly plugged in the memory slot or not.
  * @retval Returns if SD is detected or not
  */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t      status = SD_PRESENT;
90000d90:	2301      	movs	r3, #1
{
90000d92:	b507      	push	{r0, r1, r2, lr}
  
  /* Check SD card detect pin */
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
90000d94:	f44f 5100 	mov.w	r1, #8192	; 0x2000
90000d98:	4807      	ldr	r0, [pc, #28]	; (90000db8 <BSP_SD_IsDetected+0x28>)
  __IO uint8_t      status = SD_PRESENT;
90000d9a:	f88d 3007 	strb.w	r3, [sp, #7]
  if (HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) == GPIO_PIN_SET)
90000d9e:	f000 fe63 	bl	90001a68 <HAL_GPIO_ReadPin>
90000da2:	2801      	cmp	r0, #1
90000da4:	d102      	bne.n	90000dac <BSP_SD_IsDetected+0x1c>
  {
    status = SD_NOT_PRESENT;
90000da6:	2300      	movs	r3, #0
90000da8:	f88d 3007 	strb.w	r3, [sp, #7]
  }

  return status;
90000dac:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
90000db0:	b003      	add	sp, #12
90000db2:	f85d fb04 	ldr.w	pc, [sp], #4
90000db6:	bf00      	nop
90000db8:	40020800 	.word	0x40020800

90000dbc <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
90000dbc:	b507      	push	{r0, r1, r2, lr}
  if(HAL_SD_ReadBlocks(&uSdHandle, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
90000dbe:	9300      	str	r3, [sp, #0]
90000dc0:	4613      	mov	r3, r2
90000dc2:	460a      	mov	r2, r1
90000dc4:	4601      	mov	r1, r0
90000dc6:	4804      	ldr	r0, [pc, #16]	; (90000dd8 <BSP_SD_ReadBlocks+0x1c>)
90000dc8:	f001 fd86 	bl	900028d8 <HAL_SD_ReadBlocks>
  }
  else
  {
    return MSD_OK;
  }
}
90000dcc:	3800      	subs	r0, #0
90000dce:	bf18      	it	ne
90000dd0:	2001      	movne	r0, #1
90000dd2:	b003      	add	sp, #12
90000dd4:	f85d fb04 	ldr.w	pc, [sp], #4
90000dd8:	200004f8 	.word	0x200004f8

90000ddc <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
90000ddc:	b507      	push	{r0, r1, r2, lr}
  if(HAL_SD_WriteBlocks(&uSdHandle, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK)
90000dde:	9300      	str	r3, [sp, #0]
90000de0:	4613      	mov	r3, r2
90000de2:	460a      	mov	r2, r1
90000de4:	4601      	mov	r1, r0
90000de6:	4804      	ldr	r0, [pc, #16]	; (90000df8 <BSP_SD_WriteBlocks+0x1c>)
90000de8:	f001 fe72 	bl	90002ad0 <HAL_SD_WriteBlocks>
  }
  else
  {
    return MSD_OK;
  }
}
90000dec:	3800      	subs	r0, #0
90000dee:	bf18      	it	ne
90000df0:	2001      	movne	r0, #1
90000df2:	b003      	add	sp, #12
90000df4:	f85d fb04 	ldr.w	pc, [sp], #4
90000df8:	200004f8 	.word	0x200004f8

90000dfc <BSP_SD_MspInit>:
  static DMA_HandleTypeDef dma_rx_handle;
  static DMA_HandleTypeDef dma_tx_handle;
  GPIO_InitTypeDef gpio_init_structure;

  /* Enable SDIO clock */
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90000dfc:	4b53      	ldr	r3, [pc, #332]	; (90000f4c <BSP_SD_MspInit+0x150>)
90000dfe:	6c5a      	ldr	r2, [r3, #68]	; 0x44
90000e00:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
{
90000e04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90000e08:	645a      	str	r2, [r3, #68]	; 0x44
{
90000e0a:	b08b      	sub	sp, #44	; 0x2c
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90000e0c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
  gpio_init_structure.Alternate = GPIO_AF12_SDMMC1;
90000e0e:	2703      	movs	r7, #3
{
90000e10:	4605      	mov	r5, r0
  /* GPIOC configuration */
  gpio_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);

  /* GPIOD configuration */
  gpio_init_structure.Pin = GPIO_PIN_2;
90000e12:	f04f 0804 	mov.w	r8, #4
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90000e16:	f402 6200 	and.w	r2, r2, #2048	; 0x800
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
90000e1a:	a905      	add	r1, sp, #20
90000e1c:	484c      	ldr	r0, [pc, #304]	; (90000f50 <BSP_SD_MspInit+0x154>)
  HAL_NVIC_SetPriority(SDMMC1_IRQn, 0x0E, 0);
  HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
    
  /* Configure DMA Rx parameters */
  dma_rx_handle.Init.Channel             = SD_DMAx_Rx_CHANNEL;
  dma_rx_handle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
90000e1e:	2600      	movs	r6, #0
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90000e20:	9201      	str	r2, [sp, #4]
  dma_rx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
  dma_rx_handle.Init.MemInc              = DMA_MINC_ENABLE;
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  dma_rx_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
  dma_rx_handle.Init.Mode                = DMA_PFCTRL;
90000e22:	f44f 4b80 	mov.w	fp, #16384	; 0x4000
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90000e26:	9a01      	ldr	r2, [sp, #4]
  dma_rx_handle.Init.Mode                = DMA_PFCTRL;
90000e28:	f04f 0a20 	mov.w	sl, #32
  __DMAx_TxRx_CLK_ENABLE();
90000e2c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  dma_rx_handle.Init.Priority            = DMA_PRIORITY_VERY_HIGH;
90000e2e:	f44f 3940 	mov.w	r9, #196608	; 0x30000
  dma_rx_handle.Init.Channel             = SD_DMAx_Rx_CHANNEL;
90000e32:	4c48      	ldr	r4, [pc, #288]	; (90000f54 <BSP_SD_MspInit+0x158>)
  __DMAx_TxRx_CLK_ENABLE();
90000e34:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
90000e38:	631a      	str	r2, [r3, #48]	; 0x30
90000e3a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000e3c:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
90000e40:	9202      	str	r2, [sp, #8]
90000e42:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
90000e44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000e46:	f042 0204 	orr.w	r2, r2, #4
90000e4a:	631a      	str	r2, [r3, #48]	; 0x30
90000e4c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000e4e:	f002 0204 	and.w	r2, r2, #4
90000e52:	9203      	str	r2, [sp, #12]
90000e54:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
90000e56:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000e58:	f042 0208 	orr.w	r2, r2, #8
90000e5c:	631a      	str	r2, [r3, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
90000e5e:	2202      	movs	r2, #2
  __HAL_RCC_GPIOD_CLK_ENABLE();
90000e60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000e62:	f003 0308 	and.w	r3, r3, #8
90000e66:	9304      	str	r3, [sp, #16]
90000e68:	9b04      	ldr	r3, [sp, #16]
  gpio_init_structure.Pull      = GPIO_PULLUP;
90000e6a:	2301      	movs	r3, #1
90000e6c:	e9cd 2306 	strd	r2, r3, [sp, #24]
  gpio_init_structure.Alternate = GPIO_AF12_SDMMC1;
90000e70:	230c      	movs	r3, #12
90000e72:	e9cd 7308 	strd	r7, r3, [sp, #32]
  gpio_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
90000e76:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
90000e7a:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
90000e7c:	f000 fd0e 	bl	9000189c <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90000e80:	a905      	add	r1, sp, #20
90000e82:	4835      	ldr	r0, [pc, #212]	; (90000f58 <BSP_SD_MspInit+0x15c>)
  gpio_init_structure.Pin = GPIO_PIN_2;
90000e84:	f8cd 8014 	str.w	r8, [sp, #20]
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90000e88:	f000 fd08 	bl	9000189c <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(SDMMC1_IRQn, 0x0E, 0);
90000e8c:	2200      	movs	r2, #0
90000e8e:	210e      	movs	r1, #14
90000e90:	2031      	movs	r0, #49	; 0x31
90000e92:	f000 fa9b 	bl	900013cc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
90000e96:	2031      	movs	r0, #49	; 0x31
90000e98:	f000 faca 	bl	90001430 <HAL_NVIC_EnableIRQ>
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90000e9c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  dma_rx_handle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
90000ea0:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90000ea4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  dma_rx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
  dma_rx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dma_rx_handle.Init.MemBurst            = DMA_MBURST_INC4;
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
  
  dma_rx_handle.Instance = SD_DMAx_Rx_STREAM;
90000ea8:	482c      	ldr	r0, [pc, #176]	; (90000f5c <BSP_SD_MspInit+0x160>)
  
  /* Associate the DMA handle */
  __HAL_LINKDMA(hsd, hdmarx, dma_rx_handle);
90000eaa:	642c      	str	r4, [r5, #64]	; 0x40
  dma_rx_handle.Instance = SD_DMAx_Rx_STREAM;
90000eac:	6020      	str	r0, [r4, #0]
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_rx_handle);
90000eae:	4620      	mov	r0, r4
  dma_rx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
90000eb0:	62a7      	str	r7, [r4, #40]	; 0x28
  dma_rx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
90000eb2:	60e6      	str	r6, [r4, #12]
  __HAL_LINKDMA(hsd, hdmarx, dma_rx_handle);
90000eb4:	63a5      	str	r5, [r4, #56]	; 0x38
  dma_rx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90000eb6:	e9c4 2304 	strd	r2, r3, [r4, #16]
  dma_rx_handle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
90000eba:	e9c4 1601 	strd	r1, r6, [r4, #4]
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
90000ebe:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
90000ec2:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
  dma_rx_handle.Init.Mode                = DMA_PFCTRL;
90000ec6:	e9c4 ba06 	strd	fp, sl, [r4, #24]
  dma_rx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
90000eca:	e9c4 130b 	strd	r1, r3, [r4, #44]	; 0x2c
  dma_rx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
90000ece:	e9c4 9808 	strd	r9, r8, [r4, #32]
  HAL_DMA_DeInit(&dma_rx_handle);
90000ed2:	f000 fb67 	bl	900015a4 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_rx_handle);
90000ed6:	4620      	mov	r0, r4
90000ed8:	f000 fae4 	bl	900014a4 <HAL_DMA_Init>
  /* Configure DMA Tx parameters */
  dma_tx_handle.Init.Channel             = SD_DMAx_Tx_CHANNEL;
  dma_tx_handle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  dma_tx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
  dma_tx_handle.Init.MemInc              = DMA_MINC_ENABLE;
  dma_tx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90000edc:	f44f 6280 	mov.w	r2, #1024	; 0x400
90000ee0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  dma_tx_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
  dma_tx_handle.Init.Mode                = DMA_PFCTRL;
  dma_tx_handle.Init.Priority            = DMA_PRIORITY_VERY_HIGH;
  dma_tx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
  dma_tx_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
90000ee4:	f8c4 7088 	str.w	r7, [r4, #136]	; 0x88
  dma_tx_handle.Init.MemBurst            = DMA_MBURST_INC4;
  dma_tx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
90000ee8:	f44f 0700 	mov.w	r7, #8388608	; 0x800000
  dma_tx_handle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
90000eec:	2140      	movs	r1, #64	; 0x40
90000eee:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
  dma_tx_handle.Init.PeriphInc           = DMA_PINC_DISABLE;
90000ef2:	66e6      	str	r6, [r4, #108]	; 0x6c
  
  dma_tx_handle.Instance = SD_DMAx_Tx_STREAM;
  
  /* Associate the DMA handle */
  __HAL_LINKDMA(hsd, hdmatx, dma_tx_handle);
90000ef4:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
  dma_tx_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90000ef8:	e9c4 231c 	strd	r2, r3, [r4, #112]	; 0x70
  dma_tx_handle.Init.PeriphBurst         = DMA_PBURST_INC4;
90000efc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
90000f00:	e9c4 7323 	strd	r7, r3, [r4, #140]	; 0x8c
  dma_tx_handle.Instance = SD_DMAx_Tx_STREAM;
90000f04:	4b16      	ldr	r3, [pc, #88]	; (90000f60 <BSP_SD_MspInit+0x164>)
90000f06:	4627      	mov	r7, r4
  dma_tx_handle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
90000f08:	e9c4 0119 	strd	r0, r1, [r4, #100]	; 0x64
  dma_tx_handle.Instance = SD_DMAx_Tx_STREAM;
90000f0c:	f847 3f60 	str.w	r3, [r7, #96]!
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_tx_handle);
90000f10:	4638      	mov	r0, r7
  __HAL_LINKDMA(hsd, hdmatx, dma_tx_handle);
90000f12:	63ef      	str	r7, [r5, #60]	; 0x3c
  dma_tx_handle.Init.Mode                = DMA_PFCTRL;
90000f14:	e9c4 ba1e 	strd	fp, sl, [r4, #120]	; 0x78
  dma_tx_handle.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;
90000f18:	e9c4 9820 	strd	r9, r8, [r4, #128]	; 0x80
  HAL_DMA_DeInit(&dma_tx_handle);
90000f1c:	f000 fb42 	bl	900015a4 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_tx_handle); 
90000f20:	4638      	mov	r0, r7
90000f22:	f000 fabf 	bl	900014a4 <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SD_DMAx_Rx_IRQn, 0x0F, 0);
90000f26:	4632      	mov	r2, r6
90000f28:	210f      	movs	r1, #15
90000f2a:	203b      	movs	r0, #59	; 0x3b
90000f2c:	f000 fa4e 	bl	900013cc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SD_DMAx_Rx_IRQn);
90000f30:	203b      	movs	r0, #59	; 0x3b
90000f32:	f000 fa7d 	bl	90001430 <HAL_NVIC_EnableIRQ>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SD_DMAx_Tx_IRQn, 0x0F, 0);
90000f36:	4632      	mov	r2, r6
90000f38:	210f      	movs	r1, #15
90000f3a:	2045      	movs	r0, #69	; 0x45
90000f3c:	f000 fa46 	bl	900013cc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SD_DMAx_Tx_IRQn);
90000f40:	2045      	movs	r0, #69	; 0x45
90000f42:	f000 fa75 	bl	90001430 <HAL_NVIC_EnableIRQ>
}
90000f46:	b00b      	add	sp, #44	; 0x2c
90000f48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
90000f4c:	40023800 	.word	0x40023800
90000f50:	40020800 	.word	0x40020800
90000f54:	2000019c 	.word	0x2000019c
90000f58:	40020c00 	.word	0x40020c00
90000f5c:	40026458 	.word	0x40026458
90000f60:	400264a0 	.word	0x400264a0

90000f64 <BSP_SD_Detect_MspInit>:
  * @param  hsd: SD handle
  * @param  Params
  * @retval None
  */
__weak void BSP_SD_Detect_MspInit(SD_HandleTypeDef *hsd, void *Params)
{
90000f64:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  GPIO_InitTypeDef  gpio_init_structure;

  SD_DETECT_GPIO_CLK_ENABLE();
90000f66:	4b0d      	ldr	r3, [pc, #52]	; (90000f9c <BSP_SD_Detect_MspInit+0x38>)

  /* GPIO configuration in input for uSD_Detect signal */
  gpio_init_structure.Pin       = SD_DETECT_PIN;
  gpio_init_structure.Mode      = GPIO_MODE_INPUT;
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
90000f68:	2101      	movs	r1, #1
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
90000f6a:	480d      	ldr	r0, [pc, #52]	; (90000fa0 <BSP_SD_Detect_MspInit+0x3c>)
  SD_DETECT_GPIO_CLK_ENABLE();
90000f6c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90000f6e:	f042 0204 	orr.w	r2, r2, #4
90000f72:	631a      	str	r2, [r3, #48]	; 0x30
  gpio_init_structure.Mode      = GPIO_MODE_INPUT;
90000f74:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  SD_DETECT_GPIO_CLK_ENABLE();
90000f78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000f7a:	f003 0304 	and.w	r3, r3, #4
90000f7e:	9300      	str	r3, [sp, #0]
90000f80:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Mode      = GPIO_MODE_INPUT;
90000f82:	2300      	movs	r3, #0
90000f84:	e9cd 2301 	strd	r2, r3, [sp, #4]
  gpio_init_structure.Speed     = GPIO_SPEED_HIGH;
90000f88:	2303      	movs	r3, #3
90000f8a:	e9cd 1303 	strd	r1, r3, [sp, #12]
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
90000f8e:	a901      	add	r1, sp, #4
90000f90:	f000 fc84 	bl	9000189c <HAL_GPIO_Init>
}
90000f94:	b007      	add	sp, #28
90000f96:	f85d fb04 	ldr.w	pc, [sp], #4
90000f9a:	bf00      	nop
90000f9c:	40023800 	.word	0x40023800
90000fa0:	40020800 	.word	0x40020800

90000fa4 <BSP_SD_Init>:
{ 
90000fa4:	b570      	push	{r4, r5, r6, lr}
  uSdHandle.Instance = SDMMC1;
90000fa6:	4c13      	ldr	r4, [pc, #76]	; (90000ff4 <BSP_SD_Init+0x50>)
  uSdHandle.Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
90000fa8:	2600      	movs	r6, #0
90000faa:	4b13      	ldr	r3, [pc, #76]	; (90000ff8 <BSP_SD_Init+0x54>)
  BSP_SD_Detect_MspInit(&uSdHandle, NULL);
90000fac:	4631      	mov	r1, r6
90000fae:	4620      	mov	r0, r4
  uSdHandle.Init.ClockDiv            = SDMMC_TRANSFER_CLK_DIV;
90000fb0:	61a6      	str	r6, [r4, #24]
  uSdHandle.Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
90000fb2:	e9c4 3600 	strd	r3, r6, [r4]
  uSdHandle.Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
90000fb6:	e9c4 6602 	strd	r6, r6, [r4, #8]
  uSdHandle.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
90000fba:	e9c4 6604 	strd	r6, r6, [r4, #16]
  BSP_SD_Detect_MspInit(&uSdHandle, NULL);
90000fbe:	f7ff ffd1 	bl	90000f64 <BSP_SD_Detect_MspInit>
  if(BSP_SD_IsDetected() != SD_PRESENT)   /* Check if SD card is present */
90000fc2:	f7ff fee5 	bl	90000d90 <BSP_SD_IsDetected>
90000fc6:	2801      	cmp	r0, #1
90000fc8:	4605      	mov	r5, r0
90000fca:	d111      	bne.n	90000ff0 <BSP_SD_Init+0x4c>
  BSP_SD_MspInit(&uSdHandle, NULL);
90000fcc:	4620      	mov	r0, r4
90000fce:	4631      	mov	r1, r6
90000fd0:	f7ff ff14 	bl	90000dfc <BSP_SD_MspInit>
  if(HAL_SD_Init(&uSdHandle) != HAL_OK)
90000fd4:	4620      	mov	r0, r4
90000fd6:	f001 ffff 	bl	90002fd8 <HAL_SD_Init>
90000fda:	b938      	cbnz	r0, 90000fec <BSP_SD_Init+0x48>
    if(HAL_SD_ConfigWideBusOperation(&uSdHandle, SDMMC_BUS_WIDE_4B) != HAL_OK)
90000fdc:	f44f 6100 	mov.w	r1, #2048	; 0x800
90000fe0:	4620      	mov	r0, r4
90000fe2:	f002 f827 	bl	90003034 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
90000fe6:	1b85      	subs	r5, r0, r6
90000fe8:	bf18      	it	ne
90000fea:	2501      	movne	r5, #1
}
90000fec:	4628      	mov	r0, r5
90000fee:	bd70      	pop	{r4, r5, r6, pc}
    return MSD_ERROR_SD_NOT_PRESENT;
90000ff0:	2502      	movs	r5, #2
90000ff2:	e7fb      	b.n	90000fec <BSP_SD_Init+0x48>
90000ff4:	200004f8 	.word	0x200004f8
90000ff8:	40012c00 	.word	0x40012c00

90000ffc <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
uint8_t BSP_SD_GetCardState(void)
{
90000ffc:	b508      	push	{r3, lr}
  return((HAL_SD_GetCardState(&uSdHandle) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
90000ffe:	4803      	ldr	r0, [pc, #12]	; (9000100c <BSP_SD_GetCardState+0x10>)
90001000:	f002 f8aa 	bl	90003158 <HAL_SD_GetCardState>
}
90001004:	3804      	subs	r0, #4
90001006:	bf18      	it	ne
90001008:	2001      	movne	r0, #1
9000100a:	bd08      	pop	{r3, pc}
9000100c:	200004f8 	.word	0x200004f8

90001010 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None 
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
90001010:	4601      	mov	r1, r0
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&uSdHandle, CardInfo);
90001012:	4801      	ldr	r0, [pc, #4]	; (90001018 <BSP_SD_GetCardInfo+0x8>)
90001014:	f001 bffb 	b.w	9000300e <HAL_SD_GetCardInfo>
90001018:	200004f8 	.word	0x200004f8

9000101c <BSP_SDRAM_Initialization_sequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
9000101c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  __IO uint32_t tmpmrd = 0;
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
90001020:	4c21      	ldr	r4, [pc, #132]	; (900010a8 <BSP_SDRAM_Initialization_sequence+0x8c>)
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
90001022:	2601      	movs	r6, #1
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001024:	4d21      	ldr	r5, [pc, #132]	; (900010ac <BSP_SDRAM_Initialization_sequence+0x90>)
  __IO uint32_t tmpmrd = 0;
90001026:	f04f 0800 	mov.w	r8, #0
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
9000102a:	2710      	movs	r7, #16
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
9000102c:	4621      	mov	r1, r4
{
9000102e:	4681      	mov	r9, r0
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001030:	f64f 72ff 	movw	r2, #65535	; 0xffff
90001034:	4628      	mov	r0, r5
  __IO uint32_t tmpmrd = 0;
90001036:	f8cd 8004 	str.w	r8, [sp, #4]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
9000103a:	e9c4 6700 	strd	r6, r7, [r4]
  Command.ModeRegisterDefinition = 0;
9000103e:	e9c4 6802 	strd	r6, r8, [r4, #8]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001042:	f002 f8be 	bl	900031c2 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
90001046:	4630      	mov	r0, r6
90001048:	f000 f99c 	bl	90001384 <HAL_Delay>
    
  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
9000104c:	2302      	movs	r3, #2
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
9000104e:	4621      	mov	r1, r4
90001050:	f64f 72ff 	movw	r2, #65535	; 0xffff
90001054:	4628      	mov	r0, r5
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
90001056:	e9c4 3700 	strd	r3, r7, [r4]
  Command.ModeRegisterDefinition = 0;
9000105a:	e9c4 6802 	strd	r6, r8, [r4, #8]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
9000105e:	f002 f8b0 	bl	900031c2 <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
90001062:	2303      	movs	r3, #3
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 8;
  Command.ModeRegisterDefinition = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001064:	4621      	mov	r1, r4
90001066:	f64f 72ff 	movw	r2, #65535	; 0xffff
9000106a:	4628      	mov	r0, r5
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
9000106c:	e9c4 3700 	strd	r3, r7, [r4]
  Command.AutoRefreshNumber      = 8;
90001070:	2308      	movs	r3, #8
  Command.ModeRegisterDefinition = 0;
90001072:	e9c4 3802 	strd	r3, r8, [r4, #8]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001076:	f002 f8a4 	bl	900031c2 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
9000107a:	f44f 7308 	mov.w	r3, #544	; 0x220
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
  Command.AutoRefreshNumber      = 1;
  Command.ModeRegisterDefinition = tmpmrd;

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
9000107e:	4621      	mov	r1, r4
90001080:	f64f 72ff 	movw	r2, #65535	; 0xffff
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
90001084:	9301      	str	r3, [sp, #4]
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
90001086:	2304      	movs	r3, #4
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001088:	4628      	mov	r0, r5
  Command.AutoRefreshNumber      = 1;
9000108a:	60a6      	str	r6, [r4, #8]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
9000108c:	e9c4 3700 	strd	r3, r7, [r4]
  Command.ModeRegisterDefinition = tmpmrd;
90001090:	9b01      	ldr	r3, [sp, #4]
90001092:	60e3      	str	r3, [r4, #12]
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90001094:	f002 f895 	bl	900031c2 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
90001098:	4649      	mov	r1, r9
9000109a:	4628      	mov	r0, r5
}
9000109c:	b003      	add	sp, #12
9000109e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
900010a2:	f002 b8a5 	b.w	900031f0 <HAL_SDRAM_ProgramRefreshRate>
900010a6:	bf00      	nop
900010a8:	2000031c 	.word	0x2000031c
900010ac:	2000057c 	.word	0x2000057c

900010b0 <BSP_SDRAM_MspInit>:
{  
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
900010b0:	4b55      	ldr	r3, [pc, #340]	; (90001208 <BSP_SDRAM_MspInit+0x158>)
900010b2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
900010b4:	f042 0201 	orr.w	r2, r2, #1
{  
900010b8:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_FMC_CLK_ENABLE();
900010ba:	639a      	str	r2, [r3, #56]	; 0x38
{  
900010bc:	b08e      	sub	sp, #56	; 0x38
  __HAL_RCC_FMC_CLK_ENABLE();
900010be:	6b9a      	ldr	r2, [r3, #56]	; 0x38
{  
900010c0:	4606      	mov	r6, r0
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
900010c2:	a909      	add	r1, sp, #36	; 0x24
900010c4:	4851      	ldr	r0, [pc, #324]	; (9000120c <BSP_SDRAM_MspInit+0x15c>)
  __HAL_RCC_FMC_CLK_ENABLE();
900010c6:	f002 0201 	and.w	r2, r2, #1
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
900010ca:	2400      	movs	r4, #0
  __HAL_RCC_FMC_CLK_ENABLE();
900010cc:	9201      	str	r2, [sp, #4]
900010ce:	9a01      	ldr	r2, [sp, #4]
  __DMAx_CLK_ENABLE();
900010d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
900010d2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
900010d6:	631a      	str	r2, [r3, #48]	; 0x30
900010d8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
900010da:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
900010de:	9202      	str	r2, [sp, #8]
900010e0:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
900010e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
900010e4:	f042 0204 	orr.w	r2, r2, #4
900010e8:	631a      	str	r2, [r3, #48]	; 0x30
900010ea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
900010ec:	f002 0204 	and.w	r2, r2, #4
900010f0:	9203      	str	r2, [sp, #12]
900010f2:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
900010f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
900010f6:	f042 0208 	orr.w	r2, r2, #8
900010fa:	631a      	str	r2, [r3, #48]	; 0x30
900010fc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
900010fe:	f002 0208 	and.w	r2, r2, #8
90001102:	9204      	str	r2, [sp, #16]
90001104:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOE_CLK_ENABLE();
90001106:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90001108:	f042 0210 	orr.w	r2, r2, #16
9000110c:	631a      	str	r2, [r3, #48]	; 0x30
9000110e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90001110:	f002 0210 	and.w	r2, r2, #16
90001114:	9205      	str	r2, [sp, #20]
90001116:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
90001118:	6b1a      	ldr	r2, [r3, #48]	; 0x30
9000111a:	f042 0220 	orr.w	r2, r2, #32
9000111e:	631a      	str	r2, [r3, #48]	; 0x30
90001120:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90001122:	f002 0220 	and.w	r2, r2, #32
90001126:	9206      	str	r2, [sp, #24]
90001128:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
9000112a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
9000112c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
90001130:	631a      	str	r2, [r3, #48]	; 0x30
90001132:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90001134:	f002 0240 	and.w	r2, r2, #64	; 0x40
90001138:	9207      	str	r2, [sp, #28]
9000113a:	9a07      	ldr	r2, [sp, #28]
  __HAL_RCC_GPIOH_CLK_ENABLE();
9000113c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
9000113e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
90001142:	631a      	str	r2, [r3, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
90001144:	2201      	movs	r2, #1
  __HAL_RCC_GPIOH_CLK_ENABLE();
90001146:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90001148:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000114c:	9308      	str	r3, [sp, #32]
9000114e:	9b08      	ldr	r3, [sp, #32]
  gpio_init_structure.Pull      = GPIO_PULLUP;
90001150:	2302      	movs	r3, #2
90001152:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
90001156:	930c      	str	r3, [sp, #48]	; 0x30
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
90001158:	230c      	movs	r3, #12
9000115a:	930d      	str	r3, [sp, #52]	; 0x34
  gpio_init_structure.Pin   = GPIO_PIN_3;
9000115c:	2308      	movs	r3, #8
9000115e:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
90001160:	f000 fb9c 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
90001164:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90001168:	a909      	add	r1, sp, #36	; 0x24
9000116a:	4829      	ldr	r0, [pc, #164]	; (90001210 <BSP_SDRAM_MspInit+0x160>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
9000116c:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
9000116e:	f000 fb95 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
90001172:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
90001176:	a909      	add	r1, sp, #36	; 0x24
90001178:	4826      	ldr	r0, [pc, #152]	; (90001214 <BSP_SDRAM_MspInit+0x164>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
9000117a:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
9000117c:	f000 fb8e 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
90001180:	f64f 033f 	movw	r3, #63551	; 0xf83f
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
90001184:	a909      	add	r1, sp, #36	; 0x24
90001186:	4824      	ldr	r0, [pc, #144]	; (90001218 <BSP_SDRAM_MspInit+0x168>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
90001188:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
9000118a:	f000 fb87 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
9000118e:	f248 1333 	movw	r3, #33075	; 0x8133
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
90001192:	a909      	add	r1, sp, #36	; 0x24
90001194:	4821      	ldr	r0, [pc, #132]	; (9000121c <BSP_SDRAM_MspInit+0x16c>)
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
90001196:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
90001198:	f000 fb80 	bl	9000189c <HAL_GPIO_Init>
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
9000119c:	2328      	movs	r3, #40	; 0x28
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
9000119e:	a909      	add	r1, sp, #36	; 0x24
900011a0:	481f      	ldr	r0, [pc, #124]	; (90001220 <BSP_SDRAM_MspInit+0x170>)
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
900011a2:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
900011a4:	f000 fb7a 	bl	9000189c <HAL_GPIO_Init>
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
900011a8:	4b1e      	ldr	r3, [pc, #120]	; (90001224 <BSP_SDRAM_MspInit+0x174>)
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
900011aa:	2280      	movs	r2, #128	; 0x80
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
900011ac:	f44f 7100 	mov.w	r1, #512	; 0x200
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
900011b0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
  
  dma_handle.Instance = SDRAM_DMAx_STREAM;
900011b4:	461d      	mov	r5, r3
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
900011b6:	641c      	str	r4, [r3, #64]	; 0x40
  dma_handle.Init.Mode                = DMA_NORMAL;
900011b8:	62dc      	str	r4, [r3, #44]	; 0x2c
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
900011ba:	e9c3 4205 	strd	r4, r2, [r3, #20]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
900011be:	f44f 6280 	mov.w	r2, #1024	; 0x400
900011c2:	e9c3 1207 	strd	r1, r2, [r3, #28]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
900011c6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
900011ca:	e9c3 0209 	strd	r0, r2, [r3, #36]	; 0x24
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
900011ce:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
900011d2:	e9c3 240c 	strd	r2, r4, [r3, #48]	; 0x30
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
900011d6:	2203      	movs	r2, #3
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
900011d8:	e9c3 240e 	strd	r2, r4, [r3, #56]	; 0x38
  dma_handle.Instance = SDRAM_DMAx_STREAM;
900011dc:	4a12      	ldr	r2, [pc, #72]	; (90001228 <BSP_SDRAM_MspInit+0x178>)
900011de:	f845 2f10 	str.w	r2, [r5, #16]!
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
900011e2:	4628      	mov	r0, r5
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
900011e4:	6335      	str	r5, [r6, #48]	; 0x30
900011e6:	649e      	str	r6, [r3, #72]	; 0x48
  HAL_DMA_DeInit(&dma_handle);
900011e8:	f000 f9dc 	bl	900015a4 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
900011ec:	4628      	mov	r0, r5
900011ee:	f000 f959 	bl	900014a4 <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0x0F, 0);
900011f2:	4622      	mov	r2, r4
900011f4:	210f      	movs	r1, #15
900011f6:	2038      	movs	r0, #56	; 0x38
900011f8:	f000 f8e8 	bl	900013cc <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
900011fc:	2038      	movs	r0, #56	; 0x38
900011fe:	f000 f917 	bl	90001430 <HAL_NVIC_EnableIRQ>
}
90001202:	b00e      	add	sp, #56	; 0x38
90001204:	bd70      	pop	{r4, r5, r6, pc}
90001206:	bf00      	nop
90001208:	40023800 	.word	0x40023800
9000120c:	40020800 	.word	0x40020800
90001210:	40020c00 	.word	0x40020c00
90001214:	40021000 	.word	0x40021000
90001218:	40021400 	.word	0x40021400
9000121c:	40021800 	.word	0x40021800
90001220:	40021c00 	.word	0x40021c00
90001224:	2000031c 	.word	0x2000031c
90001228:	40026410 	.word	0x40026410

9000122c <BSP_SDRAM_Init>:
{ 
9000122c:	b538      	push	{r3, r4, r5, lr}
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
9000122e:	4c1a      	ldr	r4, [pc, #104]	; (90001298 <BSP_SDRAM_Init+0x6c>)
  Timing.ExitSelfRefreshDelay = 7;
90001230:	2107      	movs	r1, #7
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
90001232:	4b1a      	ldr	r3, [pc, #104]	; (9000129c <BSP_SDRAM_Init+0x70>)
  Timing.SelfRefreshTime      = 4;
90001234:	2204      	movs	r2, #4
  Timing.LoadToActiveDelay    = 2;
90001236:	4d1a      	ldr	r5, [pc, #104]	; (900012a0 <BSP_SDRAM_Init+0x74>)
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
90001238:	f44f 6000 	mov.w	r0, #2048	; 0x800
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
9000123c:	6023      	str	r3, [r4, #0]
  Timing.ExitSelfRefreshDelay = 7;
9000123e:	2302      	movs	r3, #2
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
90001240:	60e2      	str	r2, [r4, #12]
  Timing.RCDDelay             = 2;
90001242:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
  Timing.ExitSelfRefreshDelay = 7;
90001246:	e9c5 311c 	strd	r3, r1, [r5, #112]	; 0x70
  Timing.RowCycleDelay        = 7;
9000124a:	e9c5 211e 	strd	r2, r1, [r5, #120]	; 0x78
  Timing.RPDelay              = 2;
9000124e:	e9c5 3320 	strd	r3, r3, [r5, #128]	; 0x80
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
90001252:	2210      	movs	r2, #16
90001254:	2340      	movs	r3, #64	; 0x40
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
90001256:	2100      	movs	r1, #0
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
90001258:	e9c4 2304 	strd	r2, r3, [r4, #16]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
9000125c:	f44f 7380 	mov.w	r3, #256	; 0x100
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
90001260:	62a1      	str	r1, [r4, #40]	; 0x28
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
90001262:	e9c4 3106 	strd	r3, r1, [r4, #24]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
90001266:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000126a:	e9c4 0308 	strd	r0, r3, [r4, #32]
  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
9000126e:	4620      	mov	r0, r4
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
90001270:	e9c4 1101 	strd	r1, r1, [r4, #4]
  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
90001274:	f7ff ff1c 	bl	900010b0 <BSP_SDRAM_MspInit>
  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
90001278:	f105 0170 	add.w	r1, r5, #112	; 0x70
9000127c:	4620      	mov	r0, r4
9000127e:	4c09      	ldr	r4, [pc, #36]	; (900012a4 <BSP_SDRAM_Init+0x78>)
90001280:	f001 ff7f 	bl	90003182 <HAL_SDRAM_Init>
90001284:	3800      	subs	r0, #0
90001286:	bf18      	it	ne
90001288:	2001      	movne	r0, #1
9000128a:	7020      	strb	r0, [r4, #0]
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
9000128c:	f240 6003 	movw	r0, #1539	; 0x603
90001290:	f7ff fec4 	bl	9000101c <BSP_SDRAM_Initialization_sequence>
}
90001294:	7820      	ldrb	r0, [r4, #0]
90001296:	bd38      	pop	{r3, r4, r5, pc}
90001298:	2000057c 	.word	0x2000057c
9000129c:	a0000140 	.word	0xa0000140
900012a0:	2000031c 	.word	0x2000031c
900012a4:	20000028 	.word	0x20000028

900012a8 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
900012a8:	490f      	ldr	r1, [pc, #60]	; (900012e8 <SystemInit+0x40>)
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
900012aa:	2000      	movs	r0, #0
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
900012ac:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
900012b0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
900012b4:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
900012b8:	4b0c      	ldr	r3, [pc, #48]	; (900012ec <SystemInit+0x44>)
900012ba:	681a      	ldr	r2, [r3, #0]
900012bc:	f042 0201 	orr.w	r2, r2, #1
900012c0:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
900012c2:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
900012c4:	681a      	ldr	r2, [r3, #0]
900012c6:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
900012ca:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
900012ce:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
900012d0:	4a07      	ldr	r2, [pc, #28]	; (900012f0 <SystemInit+0x48>)
900012d2:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
900012d4:	681a      	ldr	r2, [r3, #0]
900012d6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
900012da:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
900012dc:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = APPLICATION_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation to APPLICATION_ADDRESS in preprocessor defines */
900012de:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000
900012e2:	608b      	str	r3, [r1, #8]
#endif
}
900012e4:	4770      	bx	lr
900012e6:	bf00      	nop
900012e8:	e000ed00 	.word	0xe000ed00
900012ec:	40023800 	.word	0x40023800
900012f0:	24003010 	.word	0x24003010

900012f4 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
900012f4:	4770      	bx	lr
	...

900012f8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
900012f8:	b570      	push	{r4, r5, r6, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
900012fa:	4e0e      	ldr	r6, [pc, #56]	; (90001334 <HAL_InitTick+0x3c>)
{
900012fc:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
900012fe:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90001302:	4a0d      	ldr	r2, [pc, #52]	; (90001338 <HAL_InitTick+0x40>)
90001304:	7830      	ldrb	r0, [r6, #0]
90001306:	fbb3 f3f0 	udiv	r3, r3, r0
9000130a:	6810      	ldr	r0, [r2, #0]
9000130c:	fbb0 f0f3 	udiv	r0, r0, r3
90001310:	f000 f89c 	bl	9000144c <HAL_SYSTICK_Config>
90001314:	4604      	mov	r4, r0
90001316:	b950      	cbnz	r0, 9000132e <HAL_InitTick+0x36>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
90001318:	2d0f      	cmp	r5, #15
9000131a:	d808      	bhi.n	9000132e <HAL_InitTick+0x36>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
9000131c:	4602      	mov	r2, r0
9000131e:	4629      	mov	r1, r5
90001320:	f04f 30ff 	mov.w	r0, #4294967295
90001324:	f000 f852 	bl	900013cc <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
90001328:	4620      	mov	r0, r4
9000132a:	6075      	str	r5, [r6, #4]
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
9000132c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
9000132e:	2001      	movs	r0, #1
90001330:	e7fc      	b.n	9000132c <HAL_InitTick+0x34>
90001332:	bf00      	nop
90001334:	20000030 	.word	0x20000030
90001338:	2000002c 	.word	0x2000002c

9000133c <HAL_Init>:
   __HAL_FLASH_ART_ENABLE();
9000133c:	4a07      	ldr	r2, [pc, #28]	; (9000135c <HAL_Init+0x20>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
9000133e:	2003      	movs	r0, #3
{
90001340:	b508      	push	{r3, lr}
   __HAL_FLASH_ART_ENABLE();
90001342:	6813      	ldr	r3, [r2, #0]
90001344:	f443 7300 	orr.w	r3, r3, #512	; 0x200
90001348:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
9000134a:	f000 f82d 	bl	900013a8 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
9000134e:	200f      	movs	r0, #15
90001350:	f7ff ffd2 	bl	900012f8 <HAL_InitTick>
  HAL_MspInit();
90001354:	f7ff ffce 	bl	900012f4 <HAL_MspInit>
}
90001358:	2000      	movs	r0, #0
9000135a:	bd08      	pop	{r3, pc}
9000135c:	40023c00 	.word	0x40023c00

90001360 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
90001360:	4a03      	ldr	r2, [pc, #12]	; (90001370 <HAL_IncTick+0x10>)
90001362:	4b04      	ldr	r3, [pc, #16]	; (90001374 <HAL_IncTick+0x14>)
90001364:	6811      	ldr	r1, [r2, #0]
90001366:	781b      	ldrb	r3, [r3, #0]
90001368:	440b      	add	r3, r1
9000136a:	6013      	str	r3, [r2, #0]
}
9000136c:	4770      	bx	lr
9000136e:	bf00      	nop
90001370:	200005b0 	.word	0x200005b0
90001374:	20000030 	.word	0x20000030

90001378 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
90001378:	4b01      	ldr	r3, [pc, #4]	; (90001380 <HAL_GetTick+0x8>)
9000137a:	6818      	ldr	r0, [r3, #0]
}
9000137c:	4770      	bx	lr
9000137e:	bf00      	nop
90001380:	200005b0 	.word	0x200005b0

90001384 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
90001384:	b538      	push	{r3, r4, r5, lr}
90001386:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
90001388:	f7ff fff6 	bl	90001378 <HAL_GetTick>
9000138c:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
9000138e:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
90001390:	bf1e      	ittt	ne
90001392:	4b04      	ldrne	r3, [pc, #16]	; (900013a4 <HAL_Delay+0x20>)
90001394:	781b      	ldrbne	r3, [r3, #0]
90001396:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
90001398:	f7ff ffee 	bl	90001378 <HAL_GetTick>
9000139c:	1b43      	subs	r3, r0, r5
9000139e:	42a3      	cmp	r3, r4
900013a0:	d3fa      	bcc.n	90001398 <HAL_Delay+0x14>
  {
  }
}
900013a2:	bd38      	pop	{r3, r4, r5, pc}
900013a4:	20000030 	.word	0x20000030

900013a8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
900013a8:	4907      	ldr	r1, [pc, #28]	; (900013c8 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
900013aa:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
900013ac:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
900013ae:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
900013b2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
900013b6:	0412      	lsls	r2, r2, #16
900013b8:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
900013ba:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
900013bc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
900013c0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
900013c4:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
900013c6:	4770      	bx	lr
900013c8:	e000ed00 	.word	0xe000ed00

900013cc <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
900013cc:	4b16      	ldr	r3, [pc, #88]	; (90001428 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
900013ce:	b530      	push	{r4, r5, lr}
900013d0:	68dc      	ldr	r4, [r3, #12]
900013d2:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
900013d6:	f1c4 0507 	rsb	r5, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
900013da:	1d23      	adds	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
900013dc:	2d04      	cmp	r5, #4
900013de:	bf28      	it	cs
900013e0:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
900013e2:	2b06      	cmp	r3, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
900013e4:	f04f 33ff 	mov.w	r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
900013e8:	bf8c      	ite	hi
900013ea:	3c03      	subhi	r4, #3
900013ec:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
900013ee:	fa03 f505 	lsl.w	r5, r3, r5
  if ((int32_t)(IRQn) >= 0)
900013f2:	2800      	cmp	r0, #0
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
900013f4:	fa03 f304 	lsl.w	r3, r3, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
900013f8:	ea21 0105 	bic.w	r1, r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
900013fc:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001400:	fa01 f104 	lsl.w	r1, r1, r4
90001404:	ea41 0302 	orr.w	r3, r1, r2
90001408:	ea4f 1303 	mov.w	r3, r3, lsl #4
9000140c:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
9000140e:	db06      	blt.n	9000141e <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001410:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
90001414:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
90001418:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
9000141c:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
9000141e:	f000 000f 	and.w	r0, r0, #15
90001422:	4a02      	ldr	r2, [pc, #8]	; (9000142c <HAL_NVIC_SetPriority+0x60>)
90001424:	5413      	strb	r3, [r2, r0]
90001426:	e7f9      	b.n	9000141c <HAL_NVIC_SetPriority+0x50>
90001428:	e000ed00 	.word	0xe000ed00
9000142c:	e000ed14 	.word	0xe000ed14

90001430 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
90001430:	2800      	cmp	r0, #0
90001432:	db08      	blt.n	90001446 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
90001434:	0942      	lsrs	r2, r0, #5
90001436:	2301      	movs	r3, #1
90001438:	f000 001f 	and.w	r0, r0, #31
9000143c:	fa03 f000 	lsl.w	r0, r3, r0
90001440:	4b01      	ldr	r3, [pc, #4]	; (90001448 <HAL_NVIC_EnableIRQ+0x18>)
90001442:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
90001446:	4770      	bx	lr
90001448:	e000e100 	.word	0xe000e100

9000144c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
9000144c:	3801      	subs	r0, #1
9000144e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
90001452:	d20a      	bcs.n	9000146a <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
90001454:	4b06      	ldr	r3, [pc, #24]	; (90001470 <HAL_SYSTICK_Config+0x24>)
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001456:	21f0      	movs	r1, #240	; 0xf0
90001458:	4a06      	ldr	r2, [pc, #24]	; (90001474 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
9000145a:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
9000145c:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
9000145e:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
90001462:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
90001464:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
90001466:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
90001468:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
9000146a:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
9000146c:	4770      	bx	lr
9000146e:	bf00      	nop
90001470:	e000e010 	.word	0xe000e010
90001474:	e000ed00 	.word	0xe000ed00

90001478 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
90001478:	6803      	ldr	r3, [r0, #0]
{
9000147a:	4602      	mov	r2, r0
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
9000147c:	2018      	movs	r0, #24
9000147e:	b2d9      	uxtb	r1, r3
90001480:	3910      	subs	r1, #16
90001482:	fbb1 f0f0 	udiv	r0, r1, r0
{
90001486:	b510      	push	{r4, lr}
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
90001488:	4c05      	ldr	r4, [pc, #20]	; (900014a0 <DMA_CalcBaseAndBitshift+0x28>)
  
  if (stream_number > 3U)
9000148a:	295f      	cmp	r1, #95	; 0x5f
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
9000148c:	5c20      	ldrb	r0, [r4, r0]
9000148e:	65d0      	str	r0, [r2, #92]	; 0x5c
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
90001490:	f423 707f 	bic.w	r0, r3, #1020	; 0x3fc
90001494:	f020 0003 	bic.w	r0, r0, #3
90001498:	bf88      	it	hi
9000149a:	3004      	addhi	r0, #4
9000149c:	6590      	str	r0, [r2, #88]	; 0x58
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
9000149e:	bd10      	pop	{r4, pc}
900014a0:	90009304 	.word	0x90009304

900014a4 <HAL_DMA_Init>:
{
900014a4:	b570      	push	{r4, r5, r6, lr}
900014a6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
900014a8:	f7ff ff66 	bl	90001378 <HAL_GetTick>
900014ac:	4605      	mov	r5, r0
  if(hdma == NULL)
900014ae:	2c00      	cmp	r4, #0
900014b0:	d073      	beq.n	9000159a <HAL_DMA_Init+0xf6>
  __HAL_UNLOCK(hdma);
900014b2:	2300      	movs	r3, #0
  __HAL_DMA_DISABLE(hdma);
900014b4:	6822      	ldr	r2, [r4, #0]
  __HAL_UNLOCK(hdma);
900014b6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
900014ba:	2302      	movs	r3, #2
900014bc:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
900014c0:	6813      	ldr	r3, [r2, #0]
900014c2:	f023 0301 	bic.w	r3, r3, #1
900014c6:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
900014c8:	6821      	ldr	r1, [r4, #0]
900014ca:	680b      	ldr	r3, [r1, #0]
900014cc:	07d8      	lsls	r0, r3, #31
900014ce:	d42f      	bmi.n	90001530 <HAL_DMA_Init+0x8c>
  tmp = hdma->Instance->CR;
900014d0:	680b      	ldr	r3, [r1, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
900014d2:	4d33      	ldr	r5, [pc, #204]	; (900015a0 <HAL_DMA_Init+0xfc>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
900014d4:	69a0      	ldr	r0, [r4, #24]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
900014d6:	401d      	ands	r5, r3
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
900014d8:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
900014dc:	4313      	orrs	r3, r2
900014de:	68e2      	ldr	r2, [r4, #12]
900014e0:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
900014e2:	6922      	ldr	r2, [r4, #16]
900014e4:	4313      	orrs	r3, r2
900014e6:	6962      	ldr	r2, [r4, #20]
900014e8:	4313      	orrs	r3, r2
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
900014ea:	69e2      	ldr	r2, [r4, #28]
900014ec:	4303      	orrs	r3, r0
900014ee:	4313      	orrs	r3, r2
          hdma->Init.Mode                | hdma->Init.Priority;
900014f0:	6a22      	ldr	r2, [r4, #32]
900014f2:	4313      	orrs	r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
900014f4:	6a62      	ldr	r2, [r4, #36]	; 0x24
900014f6:	2a04      	cmp	r2, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
900014f8:	ea43 0305 	orr.w	r3, r3, r5
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
900014fc:	bf02      	ittt	eq
900014fe:	e9d4 560b 	ldrdeq	r5, r6, [r4, #44]	; 0x2c
90001502:	4335      	orreq	r5, r6
90001504:	432b      	orreq	r3, r5
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
90001506:	2a04      	cmp	r2, #4
  hdma->Instance->CR = tmp;  
90001508:	600b      	str	r3, [r1, #0]
  tmp = hdma->Instance->FCR;
9000150a:	694b      	ldr	r3, [r1, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
9000150c:	f023 0307 	bic.w	r3, r3, #7
  tmp |= hdma->Init.FIFOMode;
90001510:	ea43 0302 	orr.w	r3, r3, r2
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
90001514:	d133      	bne.n	9000157e <HAL_DMA_Init+0xda>
    tmp |= hdma->Init.FIFOThreshold;
90001516:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
90001518:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
9000151a:	4313      	orrs	r3, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
9000151c:	b37d      	cbz	r5, 9000157e <HAL_DMA_Init+0xda>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
9000151e:	b990      	cbnz	r0, 90001546 <HAL_DMA_Init+0xa2>
  {
    switch (tmp)
90001520:	2a01      	cmp	r2, #1
90001522:	d021      	beq.n	90001568 <HAL_DMA_Init+0xc4>
90001524:	f032 0202 	bics.w	r2, r2, #2
90001528:	d129      	bne.n	9000157e <HAL_DMA_Init+0xda>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
9000152a:	01ea      	lsls	r2, r5, #7
9000152c:	d527      	bpl.n	9000157e <HAL_DMA_Init+0xda>
9000152e:	e01e      	b.n	9000156e <HAL_DMA_Init+0xca>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
90001530:	f7ff ff22 	bl	90001378 <HAL_GetTick>
90001534:	1b40      	subs	r0, r0, r5
90001536:	2805      	cmp	r0, #5
90001538:	d9c6      	bls.n	900014c8 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
9000153a:	2320      	movs	r3, #32
      hdma->State = HAL_DMA_STATE_TIMEOUT;
9000153c:	2003      	movs	r0, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
9000153e:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
90001540:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
90001544:	bd70      	pop	{r4, r5, r6, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
90001546:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
9000154a:	d114      	bne.n	90001576 <HAL_DMA_Init+0xd2>
    switch (tmp)
9000154c:	2a03      	cmp	r2, #3
9000154e:	d816      	bhi.n	9000157e <HAL_DMA_Init+0xda>
90001550:	a001      	add	r0, pc, #4	; (adr r0, 90001558 <HAL_DMA_Init+0xb4>)
90001552:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
90001556:	bf00      	nop
90001558:	9000156f 	.word	0x9000156f
9000155c:	9000152b 	.word	0x9000152b
90001560:	9000156f 	.word	0x9000156f
90001564:	90001569 	.word	0x90001569
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
90001568:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
9000156c:	d107      	bne.n	9000157e <HAL_DMA_Init+0xda>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
9000156e:	2340      	movs	r3, #64	; 0x40
        hdma->State = HAL_DMA_STATE_READY;
90001570:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
90001572:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
90001574:	e7e4      	b.n	90001540 <HAL_DMA_Init+0x9c>
    switch (tmp)
90001576:	2a02      	cmp	r2, #2
90001578:	d9f9      	bls.n	9000156e <HAL_DMA_Init+0xca>
9000157a:	2a03      	cmp	r2, #3
9000157c:	d0d5      	beq.n	9000152a <HAL_DMA_Init+0x86>
  hdma->Instance->FCR = tmp;
9000157e:	614b      	str	r3, [r1, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
90001580:	4620      	mov	r0, r4
90001582:	f7ff ff79 	bl	90001478 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
90001586:	6de2      	ldr	r2, [r4, #92]	; 0x5c
90001588:	233f      	movs	r3, #63	; 0x3f
9000158a:	4093      	lsls	r3, r2
9000158c:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
9000158e:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
90001590:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
90001592:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
90001594:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
90001598:	e7d4      	b.n	90001544 <HAL_DMA_Init+0xa0>
    return HAL_ERROR;
9000159a:	2001      	movs	r0, #1
9000159c:	e7d2      	b.n	90001544 <HAL_DMA_Init+0xa0>
9000159e:	bf00      	nop
900015a0:	f010803f 	.word	0xf010803f

900015a4 <HAL_DMA_DeInit>:
{
900015a4:	b538      	push	{r3, r4, r5, lr}
  if(hdma == NULL)
900015a6:	4605      	mov	r5, r0
900015a8:	b320      	cbz	r0, 900015f4 <HAL_DMA_DeInit+0x50>
  if(hdma->State == HAL_DMA_STATE_BUSY)
900015aa:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
900015ae:	2b02      	cmp	r3, #2
900015b0:	b2dc      	uxtb	r4, r3
900015b2:	d01d      	beq.n	900015f0 <HAL_DMA_DeInit+0x4c>
  __HAL_DMA_DISABLE(hdma);
900015b4:	6803      	ldr	r3, [r0, #0]
  hdma->Instance->CR   = 0U;
900015b6:	2400      	movs	r4, #0
  __HAL_DMA_DISABLE(hdma);
900015b8:	681a      	ldr	r2, [r3, #0]
900015ba:	f022 0201 	bic.w	r2, r2, #1
900015be:	601a      	str	r2, [r3, #0]
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
900015c0:	2221      	movs	r2, #33	; 0x21
  hdma->Instance->CR   = 0U;
900015c2:	601c      	str	r4, [r3, #0]
  hdma->Instance->NDTR = 0U;
900015c4:	605c      	str	r4, [r3, #4]
  hdma->Instance->PAR  = 0U;
900015c6:	609c      	str	r4, [r3, #8]
  hdma->Instance->M0AR = 0U;
900015c8:	60dc      	str	r4, [r3, #12]
  hdma->Instance->M1AR = 0U;
900015ca:	611c      	str	r4, [r3, #16]
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
900015cc:	615a      	str	r2, [r3, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
900015ce:	f7ff ff53 	bl	90001478 <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
900015d2:	6dea      	ldr	r2, [r5, #92]	; 0x5c
900015d4:	233f      	movs	r3, #63	; 0x3f
900015d6:	4093      	lsls	r3, r2
900015d8:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
900015da:	656c      	str	r4, [r5, #84]	; 0x54
  __HAL_UNLOCK(hdma);
900015dc:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_RESET;
900015e0:	f885 4035 	strb.w	r4, [r5, #53]	; 0x35
  hdma->XferHalfCpltCallback = NULL;
900015e4:	e9c5 440f 	strd	r4, r4, [r5, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
900015e8:	e9c5 4411 	strd	r4, r4, [r5, #68]	; 0x44
  hdma->XferAbortCallback = NULL;  
900015ec:	e9c5 4413 	strd	r4, r4, [r5, #76]	; 0x4c
}
900015f0:	4620      	mov	r0, r4
900015f2:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
900015f4:	2401      	movs	r4, #1
900015f6:	e7fb      	b.n	900015f0 <HAL_DMA_DeInit+0x4c>

900015f8 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
900015f8:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
900015fa:	6804      	ldr	r4, [r0, #0]
900015fc:	9d04      	ldr	r5, [sp, #16]
900015fe:	6c66      	ldr	r6, [r4, #68]	; 0x44
90001600:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
90001604:	f006 4640 	and.w	r6, r6, #3221225472	; 0xc0000000
90001608:	4333      	orrs	r3, r6
9000160a:	6463      	str	r3, [r4, #68]	; 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
9000160c:	6843      	ldr	r3, [r0, #4]
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
9000160e:	63e2      	str	r2, [r4, #60]	; 0x3c
  if (hdma2d->Init.Mode == DMA2D_R2M)
90001610:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
90001614:	d130      	bne.n	90001678 <DMA2D_SetConfig+0x80>
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
90001616:	6886      	ldr	r6, [r0, #8]
90001618:	b11e      	cbz	r6, 90001622 <DMA2D_SetConfig+0x2a>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
9000161a:	2e01      	cmp	r6, #1
9000161c:	d103      	bne.n	90001626 <DMA2D_SetConfig+0x2e>
    {
      tmp = (tmp3 | tmp2 | tmp4);
9000161e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
      tmp3 = (tmp3 >> 12U);
      tmp4 = (tmp4 >> 4U);
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
90001622:	63a1      	str	r1, [r4, #56]	; 0x38
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
90001624:	bd70      	pop	{r4, r5, r6, pc}
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
90001626:	2e02      	cmp	r6, #2
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
90001628:	f401 037f 	and.w	r3, r1, #16711680	; 0xff0000
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
9000162c:	f401 457f 	and.w	r5, r1, #65280	; 0xff00
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
90001630:	b2c8      	uxtb	r0, r1
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
90001632:	d107      	bne.n	90001644 <DMA2D_SetConfig+0x4c>
      tmp2 = (tmp2 >> 19U);
90001634:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 10U);
90001636:	0aad      	lsrs	r5, r5, #10
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
90001638:	02db      	lsls	r3, r3, #11
9000163a:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
9000163e:	ea43 01d0 	orr.w	r1, r3, r0, lsr #3
90001642:	e7ee      	b.n	90001622 <DMA2D_SetConfig+0x2a>
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
90001644:	2e03      	cmp	r6, #3
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
90001646:	f001 427f 	and.w	r2, r1, #4278190080	; 0xff000000
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
9000164a:	d10a      	bne.n	90001662 <DMA2D_SetConfig+0x6a>
      tmp2 = (tmp2 >> 19U);
9000164c:	0cdb      	lsrs	r3, r3, #19
      tmp3 = (tmp3 >> 11U);
9000164e:	0aed      	lsrs	r5, r5, #11
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
90001650:	029b      	lsls	r3, r3, #10
      tmp1 = (tmp1 >> 31U);
90001652:	0fd1      	lsrs	r1, r2, #31
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
90001654:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
90001658:	ea43 03d0 	orr.w	r3, r3, r0, lsr #3
9000165c:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
90001660:	e7df      	b.n	90001622 <DMA2D_SetConfig+0x2a>
      tmp2 = (tmp2 >> 20U);
90001662:	0d19      	lsrs	r1, r3, #20
      tmp3 = (tmp3 >> 12U);
90001664:	0b2d      	lsrs	r5, r5, #12
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
90001666:	0209      	lsls	r1, r1, #8
      tmp1 = (tmp1 >> 28U);
90001668:	0f13      	lsrs	r3, r2, #28
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
9000166a:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
9000166e:	ea41 1110 	orr.w	r1, r1, r0, lsr #4
90001672:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
90001676:	e7d4      	b.n	90001622 <DMA2D_SetConfig+0x2a>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
90001678:	60e1      	str	r1, [r4, #12]
}
9000167a:	e7d3      	b.n	90001624 <DMA2D_SetConfig+0x2c>

9000167c <HAL_DMA2D_MspInit>:
}
9000167c:	4770      	bx	lr

9000167e <HAL_DMA2D_Init>:
{
9000167e:	b510      	push	{r4, lr}
  if (hdma2d == NULL)
90001680:	4604      	mov	r4, r0
90001682:	b330      	cbz	r0, 900016d2 <HAL_DMA2D_Init+0x54>
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
90001684:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
90001688:	f003 02ff 	and.w	r2, r3, #255	; 0xff
9000168c:	b91b      	cbnz	r3, 90001696 <HAL_DMA2D_Init+0x18>
    hdma2d->Lock = HAL_UNLOCKED;
9000168e:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_DMA2D_MspInit(hdma2d);
90001692:	f7ff fff3 	bl	9000167c <HAL_DMA2D_MspInit>
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
90001696:	6822      	ldr	r2, [r4, #0]
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
90001698:	2302      	movs	r3, #2
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
9000169a:	6861      	ldr	r1, [r4, #4]
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
9000169c:	2000      	movs	r0, #0
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
9000169e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
900016a2:	6813      	ldr	r3, [r2, #0]
900016a4:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
900016a8:	430b      	orrs	r3, r1
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
900016aa:	68a1      	ldr	r1, [r4, #8]
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
900016ac:	6013      	str	r3, [r2, #0]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
900016ae:	6b53      	ldr	r3, [r2, #52]	; 0x34
900016b0:	f023 0307 	bic.w	r3, r3, #7
900016b4:	430b      	orrs	r3, r1
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
900016b6:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
900016b8:	6353      	str	r3, [r2, #52]	; 0x34
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
900016ba:	6c13      	ldr	r3, [r2, #64]	; 0x40
900016bc:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
900016c0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
900016c4:	430b      	orrs	r3, r1
900016c6:	6413      	str	r3, [r2, #64]	; 0x40
  hdma2d->State  = HAL_DMA2D_STATE_READY;
900016c8:	2301      	movs	r3, #1
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
900016ca:	63e0      	str	r0, [r4, #60]	; 0x3c
  hdma2d->State  = HAL_DMA2D_STATE_READY;
900016cc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
}
900016d0:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
900016d2:	2001      	movs	r0, #1
900016d4:	e7fc      	b.n	900016d0 <HAL_DMA2D_Init+0x52>

900016d6 <HAL_DMA2D_Start>:
{
900016d6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hdma2d);
900016d8:	f890 5038 	ldrb.w	r5, [r0, #56]	; 0x38
{
900016dc:	4604      	mov	r4, r0
  __HAL_LOCK(hdma2d);
900016de:	2d01      	cmp	r5, #1
900016e0:	f04f 0502 	mov.w	r5, #2
900016e4:	d00f      	beq.n	90001706 <HAL_DMA2D_Start+0x30>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
900016e6:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
  __HAL_LOCK(hdma2d);
900016ea:	2601      	movs	r6, #1
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
900016ec:	9d06      	ldr	r5, [sp, #24]
  __HAL_LOCK(hdma2d);
900016ee:	f880 6038 	strb.w	r6, [r0, #56]	; 0x38
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
900016f2:	9500      	str	r5, [sp, #0]
900016f4:	f7ff ff80 	bl	900015f8 <DMA2D_SetConfig>
  __HAL_DMA2D_ENABLE(hdma2d);
900016f8:	6822      	ldr	r2, [r4, #0]
  return HAL_OK;
900016fa:	2000      	movs	r0, #0
  __HAL_DMA2D_ENABLE(hdma2d);
900016fc:	6813      	ldr	r3, [r2, #0]
900016fe:	4333      	orrs	r3, r6
90001700:	6013      	str	r3, [r2, #0]
}
90001702:	b002      	add	sp, #8
90001704:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hdma2d);
90001706:	4628      	mov	r0, r5
90001708:	e7fb      	b.n	90001702 <HAL_DMA2D_Start+0x2c>

9000170a <HAL_DMA2D_PollForTransfer>:
  __IO uint32_t isrflags = 0x0U;
9000170a:	2300      	movs	r3, #0
{
9000170c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t isrflags = 0x0U;
9000170e:	9301      	str	r3, [sp, #4]
{
90001710:	4604      	mov	r4, r0
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
90001712:	6803      	ldr	r3, [r0, #0]
{
90001714:	460d      	mov	r5, r1
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
90001716:	681b      	ldr	r3, [r3, #0]
90001718:	07db      	lsls	r3, r3, #31
9000171a:	d417      	bmi.n	9000174c <HAL_DMA2D_PollForTransfer+0x42>
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
9000171c:	6822      	ldr	r2, [r4, #0]
9000171e:	69d3      	ldr	r3, [r2, #28]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
90001720:	6a52      	ldr	r2, [r2, #36]	; 0x24
90001722:	4313      	orrs	r3, r2
  if (layer_start != 0U)
90001724:	069e      	lsls	r6, r3, #26
90001726:	d506      	bpl.n	90001736 <HAL_DMA2D_PollForTransfer+0x2c>
    tickstart = HAL_GetTick();
90001728:	f7ff fe26 	bl	90001378 <HAL_GetTick>
9000172c:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
9000172e:	6823      	ldr	r3, [r4, #0]
90001730:	685a      	ldr	r2, [r3, #4]
90001732:	06d2      	lsls	r2, r2, #27
90001734:	d543      	bpl.n	900017be <HAL_DMA2D_PollForTransfer+0xb4>
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
90001736:	6823      	ldr	r3, [r4, #0]
90001738:	2212      	movs	r2, #18
  __HAL_UNLOCK(hdma2d);
9000173a:	2000      	movs	r0, #0
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
9000173c:	609a      	str	r2, [r3, #8]
  hdma2d->State = HAL_DMA2D_STATE_READY;
9000173e:	2301      	movs	r3, #1
  __HAL_UNLOCK(hdma2d);
90001740:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
  hdma2d->State = HAL_DMA2D_STATE_READY;
90001744:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
}
90001748:	b002      	add	sp, #8
9000174a:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick();
9000174c:	f7ff fe14 	bl	90001378 <HAL_GetTick>
90001750:	4606      	mov	r6, r0
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
90001752:	6823      	ldr	r3, [r4, #0]
90001754:	685a      	ldr	r2, [r3, #4]
90001756:	0792      	lsls	r2, r2, #30
90001758:	d4e0      	bmi.n	9000171c <HAL_DMA2D_PollForTransfer+0x12>
      isrflags = READ_REG(hdma2d->Instance->ISR);
9000175a:	685a      	ldr	r2, [r3, #4]
9000175c:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
9000175e:	9a01      	ldr	r2, [sp, #4]
90001760:	f012 0f21 	tst.w	r2, #33	; 0x21
90001764:	d017      	beq.n	90001796 <HAL_DMA2D_PollForTransfer+0x8c>
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
90001766:	9a01      	ldr	r2, [sp, #4]
90001768:	0695      	lsls	r5, r2, #26
9000176a:	d503      	bpl.n	90001774 <HAL_DMA2D_PollForTransfer+0x6a>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
9000176c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
9000176e:	f042 0202 	orr.w	r2, r2, #2
90001772:	63e2      	str	r2, [r4, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
90001774:	9a01      	ldr	r2, [sp, #4]
90001776:	07d0      	lsls	r0, r2, #31
90001778:	d503      	bpl.n	90001782 <HAL_DMA2D_PollForTransfer+0x78>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
9000177a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
9000177c:	f042 0201 	orr.w	r2, r2, #1
90001780:	63e2      	str	r2, [r4, #60]	; 0x3c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
90001782:	2221      	movs	r2, #33	; 0x21
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
90001784:	609a      	str	r2, [r3, #8]
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
90001786:	2304      	movs	r3, #4
        return HAL_ERROR;
90001788:	2001      	movs	r0, #1
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
9000178a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
        __HAL_UNLOCK(hdma2d);
9000178e:	2300      	movs	r3, #0
90001790:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
        return HAL_ERROR;
90001794:	e7d8      	b.n	90001748 <HAL_DMA2D_PollForTransfer+0x3e>
      if (Timeout != HAL_MAX_DELAY)
90001796:	1c69      	adds	r1, r5, #1
90001798:	d0dc      	beq.n	90001754 <HAL_DMA2D_PollForTransfer+0x4a>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
9000179a:	f7ff fded 	bl	90001378 <HAL_GetTick>
9000179e:	1b80      	subs	r0, r0, r6
900017a0:	42a8      	cmp	r0, r5
900017a2:	d801      	bhi.n	900017a8 <HAL_DMA2D_PollForTransfer+0x9e>
900017a4:	2d00      	cmp	r5, #0
900017a6:	d1d4      	bne.n	90001752 <HAL_DMA2D_PollForTransfer+0x48>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
900017a8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
900017aa:	2003      	movs	r0, #3
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
900017ac:	f043 0320 	orr.w	r3, r3, #32
900017b0:	63e3      	str	r3, [r4, #60]	; 0x3c
          __HAL_UNLOCK(hdma2d);
900017b2:	2300      	movs	r3, #0
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
900017b4:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
          __HAL_UNLOCK(hdma2d);
900017b8:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
          return HAL_TIMEOUT;
900017bc:	e7c4      	b.n	90001748 <HAL_DMA2D_PollForTransfer+0x3e>
      isrflags = READ_REG(hdma2d->Instance->ISR);
900017be:	685a      	ldr	r2, [r3, #4]
900017c0:	9201      	str	r2, [sp, #4]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
900017c2:	9a01      	ldr	r2, [sp, #4]
900017c4:	f012 0f29 	tst.w	r2, #41	; 0x29
900017c8:	d016      	beq.n	900017f8 <HAL_DMA2D_PollForTransfer+0xee>
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
900017ca:	9a01      	ldr	r2, [sp, #4]
900017cc:	0716      	lsls	r6, r2, #28
900017ce:	d503      	bpl.n	900017d8 <HAL_DMA2D_PollForTransfer+0xce>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
900017d0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
900017d2:	f042 0204 	orr.w	r2, r2, #4
900017d6:	63e2      	str	r2, [r4, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
900017d8:	9a01      	ldr	r2, [sp, #4]
900017da:	0695      	lsls	r5, r2, #26
900017dc:	d503      	bpl.n	900017e6 <HAL_DMA2D_PollForTransfer+0xdc>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
900017de:	6be2      	ldr	r2, [r4, #60]	; 0x3c
900017e0:	f042 0202 	orr.w	r2, r2, #2
900017e4:	63e2      	str	r2, [r4, #60]	; 0x3c
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
900017e6:	9a01      	ldr	r2, [sp, #4]
900017e8:	07d0      	lsls	r0, r2, #31
900017ea:	d503      	bpl.n	900017f4 <HAL_DMA2D_PollForTransfer+0xea>
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
900017ec:	6be2      	ldr	r2, [r4, #60]	; 0x3c
900017ee:	f042 0201 	orr.w	r2, r2, #1
900017f2:	63e2      	str	r2, [r4, #60]	; 0x3c
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
900017f4:	2229      	movs	r2, #41	; 0x29
900017f6:	e7c5      	b.n	90001784 <HAL_DMA2D_PollForTransfer+0x7a>
      if (Timeout != HAL_MAX_DELAY)
900017f8:	1c69      	adds	r1, r5, #1
900017fa:	d099      	beq.n	90001730 <HAL_DMA2D_PollForTransfer+0x26>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
900017fc:	f7ff fdbc 	bl	90001378 <HAL_GetTick>
90001800:	1b80      	subs	r0, r0, r6
90001802:	42a8      	cmp	r0, r5
90001804:	d8d0      	bhi.n	900017a8 <HAL_DMA2D_PollForTransfer+0x9e>
90001806:	2d00      	cmp	r5, #0
90001808:	d191      	bne.n	9000172e <HAL_DMA2D_PollForTransfer+0x24>
9000180a:	e7cd      	b.n	900017a8 <HAL_DMA2D_PollForTransfer+0x9e>

9000180c <HAL_DMA2D_ConfigLayer>:
{
9000180c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma2d);
9000180e:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
90001812:	2b01      	cmp	r3, #1
90001814:	f04f 0302 	mov.w	r3, #2
90001818:	d02b      	beq.n	90001872 <HAL_DMA2D_ConfigLayer+0x66>
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
9000181a:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  __HAL_LOCK(hdma2d);
9000181e:	2201      	movs	r2, #1
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
90001820:	eb00 1301 	add.w	r3, r0, r1, lsl #4
90001824:	4f1c      	ldr	r7, [pc, #112]	; (90001898 <HAL_DMA2D_ConfigLayer+0x8c>)
  __HAL_LOCK(hdma2d);
90001826:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
9000182a:	010e      	lsls	r6, r1, #4
9000182c:	6a5d      	ldr	r5, [r3, #36]	; 0x24
9000182e:	e9d3 4207 	ldrd	r4, r2, [r3, #28]
90001832:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
90001836:	3c09      	subs	r4, #9
90001838:	2c01      	cmp	r4, #1
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
9000183a:	bf96      	itet	ls
9000183c:	f005 437f 	andls.w	r3, r5, #4278190080	; 0xff000000
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
90001840:	ea42 6205 	orrhi.w	r2, r2, r5, lsl #24
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
90001844:	431a      	orrls	r2, r3
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
90001846:	6803      	ldr	r3, [r0, #0]
90001848:	b9a9      	cbnz	r1, 90001876 <HAL_DMA2D_ConfigLayer+0x6a>
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
9000184a:	6a59      	ldr	r1, [r3, #36]	; 0x24
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
9000184c:	2c01      	cmp	r4, #1
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
9000184e:	ea01 0107 	and.w	r1, r1, r7
90001852:	ea42 0201 	orr.w	r2, r2, r1
90001856:	625a      	str	r2, [r3, #36]	; 0x24
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
90001858:	6982      	ldr	r2, [r0, #24]
9000185a:	619a      	str	r2, [r3, #24]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
9000185c:	d803      	bhi.n	90001866 <HAL_DMA2D_ConfigLayer+0x5a>
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
9000185e:	6a42      	ldr	r2, [r0, #36]	; 0x24
90001860:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
90001864:	629a      	str	r2, [r3, #40]	; 0x28
  hdma2d->State = HAL_DMA2D_STATE_READY;
90001866:	2301      	movs	r3, #1
90001868:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  __HAL_UNLOCK(hdma2d);
9000186c:	2300      	movs	r3, #0
9000186e:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  __HAL_LOCK(hdma2d);
90001872:	4618      	mov	r0, r3
}
90001874:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
90001876:	69d9      	ldr	r1, [r3, #28]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
90001878:	2c01      	cmp	r4, #1
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
9000187a:	ea01 0107 	and.w	r1, r1, r7
9000187e:	ea42 0201 	orr.w	r2, r2, r1
90001882:	61da      	str	r2, [r3, #28]
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
90001884:	eb00 0206 	add.w	r2, r0, r6
90001888:	6992      	ldr	r2, [r2, #24]
9000188a:	611a      	str	r2, [r3, #16]
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
9000188c:	d8eb      	bhi.n	90001866 <HAL_DMA2D_ConfigLayer+0x5a>
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
9000188e:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
90001892:	621d      	str	r5, [r3, #32]
90001894:	e7e7      	b.n	90001866 <HAL_DMA2D_ConfigLayer+0x5a>
90001896:	bf00      	nop
90001898:	00fcfff0 	.word	0x00fcfff0

9000189c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
9000189c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
900018a0:	2300      	movs	r3, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
900018a2:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 90001a60 <HAL_GPIO_Init+0x1c4>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
900018a6:	4a6c      	ldr	r2, [pc, #432]	; (90001a58 <HAL_GPIO_Init+0x1bc>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
900018a8:	f8df 91b8 	ldr.w	r9, [pc, #440]	; 90001a64 <HAL_GPIO_Init+0x1c8>
    ioposition = ((uint32_t)0x01) << position;
900018ac:	2401      	movs	r4, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
900018ae:	680d      	ldr	r5, [r1, #0]
    ioposition = ((uint32_t)0x01) << position;
900018b0:	409c      	lsls	r4, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
900018b2:	ea04 0605 	and.w	r6, r4, r5
    if(iocurrent == ioposition)
900018b6:	43ac      	bics	r4, r5
900018b8:	f040 80b4 	bne.w	90001a24 <HAL_GPIO_Init+0x188>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
900018bc:	684c      	ldr	r4, [r1, #4]
900018be:	ea4f 0e43 	mov.w	lr, r3, lsl #1
900018c2:	2503      	movs	r5, #3
900018c4:	f024 0c10 	bic.w	ip, r4, #16
900018c8:	fa05 f50e 	lsl.w	r5, r5, lr
900018cc:	f10c 37ff 	add.w	r7, ip, #4294967295
900018d0:	43ed      	mvns	r5, r5
900018d2:	2f01      	cmp	r7, #1
900018d4:	d811      	bhi.n	900018fa <HAL_GPIO_Init+0x5e>
        temp = GPIOx->OSPEEDR; 
900018d6:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
900018d8:	ea07 0a05 	and.w	sl, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
900018dc:	68cf      	ldr	r7, [r1, #12]
900018de:	fa07 f70e 	lsl.w	r7, r7, lr
900018e2:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
900018e6:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
900018e8:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
900018ea:	ea27 0a06 	bic.w	sl, r7, r6
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
900018ee:	f3c4 1700 	ubfx	r7, r4, #4, #1
900018f2:	409f      	lsls	r7, r3
900018f4:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OTYPER = temp;
900018f8:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
900018fa:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
900018fc:	f1bc 0f02 	cmp.w	ip, #2
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
90001900:	ea07 0a05 	and.w	sl, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2));
90001904:	688f      	ldr	r7, [r1, #8]
90001906:	fa07 f70e 	lsl.w	r7, r7, lr
9000190a:	ea47 070a 	orr.w	r7, r7, sl
      GPIOx->PUPDR = temp;
9000190e:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
90001910:	d116      	bne.n	90001940 <HAL_GPIO_Init+0xa4>
        temp = GPIOx->AFR[position >> 3];
90001912:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
90001916:	f003 0b07 	and.w	fp, r3, #7
9000191a:	f04f 0c0f 	mov.w	ip, #15
9000191e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
90001922:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3];
90001926:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
9000192a:	fa0c fc0b 	lsl.w	ip, ip, fp
9000192e:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
90001932:	690f      	ldr	r7, [r1, #16]
90001934:	fa07 f70b 	lsl.w	r7, r7, fp
90001938:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3] = temp;
9000193c:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
90001940:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
90001942:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
90001944:	f004 0703 	and.w	r7, r4, #3
90001948:	fa07 fe0e 	lsl.w	lr, r7, lr
9000194c:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
90001950:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
90001952:	00e5      	lsls	r5, r4, #3
90001954:	d566      	bpl.n	90001a24 <HAL_GPIO_Init+0x188>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90001956:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
9000195a:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
9000195e:	f003 0c03 	and.w	ip, r3, #3
90001962:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90001966:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
9000196a:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
9000196e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90001972:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
90001976:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
9000197a:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
9000197e:	f405 4580 	and.w	r5, r5, #16384	; 0x4000
90001982:	9501      	str	r5, [sp, #4]
90001984:	9d01      	ldr	r5, [sp, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
90001986:	fa0e f50c 	lsl.w	r5, lr, ip
        temp = SYSCFG->EXTICR[position >> 2];
9000198a:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
9000198e:	ea2a 0e05 	bic.w	lr, sl, r5
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
90001992:	4d32      	ldr	r5, [pc, #200]	; (90001a5c <HAL_GPIO_Init+0x1c0>)
90001994:	42a8      	cmp	r0, r5
90001996:	d04c      	beq.n	90001a32 <HAL_GPIO_Init+0x196>
90001998:	f505 6580 	add.w	r5, r5, #1024	; 0x400
9000199c:	42a8      	cmp	r0, r5
9000199e:	d04a      	beq.n	90001a36 <HAL_GPIO_Init+0x19a>
900019a0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
900019a4:	42a8      	cmp	r0, r5
900019a6:	d048      	beq.n	90001a3a <HAL_GPIO_Init+0x19e>
900019a8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
900019ac:	42a8      	cmp	r0, r5
900019ae:	d046      	beq.n	90001a3e <HAL_GPIO_Init+0x1a2>
900019b0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
900019b4:	42a8      	cmp	r0, r5
900019b6:	d044      	beq.n	90001a42 <HAL_GPIO_Init+0x1a6>
900019b8:	4548      	cmp	r0, r9
900019ba:	d044      	beq.n	90001a46 <HAL_GPIO_Init+0x1aa>
900019bc:	f505 6500 	add.w	r5, r5, #2048	; 0x800
900019c0:	42a8      	cmp	r0, r5
900019c2:	d042      	beq.n	90001a4a <HAL_GPIO_Init+0x1ae>
900019c4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
900019c8:	42a8      	cmp	r0, r5
900019ca:	d040      	beq.n	90001a4e <HAL_GPIO_Init+0x1b2>
900019cc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
900019d0:	42a8      	cmp	r0, r5
900019d2:	d03e      	beq.n	90001a52 <HAL_GPIO_Init+0x1b6>
900019d4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
900019d8:	42a8      	cmp	r0, r5
900019da:	bf0c      	ite	eq
900019dc:	2509      	moveq	r5, #9
900019de:	250a      	movne	r5, #10
900019e0:	fa05 f50c 	lsl.w	r5, r5, ip
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
900019e4:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
900019e8:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
900019ec:	60bd      	str	r5, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
900019ee:	ea6f 0706 	mvn.w	r7, r6
        temp = EXTI->IMR;
900019f2:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
900019f4:	bf0c      	ite	eq
900019f6:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
900019f8:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
900019fa:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        EXTI->IMR = temp;
900019fe:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
90001a00:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
90001a02:	bf0c      	ite	eq
90001a04:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
90001a06:	4335      	orrne	r5, r6
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
90001a08:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        EXTI->EMR = temp;
90001a0c:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
90001a0e:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
90001a10:	bf0c      	ite	eq
90001a12:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
90001a14:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
90001a16:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
90001a18:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
90001a1a:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
90001a1c:	bf54      	ite	pl
90001a1e:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
90001a20:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
90001a22:	60d5      	str	r5, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
90001a24:	3301      	adds	r3, #1
90001a26:	2b10      	cmp	r3, #16
90001a28:	f47f af40 	bne.w	900018ac <HAL_GPIO_Init+0x10>
      }
    }
  }
}
90001a2c:	b003      	add	sp, #12
90001a2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
90001a32:	2500      	movs	r5, #0
90001a34:	e7d4      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a36:	2501      	movs	r5, #1
90001a38:	e7d2      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a3a:	2502      	movs	r5, #2
90001a3c:	e7d0      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a3e:	2503      	movs	r5, #3
90001a40:	e7ce      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a42:	2504      	movs	r5, #4
90001a44:	e7cc      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a46:	2505      	movs	r5, #5
90001a48:	e7ca      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a4a:	2506      	movs	r5, #6
90001a4c:	e7c8      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a4e:	2507      	movs	r5, #7
90001a50:	e7c6      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a52:	2508      	movs	r5, #8
90001a54:	e7c4      	b.n	900019e0 <HAL_GPIO_Init+0x144>
90001a56:	bf00      	nop
90001a58:	40013c00 	.word	0x40013c00
90001a5c:	40020000 	.word	0x40020000
90001a60:	40023800 	.word	0x40023800
90001a64:	40021400 	.word	0x40021400

90001a68 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
90001a68:	6903      	ldr	r3, [r0, #16]
90001a6a:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
90001a6c:	bf14      	ite	ne
90001a6e:	2001      	movne	r0, #1
90001a70:	2000      	moveq	r0, #0
90001a72:	4770      	bx	lr

90001a74 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
90001a74:	b10a      	cbz	r2, 90001a7a <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
90001a76:	6181      	str	r1, [r0, #24]
  }
}
90001a78:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
90001a7a:	0409      	lsls	r1, r1, #16
90001a7c:	e7fb      	b.n	90001a76 <HAL_GPIO_WritePin+0x2>

90001a7e <LTDC_SetConfig>:
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
90001a7e:	01d2      	lsls	r2, r2, #7
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
90001a80:	f8d1 c000 	ldr.w	ip, [r1]
{
90001a84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
90001a88:	3284      	adds	r2, #132	; 0x84
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
90001a8a:	6804      	ldr	r4, [r0, #0]
90001a8c:	684f      	ldr	r7, [r1, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
90001a8e:	f10c 0601 	add.w	r6, ip, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
90001a92:	18a3      	adds	r3, r4, r2
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
90001a94:	68e5      	ldr	r5, [r4, #12]

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  tmp2 = (pLayerCfg->Alpha0 << 24U);
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
90001a96:	f04f 0e00 	mov.w	lr, #0
  tmp2 = (pLayerCfg->Alpha0 << 24U);
90001a9a:	f8d1 9018 	ldr.w	r9, [r1, #24]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
90001a9e:	6858      	ldr	r0, [r3, #4]
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
90001aa0:	f3c5 450b 	ubfx	r5, r5, #16, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
90001aa4:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
90001aa8:	443d      	add	r5, r7
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
90001aaa:	6058      	str	r0, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
90001aac:	68e0      	ldr	r0, [r4, #12]
90001aae:	f3c0 400b 	ubfx	r0, r0, #16, #12
90001ab2:	4430      	add	r0, r6
90001ab4:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
90001ab8:	68cd      	ldr	r5, [r1, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
90001aba:	6058      	str	r0, [r3, #4]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
90001abc:	68e0      	ldr	r0, [r4, #12]
90001abe:	f3c0 000a 	ubfx	r0, r0, #0, #11
90001ac2:	4405      	add	r5, r0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
90001ac4:	6898      	ldr	r0, [r3, #8]
90001ac6:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
90001aca:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
90001acc:	6888      	ldr	r0, [r1, #8]
90001ace:	68e6      	ldr	r6, [r4, #12]
90001ad0:	3001      	adds	r0, #1
90001ad2:	f3c6 060a 	ubfx	r6, r6, #0, #11
90001ad6:	4430      	add	r0, r6
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
90001ad8:	690e      	ldr	r6, [r1, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
90001ada:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
90001ade:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
90001ae0:	6918      	ldr	r0, [r3, #16]
90001ae2:	f020 0007 	bic.w	r0, r0, #7
90001ae6:	6118      	str	r0, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
90001ae8:	611e      	str	r6, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
90001aea:	699d      	ldr	r5, [r3, #24]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
90001aec:	f891 0032 	ldrb.w	r0, [r1, #50]	; 0x32
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
90001af0:	f891 8031 	ldrb.w	r8, [r1, #49]	; 0x31
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
90001af4:	f8c3 e018 	str.w	lr, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
90001af8:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
90001afc:	ea45 6509 	orr.w	r5, r5, r9, lsl #24
90001b00:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
90001b04:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
90001b08:	619d      	str	r5, [r3, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
90001b0a:	6958      	ldr	r0, [r3, #20]
90001b0c:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
90001b10:	6158      	str	r0, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
90001b12:	6948      	ldr	r0, [r1, #20]
90001b14:	6158      	str	r0, [r3, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
90001b16:	69d8      	ldr	r0, [r3, #28]
90001b18:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
90001b1c:	f020 0007 	bic.w	r0, r0, #7
90001b20:	61d8      	str	r0, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
90001b22:	e9d1 5007 	ldrd	r5, r0, [r1, #28]
90001b26:	4305      	orrs	r5, r0
90001b28:	61dd      	str	r5, [r3, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
90001b2a:	6a98      	ldr	r0, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
90001b2c:	6a48      	ldr	r0, [r1, #36]	; 0x24
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
90001b2e:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
90001b32:	6298      	str	r0, [r3, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
90001b34:	b31e      	cbz	r6, 90001b7e <LTDC_SetConfig+0x100>
  {
    tmp = 4U;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
90001b36:	2e01      	cmp	r6, #1
90001b38:	d023      	beq.n	90001b82 <LTDC_SetConfig+0x104>
  {
    tmp = 3U;
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
90001b3a:	1eb0      	subs	r0, r6, #2
90001b3c:	2802      	cmp	r0, #2
90001b3e:	d922      	bls.n	90001b86 <LTDC_SetConfig+0x108>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
90001b40:	2e07      	cmp	r6, #7
  {
    tmp = 2U;
  }
  else
  {
    tmp = 1U;
90001b42:	bf0c      	ite	eq
90001b44:	2002      	moveq	r0, #2
90001b46:	2001      	movne	r0, #1
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
90001b48:	6add      	ldr	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
90001b4a:	eba7 070c 	sub.w	r7, r7, ip
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
90001b4e:	f005 25e0 	and.w	r5, r5, #3758153728	; 0xe000e000
90001b52:	62dd      	str	r5, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
90001b54:	6a8d      	ldr	r5, [r1, #40]	; 0x28
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
90001b56:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
90001b58:	4345      	muls	r5, r0
90001b5a:	4378      	muls	r0, r7
90001b5c:	3003      	adds	r0, #3
90001b5e:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
90001b62:	62d8      	str	r0, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
90001b64:	6b18      	ldr	r0, [r3, #48]	; 0x30
90001b66:	f420 60ff 	bic.w	r0, r0, #2040	; 0x7f8
90001b6a:	f020 0007 	bic.w	r0, r0, #7
90001b6e:	6318      	str	r0, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
90001b70:	6319      	str	r1, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
90001b72:	58a3      	ldr	r3, [r4, r2]
90001b74:	f043 0301 	orr.w	r3, r3, #1
90001b78:	50a3      	str	r3, [r4, r2]
}
90001b7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tmp = 4U;
90001b7e:	2004      	movs	r0, #4
90001b80:	e7e2      	b.n	90001b48 <LTDC_SetConfig+0xca>
    tmp = 3U;
90001b82:	2003      	movs	r0, #3
90001b84:	e7e0      	b.n	90001b48 <LTDC_SetConfig+0xca>
    tmp = 2U;
90001b86:	2002      	movs	r0, #2
90001b88:	e7de      	b.n	90001b48 <LTDC_SetConfig+0xca>

90001b8a <HAL_LTDC_MspInit>:
}
90001b8a:	4770      	bx	lr

90001b8c <HAL_LTDC_Init>:
{
90001b8c:	b538      	push	{r3, r4, r5, lr}
  if (hltdc == NULL)
90001b8e:	4604      	mov	r4, r0
90001b90:	2800      	cmp	r0, #0
90001b92:	d063      	beq.n	90001c5c <HAL_LTDC_Init+0xd0>
  if (hltdc->State == HAL_LTDC_STATE_RESET)
90001b94:	f890 30a1 	ldrb.w	r3, [r0, #161]	; 0xa1
90001b98:	f003 02ff 	and.w	r2, r3, #255	; 0xff
90001b9c:	b91b      	cbnz	r3, 90001ba6 <HAL_LTDC_Init+0x1a>
    hltdc->Lock = HAL_UNLOCKED;
90001b9e:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
    HAL_LTDC_MspInit(hltdc);
90001ba2:	f7ff fff2 	bl	90001b8a <HAL_LTDC_MspInit>
  hltdc->State = HAL_LTDC_STATE_BUSY;
90001ba6:	2302      	movs	r3, #2
90001ba8:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
90001bac:	6823      	ldr	r3, [r4, #0]
90001bae:	699a      	ldr	r2, [r3, #24]
90001bb0:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
90001bb4:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
90001bb6:	6999      	ldr	r1, [r3, #24]
90001bb8:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
90001bbc:	4302      	orrs	r2, r0
90001bbe:	68e0      	ldr	r0, [r4, #12]
90001bc0:	4302      	orrs	r2, r0
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
90001bc2:	6920      	ldr	r0, [r4, #16]
90001bc4:	4302      	orrs	r2, r0
  tmp = (hltdc->Init.HorizontalSync << 16U);
90001bc6:	6960      	ldr	r0, [r4, #20]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
90001bc8:	430a      	orrs	r2, r1
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
90001bca:	4925      	ldr	r1, [pc, #148]	; (90001c60 <HAL_LTDC_Init+0xd4>)
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
90001bcc:	619a      	str	r2, [r3, #24]
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
90001bce:	689a      	ldr	r2, [r3, #8]
90001bd0:	400a      	ands	r2, r1
90001bd2:	609a      	str	r2, [r3, #8]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
90001bd4:	689a      	ldr	r2, [r3, #8]
90001bd6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
90001bda:	69a0      	ldr	r0, [r4, #24]
90001bdc:	4302      	orrs	r2, r0
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
90001bde:	69e0      	ldr	r0, [r4, #28]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
90001be0:	609a      	str	r2, [r3, #8]
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
90001be2:	68da      	ldr	r2, [r3, #12]
90001be4:	400a      	ands	r2, r1
90001be6:	60da      	str	r2, [r3, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
90001be8:	68da      	ldr	r2, [r3, #12]
90001bea:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
90001bee:	6a20      	ldr	r0, [r4, #32]
90001bf0:	4302      	orrs	r2, r0
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
90001bf2:	6a60      	ldr	r0, [r4, #36]	; 0x24
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
90001bf4:	60da      	str	r2, [r3, #12]
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
90001bf6:	691a      	ldr	r2, [r3, #16]
90001bf8:	400a      	ands	r2, r1
90001bfa:	611a      	str	r2, [r3, #16]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
90001bfc:	691a      	ldr	r2, [r3, #16]
90001bfe:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
90001c02:	6aa0      	ldr	r0, [r4, #40]	; 0x28
90001c04:	4302      	orrs	r2, r0
90001c06:	611a      	str	r2, [r3, #16]
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
90001c08:	695a      	ldr	r2, [r3, #20]
90001c0a:	4011      	ands	r1, r2
90001c0c:	6159      	str	r1, [r3, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
90001c0e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
90001c10:	695a      	ldr	r2, [r3, #20]
90001c12:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
90001c16:	6b21      	ldr	r1, [r4, #48]	; 0x30
90001c18:	430a      	orrs	r2, r1
90001c1a:	615a      	str	r2, [r3, #20]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
90001c1c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
90001c1e:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
90001c22:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
90001c26:	f894 5035 	ldrb.w	r5, [r4, #53]	; 0x35
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
90001c2a:	62d9      	str	r1, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
90001c2c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
90001c2e:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
90001c32:	430a      	orrs	r2, r1
90001c34:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
90001c38:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
90001c3c:	2000      	movs	r0, #0
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
90001c3e:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
90001c40:	6b5a      	ldr	r2, [r3, #52]	; 0x34
90001c42:	f042 0206 	orr.w	r2, r2, #6
90001c46:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_LTDC_ENABLE(hltdc);
90001c48:	699a      	ldr	r2, [r3, #24]
90001c4a:	f042 0201 	orr.w	r2, r2, #1
90001c4e:	619a      	str	r2, [r3, #24]
  hltdc->State = HAL_LTDC_STATE_READY;
90001c50:	2301      	movs	r3, #1
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
90001c52:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
  hltdc->State = HAL_LTDC_STATE_READY;
90001c56:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
}
90001c5a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
90001c5c:	2001      	movs	r0, #1
90001c5e:	e7fc      	b.n	90001c5a <HAL_LTDC_Init+0xce>
90001c60:	f000f800 	.word	0xf000f800

90001c64 <HAL_LTDC_ConfigLayer>:
{
90001c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(hltdc);
90001c68:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
{
90001c6c:	4606      	mov	r6, r0
90001c6e:	460f      	mov	r7, r1
90001c70:	4694      	mov	ip, r2
  __HAL_LOCK(hltdc);
90001c72:	2b01      	cmp	r3, #1
90001c74:	f04f 0002 	mov.w	r0, #2
90001c78:	d01f      	beq.n	90001cba <HAL_LTDC_ConfigLayer+0x56>
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
90001c7a:	2434      	movs	r4, #52	; 0x34
  __HAL_LOCK(hltdc);
90001c7c:	f04f 0801 	mov.w	r8, #1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
90001c80:	460d      	mov	r5, r1
  hltdc->State = HAL_LTDC_STATE_BUSY;
90001c82:	f886 00a1 	strb.w	r0, [r6, #161]	; 0xa1
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
90001c86:	fb04 6402 	mla	r4, r4, r2, r6
  __HAL_LOCK(hltdc);
90001c8a:	f886 80a0 	strb.w	r8, [r6, #160]	; 0xa0
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
90001c8e:	3438      	adds	r4, #56	; 0x38
90001c90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
90001c92:	c40f      	stmia	r4!, {r0, r1, r2, r3}
90001c94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
90001c96:	c40f      	stmia	r4!, {r0, r1, r2, r3}
90001c98:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
90001c9a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
90001c9c:	682b      	ldr	r3, [r5, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
90001c9e:	4630      	mov	r0, r6
90001ca0:	4662      	mov	r2, ip
90001ca2:	4639      	mov	r1, r7
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
90001ca4:	6023      	str	r3, [r4, #0]
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
90001ca6:	f7ff feea 	bl	90001a7e <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
90001caa:	6833      	ldr	r3, [r6, #0]
  __HAL_UNLOCK(hltdc);
90001cac:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
90001cae:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
  hltdc->State  = HAL_LTDC_STATE_READY;
90001cb2:	f886 80a1 	strb.w	r8, [r6, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
90001cb6:	f886 00a0 	strb.w	r0, [r6, #160]	; 0xa0
}
90001cba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

90001cbe <HAL_LTDC_SetWindowSize>:
{
90001cbe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hltdc);
90001cc0:	f890 50a0 	ldrb.w	r5, [r0, #160]	; 0xa0
{
90001cc4:	4604      	mov	r4, r0
90001cc6:	469e      	mov	lr, r3
  __HAL_LOCK(hltdc);
90001cc8:	2d01      	cmp	r5, #1
90001cca:	f04f 0502 	mov.w	r5, #2
90001cce:	d021      	beq.n	90001d14 <HAL_LTDC_SetWindowSize+0x56>
  hltdc->State = HAL_LTDC_STATE_BUSY;
90001cd0:	f880 50a1 	strb.w	r5, [r0, #161]	; 0xa1
  pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
90001cd4:	2534      	movs	r5, #52	; 0x34
  __HAL_LOCK(hltdc);
90001cd6:	2701      	movs	r7, #1
  pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
90001cd8:	435d      	muls	r5, r3
  __HAL_LOCK(hltdc);
90001cda:	f880 70a0 	strb.w	r7, [r0, #160]	; 0xa0
  pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
90001cde:	1946      	adds	r6, r0, r5
90001ce0:	6bb3      	ldr	r3, [r6, #56]	; 0x38
90001ce2:	eb03 0c01 	add.w	ip, r3, r1
  pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
90001ce6:	6c33      	ldr	r3, [r6, #64]	; 0x40
  pLayerCfg->ImageHeight = YSize;
90001ce8:	e9c6 1218 	strd	r1, r2, [r6, #96]	; 0x60
  pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
90001cec:	f8c6 c03c 	str.w	ip, [r6, #60]	; 0x3c
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
90001cf0:	f105 0138 	add.w	r1, r5, #56	; 0x38
  pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
90001cf4:	eb03 0c02 	add.w	ip, r3, r2
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
90001cf8:	4672      	mov	r2, lr
90001cfa:	4401      	add	r1, r0
  pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
90001cfc:	f8c6 c044 	str.w	ip, [r6, #68]	; 0x44
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
90001d00:	f7ff febd 	bl	90001a7e <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
90001d04:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hltdc);
90001d06:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
90001d08:	625f      	str	r7, [r3, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
90001d0a:	f884 70a1 	strb.w	r7, [r4, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
90001d0e:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0
}
90001d12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hltdc);
90001d14:	4628      	mov	r0, r5
90001d16:	e7fc      	b.n	90001d12 <HAL_LTDC_SetWindowSize+0x54>

90001d18 <HAL_LTDC_SetWindowPosition>:
{
90001d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hltdc);
90001d1a:	f890 50a0 	ldrb.w	r5, [r0, #160]	; 0xa0
{
90001d1e:	4604      	mov	r4, r0
90001d20:	469c      	mov	ip, r3
  __HAL_LOCK(hltdc);
90001d22:	2d01      	cmp	r5, #1
90001d24:	f04f 0502 	mov.w	r5, #2
90001d28:	d01d      	beq.n	90001d66 <HAL_LTDC_SetWindowPosition+0x4e>
  hltdc->State = HAL_LTDC_STATE_BUSY;
90001d2a:	f880 50a1 	strb.w	r5, [r0, #161]	; 0xa1
  pLayerCfg->WindowX0 = X0;
90001d2e:	2534      	movs	r5, #52	; 0x34
  __HAL_LOCK(hltdc);
90001d30:	2701      	movs	r7, #1
  pLayerCfg->WindowX0 = X0;
90001d32:	435d      	muls	r5, r3
  __HAL_LOCK(hltdc);
90001d34:	f880 70a0 	strb.w	r7, [r0, #160]	; 0xa0
  pLayerCfg->WindowX0 = X0;
90001d38:	1946      	adds	r6, r0, r5
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
90001d3a:	6e33      	ldr	r3, [r6, #96]	; 0x60
  pLayerCfg->WindowX0 = X0;
90001d3c:	63b1      	str	r1, [r6, #56]	; 0x38
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
90001d3e:	4419      	add	r1, r3
  pLayerCfg->WindowY0 = Y0;
90001d40:	e9c6 120f 	strd	r1, r2, [r6, #60]	; 0x3c
  pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
90001d44:	6e71      	ldr	r1, [r6, #100]	; 0x64
90001d46:	440a      	add	r2, r1
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
90001d48:	f105 0138 	add.w	r1, r5, #56	; 0x38
  pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
90001d4c:	6472      	str	r2, [r6, #68]	; 0x44
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
90001d4e:	4401      	add	r1, r0
90001d50:	4662      	mov	r2, ip
90001d52:	f7ff fe94 	bl	90001a7e <LTDC_SetConfig>
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
90001d56:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hltdc);
90001d58:	2000      	movs	r0, #0
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
90001d5a:	625f      	str	r7, [r3, #36]	; 0x24
  hltdc->State = HAL_LTDC_STATE_READY;
90001d5c:	f884 70a1 	strb.w	r7, [r4, #161]	; 0xa1
  __HAL_UNLOCK(hltdc);
90001d60:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0
}
90001d64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hltdc);
90001d66:	4628      	mov	r0, r5
90001d68:	e7fc      	b.n	90001d64 <HAL_LTDC_SetWindowPosition+0x4c>

90001d6a <HAL_LTDC_GetState>:
  return hltdc->State;
90001d6a:	f890 00a1 	ldrb.w	r0, [r0, #161]	; 0xa1
}
90001d6e:	4770      	bx	lr

90001d70 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
90001d70:	4b19      	ldr	r3, [pc, #100]	; (90001dd8 <HAL_PWREx_EnableOverDrive+0x68>)
{
90001d72:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
90001d74:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
90001d76:	4c19      	ldr	r4, [pc, #100]	; (90001ddc <HAL_PWREx_EnableOverDrive+0x6c>)
  __HAL_RCC_PWR_CLK_ENABLE();
90001d78:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
90001d7c:	641a      	str	r2, [r3, #64]	; 0x40
90001d7e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90001d80:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90001d84:	9301      	str	r3, [sp, #4]
90001d86:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
90001d88:	6823      	ldr	r3, [r4, #0]
90001d8a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90001d8e:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
90001d90:	f7ff faf2 	bl	90001378 <HAL_GetTick>
90001d94:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
90001d96:	6863      	ldr	r3, [r4, #4]
90001d98:	03da      	lsls	r2, r3, #15
90001d9a:	d50c      	bpl.n	90001db6 <HAL_PWREx_EnableOverDrive+0x46>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
90001d9c:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
90001d9e:	4d0f      	ldr	r5, [pc, #60]	; (90001ddc <HAL_PWREx_EnableOverDrive+0x6c>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
90001da0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90001da4:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
90001da6:	f7ff fae7 	bl	90001378 <HAL_GetTick>
90001daa:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
90001dac:	686b      	ldr	r3, [r5, #4]
90001dae:	039b      	lsls	r3, r3, #14
90001db0:	d50a      	bpl.n	90001dc8 <HAL_PWREx_EnableOverDrive+0x58>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
90001db2:	2000      	movs	r0, #0
90001db4:	e006      	b.n	90001dc4 <HAL_PWREx_EnableOverDrive+0x54>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
90001db6:	f7ff fadf 	bl	90001378 <HAL_GetTick>
90001dba:	1b40      	subs	r0, r0, r5
90001dbc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
90001dc0:	d9e9      	bls.n	90001d96 <HAL_PWREx_EnableOverDrive+0x26>
      return HAL_TIMEOUT;
90001dc2:	2003      	movs	r0, #3
}
90001dc4:	b003      	add	sp, #12
90001dc6:	bd30      	pop	{r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
90001dc8:	f7ff fad6 	bl	90001378 <HAL_GetTick>
90001dcc:	1b00      	subs	r0, r0, r4
90001dce:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
90001dd2:	d9eb      	bls.n	90001dac <HAL_PWREx_EnableOverDrive+0x3c>
90001dd4:	e7f5      	b.n	90001dc2 <HAL_PWREx_EnableOverDrive+0x52>
90001dd6:	bf00      	nop
90001dd8:	40023800 	.word	0x40023800
90001ddc:	40007000 	.word	0x40007000

90001de0 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
90001de0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
90001de4:	4604      	mov	r4, r0
90001de6:	b340      	cbz	r0, 90001e3a <HAL_RCC_OscConfig+0x5a>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
90001de8:	6803      	ldr	r3, [r0, #0]
90001dea:	07d8      	lsls	r0, r3, #31
90001dec:	d410      	bmi.n	90001e10 <HAL_RCC_OscConfig+0x30>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
90001dee:	6823      	ldr	r3, [r4, #0]
90001df0:	0799      	lsls	r1, r3, #30
90001df2:	d464      	bmi.n	90001ebe <HAL_RCC_OscConfig+0xde>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
90001df4:	6823      	ldr	r3, [r4, #0]
90001df6:	0719      	lsls	r1, r3, #28
90001df8:	f100 80aa 	bmi.w	90001f50 <HAL_RCC_OscConfig+0x170>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
90001dfc:	6823      	ldr	r3, [r4, #0]
90001dfe:	075a      	lsls	r2, r3, #29
90001e00:	f100 80cb 	bmi.w	90001f9a <HAL_RCC_OscConfig+0x1ba>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
90001e04:	69a2      	ldr	r2, [r4, #24]
90001e06:	2a00      	cmp	r2, #0
90001e08:	f040 8134 	bne.w	90002074 <HAL_RCC_OscConfig+0x294>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
90001e0c:	2000      	movs	r0, #0
90001e0e:	e02b      	b.n	90001e68 <HAL_RCC_OscConfig+0x88>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
90001e10:	4b96      	ldr	r3, [pc, #600]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001e12:	689a      	ldr	r2, [r3, #8]
90001e14:	f002 020c 	and.w	r2, r2, #12
90001e18:	2a04      	cmp	r2, #4
90001e1a:	d007      	beq.n	90001e2c <HAL_RCC_OscConfig+0x4c>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
90001e1c:	689a      	ldr	r2, [r3, #8]
90001e1e:	f002 020c 	and.w	r2, r2, #12
90001e22:	2a08      	cmp	r2, #8
90001e24:	d10b      	bne.n	90001e3e <HAL_RCC_OscConfig+0x5e>
90001e26:	685a      	ldr	r2, [r3, #4]
90001e28:	0252      	lsls	r2, r2, #9
90001e2a:	d508      	bpl.n	90001e3e <HAL_RCC_OscConfig+0x5e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
90001e2c:	4b8f      	ldr	r3, [pc, #572]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001e2e:	681b      	ldr	r3, [r3, #0]
90001e30:	039b      	lsls	r3, r3, #14
90001e32:	d5dc      	bpl.n	90001dee <HAL_RCC_OscConfig+0xe>
90001e34:	6863      	ldr	r3, [r4, #4]
90001e36:	2b00      	cmp	r3, #0
90001e38:	d1d9      	bne.n	90001dee <HAL_RCC_OscConfig+0xe>
        return HAL_ERROR;
90001e3a:	2001      	movs	r0, #1
90001e3c:	e014      	b.n	90001e68 <HAL_RCC_OscConfig+0x88>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
90001e3e:	6862      	ldr	r2, [r4, #4]
90001e40:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
90001e44:	d113      	bne.n	90001e6e <HAL_RCC_OscConfig+0x8e>
90001e46:	681a      	ldr	r2, [r3, #0]
90001e48:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90001e4c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
90001e4e:	f7ff fa93 	bl	90001378 <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
90001e52:	4e86      	ldr	r6, [pc, #536]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
        tickstart = HAL_GetTick();
90001e54:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
90001e56:	6833      	ldr	r3, [r6, #0]
90001e58:	039f      	lsls	r7, r3, #14
90001e5a:	d4c8      	bmi.n	90001dee <HAL_RCC_OscConfig+0xe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
90001e5c:	f7ff fa8c 	bl	90001378 <HAL_GetTick>
90001e60:	1b40      	subs	r0, r0, r5
90001e62:	2864      	cmp	r0, #100	; 0x64
90001e64:	d9f7      	bls.n	90001e56 <HAL_RCC_OscConfig+0x76>
            return HAL_TIMEOUT;
90001e66:	2003      	movs	r0, #3
}
90001e68:	b002      	add	sp, #8
90001e6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
90001e6e:	4d7f      	ldr	r5, [pc, #508]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001e70:	682b      	ldr	r3, [r5, #0]
90001e72:	b992      	cbnz	r2, 90001e9a <HAL_RCC_OscConfig+0xba>
90001e74:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
90001e78:	602b      	str	r3, [r5, #0]
90001e7a:	682b      	ldr	r3, [r5, #0]
90001e7c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
90001e80:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
90001e82:	f7ff fa79 	bl	90001378 <HAL_GetTick>
90001e86:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
90001e88:	682b      	ldr	r3, [r5, #0]
90001e8a:	0398      	lsls	r0, r3, #14
90001e8c:	d5af      	bpl.n	90001dee <HAL_RCC_OscConfig+0xe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
90001e8e:	f7ff fa73 	bl	90001378 <HAL_GetTick>
90001e92:	1b80      	subs	r0, r0, r6
90001e94:	2864      	cmp	r0, #100	; 0x64
90001e96:	d9f7      	bls.n	90001e88 <HAL_RCC_OscConfig+0xa8>
90001e98:	e7e5      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
90001e9a:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
90001e9e:	d107      	bne.n	90001eb0 <HAL_RCC_OscConfig+0xd0>
90001ea0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
90001ea4:	602b      	str	r3, [r5, #0]
90001ea6:	682b      	ldr	r3, [r5, #0]
90001ea8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90001eac:	602b      	str	r3, [r5, #0]
90001eae:	e7ce      	b.n	90001e4e <HAL_RCC_OscConfig+0x6e>
90001eb0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
90001eb4:	602b      	str	r3, [r5, #0]
90001eb6:	682b      	ldr	r3, [r5, #0]
90001eb8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
90001ebc:	e7f6      	b.n	90001eac <HAL_RCC_OscConfig+0xcc>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
90001ebe:	4b6b      	ldr	r3, [pc, #428]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001ec0:	689a      	ldr	r2, [r3, #8]
90001ec2:	f012 0f0c 	tst.w	r2, #12
90001ec6:	d007      	beq.n	90001ed8 <HAL_RCC_OscConfig+0xf8>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
90001ec8:	689a      	ldr	r2, [r3, #8]
90001eca:	f002 020c 	and.w	r2, r2, #12
90001ece:	2a08      	cmp	r2, #8
90001ed0:	d111      	bne.n	90001ef6 <HAL_RCC_OscConfig+0x116>
90001ed2:	685a      	ldr	r2, [r3, #4]
90001ed4:	0251      	lsls	r1, r2, #9
90001ed6:	d40e      	bmi.n	90001ef6 <HAL_RCC_OscConfig+0x116>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
90001ed8:	4b64      	ldr	r3, [pc, #400]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001eda:	681a      	ldr	r2, [r3, #0]
90001edc:	0792      	lsls	r2, r2, #30
90001ede:	d502      	bpl.n	90001ee6 <HAL_RCC_OscConfig+0x106>
90001ee0:	68e2      	ldr	r2, [r4, #12]
90001ee2:	2a01      	cmp	r2, #1
90001ee4:	d1a9      	bne.n	90001e3a <HAL_RCC_OscConfig+0x5a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
90001ee6:	681a      	ldr	r2, [r3, #0]
90001ee8:	6921      	ldr	r1, [r4, #16]
90001eea:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
90001eee:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
90001ef2:	601a      	str	r2, [r3, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
90001ef4:	e77e      	b.n	90001df4 <HAL_RCC_OscConfig+0x14>
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
90001ef6:	68e2      	ldr	r2, [r4, #12]
90001ef8:	b1c2      	cbz	r2, 90001f2c <HAL_RCC_OscConfig+0x14c>
        __HAL_RCC_HSI_ENABLE();
90001efa:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
90001efc:	4d5b      	ldr	r5, [pc, #364]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
        __HAL_RCC_HSI_ENABLE();
90001efe:	f042 0201 	orr.w	r2, r2, #1
90001f02:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
90001f04:	f7ff fa38 	bl	90001378 <HAL_GetTick>
90001f08:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
90001f0a:	682b      	ldr	r3, [r5, #0]
90001f0c:	079f      	lsls	r7, r3, #30
90001f0e:	d507      	bpl.n	90001f20 <HAL_RCC_OscConfig+0x140>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
90001f10:	682b      	ldr	r3, [r5, #0]
90001f12:	6922      	ldr	r2, [r4, #16]
90001f14:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
90001f18:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
90001f1c:	602b      	str	r3, [r5, #0]
90001f1e:	e769      	b.n	90001df4 <HAL_RCC_OscConfig+0x14>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
90001f20:	f7ff fa2a 	bl	90001378 <HAL_GetTick>
90001f24:	1b80      	subs	r0, r0, r6
90001f26:	2802      	cmp	r0, #2
90001f28:	d9ef      	bls.n	90001f0a <HAL_RCC_OscConfig+0x12a>
90001f2a:	e79c      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
        __HAL_RCC_HSI_DISABLE();
90001f2c:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
90001f2e:	4e4f      	ldr	r6, [pc, #316]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
        __HAL_RCC_HSI_DISABLE();
90001f30:	f022 0201 	bic.w	r2, r2, #1
90001f34:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
90001f36:	f7ff fa1f 	bl	90001378 <HAL_GetTick>
90001f3a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
90001f3c:	6833      	ldr	r3, [r6, #0]
90001f3e:	0798      	lsls	r0, r3, #30
90001f40:	f57f af58 	bpl.w	90001df4 <HAL_RCC_OscConfig+0x14>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
90001f44:	f7ff fa18 	bl	90001378 <HAL_GetTick>
90001f48:	1b40      	subs	r0, r0, r5
90001f4a:	2802      	cmp	r0, #2
90001f4c:	d9f6      	bls.n	90001f3c <HAL_RCC_OscConfig+0x15c>
90001f4e:	e78a      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
90001f50:	6963      	ldr	r3, [r4, #20]
90001f52:	4d46      	ldr	r5, [pc, #280]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001f54:	b183      	cbz	r3, 90001f78 <HAL_RCC_OscConfig+0x198>
      __HAL_RCC_LSI_ENABLE();
90001f56:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90001f58:	f043 0301 	orr.w	r3, r3, #1
90001f5c:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
90001f5e:	f7ff fa0b 	bl	90001378 <HAL_GetTick>
90001f62:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
90001f64:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90001f66:	079b      	lsls	r3, r3, #30
90001f68:	f53f af48 	bmi.w	90001dfc <HAL_RCC_OscConfig+0x1c>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
90001f6c:	f7ff fa04 	bl	90001378 <HAL_GetTick>
90001f70:	1b80      	subs	r0, r0, r6
90001f72:	2802      	cmp	r0, #2
90001f74:	d9f6      	bls.n	90001f64 <HAL_RCC_OscConfig+0x184>
90001f76:	e776      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
      __HAL_RCC_LSI_DISABLE();
90001f78:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90001f7a:	f023 0301 	bic.w	r3, r3, #1
90001f7e:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
90001f80:	f7ff f9fa 	bl	90001378 <HAL_GetTick>
90001f84:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
90001f86:	6f6b      	ldr	r3, [r5, #116]	; 0x74
90001f88:	079f      	lsls	r7, r3, #30
90001f8a:	f57f af37 	bpl.w	90001dfc <HAL_RCC_OscConfig+0x1c>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
90001f8e:	f7ff f9f3 	bl	90001378 <HAL_GetTick>
90001f92:	1b80      	subs	r0, r0, r6
90001f94:	2802      	cmp	r0, #2
90001f96:	d9f6      	bls.n	90001f86 <HAL_RCC_OscConfig+0x1a6>
90001f98:	e765      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
90001f9a:	4b34      	ldr	r3, [pc, #208]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001f9c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
90001f9e:	00d0      	lsls	r0, r2, #3
90001fa0:	d427      	bmi.n	90001ff2 <HAL_RCC_OscConfig+0x212>
      __HAL_RCC_PWR_CLK_ENABLE();
90001fa2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
90001fa4:	2701      	movs	r7, #1
      __HAL_RCC_PWR_CLK_ENABLE();
90001fa6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
90001faa:	641a      	str	r2, [r3, #64]	; 0x40
90001fac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90001fae:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90001fb2:	9301      	str	r3, [sp, #4]
90001fb4:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
90001fb6:	4d2e      	ldr	r5, [pc, #184]	; (90002070 <HAL_RCC_OscConfig+0x290>)
90001fb8:	682b      	ldr	r3, [r5, #0]
90001fba:	05d9      	lsls	r1, r3, #23
90001fbc:	d51b      	bpl.n	90001ff6 <HAL_RCC_OscConfig+0x216>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
90001fbe:	68a3      	ldr	r3, [r4, #8]
90001fc0:	4d2a      	ldr	r5, [pc, #168]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001fc2:	2b01      	cmp	r3, #1
90001fc4:	d127      	bne.n	90002016 <HAL_RCC_OscConfig+0x236>
90001fc6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
90001fc8:	f043 0301 	orr.w	r3, r3, #1
90001fcc:	672b      	str	r3, [r5, #112]	; 0x70
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90001fce:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
90001fd2:	f7ff f9d1 	bl	90001378 <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
90001fd6:	4e25      	ldr	r6, [pc, #148]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
      tickstart = HAL_GetTick();
90001fd8:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
90001fda:	6f33      	ldr	r3, [r6, #112]	; 0x70
90001fdc:	079b      	lsls	r3, r3, #30
90001fde:	d53f      	bpl.n	90002060 <HAL_RCC_OscConfig+0x280>
    if (pwrclkchanged == SET)
90001fe0:	2f00      	cmp	r7, #0
90001fe2:	f43f af0f 	beq.w	90001e04 <HAL_RCC_OscConfig+0x24>
      __HAL_RCC_PWR_CLK_DISABLE();
90001fe6:	4a21      	ldr	r2, [pc, #132]	; (9000206c <HAL_RCC_OscConfig+0x28c>)
90001fe8:	6c13      	ldr	r3, [r2, #64]	; 0x40
90001fea:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
90001fee:	6413      	str	r3, [r2, #64]	; 0x40
90001ff0:	e708      	b.n	90001e04 <HAL_RCC_OscConfig+0x24>
  FlagStatus pwrclkchanged = RESET;
90001ff2:	2700      	movs	r7, #0
90001ff4:	e7df      	b.n	90001fb6 <HAL_RCC_OscConfig+0x1d6>
      PWR->CR1 |= PWR_CR1_DBP;
90001ff6:	682b      	ldr	r3, [r5, #0]
90001ff8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90001ffc:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
90001ffe:	f7ff f9bb 	bl	90001378 <HAL_GetTick>
90002002:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
90002004:	682b      	ldr	r3, [r5, #0]
90002006:	05da      	lsls	r2, r3, #23
90002008:	d4d9      	bmi.n	90001fbe <HAL_RCC_OscConfig+0x1de>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
9000200a:	f7ff f9b5 	bl	90001378 <HAL_GetTick>
9000200e:	1b80      	subs	r0, r0, r6
90002010:	2864      	cmp	r0, #100	; 0x64
90002012:	d9f7      	bls.n	90002004 <HAL_RCC_OscConfig+0x224>
90002014:	e727      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
90002016:	b9ab      	cbnz	r3, 90002044 <HAL_RCC_OscConfig+0x264>
90002018:	6f2b      	ldr	r3, [r5, #112]	; 0x70
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
9000201a:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
9000201e:	f023 0301 	bic.w	r3, r3, #1
90002022:	672b      	str	r3, [r5, #112]	; 0x70
90002024:	6f2b      	ldr	r3, [r5, #112]	; 0x70
90002026:	f023 0304 	bic.w	r3, r3, #4
9000202a:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
9000202c:	f7ff f9a4 	bl	90001378 <HAL_GetTick>
90002030:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
90002032:	6f2b      	ldr	r3, [r5, #112]	; 0x70
90002034:	0798      	lsls	r0, r3, #30
90002036:	d5d3      	bpl.n	90001fe0 <HAL_RCC_OscConfig+0x200>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90002038:	f7ff f99e 	bl	90001378 <HAL_GetTick>
9000203c:	1b80      	subs	r0, r0, r6
9000203e:	4540      	cmp	r0, r8
90002040:	d9f7      	bls.n	90002032 <HAL_RCC_OscConfig+0x252>
90002042:	e710      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
90002044:	2b05      	cmp	r3, #5
90002046:	6f2b      	ldr	r3, [r5, #112]	; 0x70
90002048:	d103      	bne.n	90002052 <HAL_RCC_OscConfig+0x272>
9000204a:	f043 0304 	orr.w	r3, r3, #4
9000204e:	672b      	str	r3, [r5, #112]	; 0x70
90002050:	e7b9      	b.n	90001fc6 <HAL_RCC_OscConfig+0x1e6>
90002052:	f023 0301 	bic.w	r3, r3, #1
90002056:	672b      	str	r3, [r5, #112]	; 0x70
90002058:	6f2b      	ldr	r3, [r5, #112]	; 0x70
9000205a:	f023 0304 	bic.w	r3, r3, #4
9000205e:	e7b5      	b.n	90001fcc <HAL_RCC_OscConfig+0x1ec>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90002060:	f7ff f98a 	bl	90001378 <HAL_GetTick>
90002064:	1b40      	subs	r0, r0, r5
90002066:	4540      	cmp	r0, r8
90002068:	d9b7      	bls.n	90001fda <HAL_RCC_OscConfig+0x1fa>
9000206a:	e6fc      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
9000206c:	40023800 	.word	0x40023800
90002070:	40007000 	.word	0x40007000
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
90002074:	4d38      	ldr	r5, [pc, #224]	; (90002158 <HAL_RCC_OscConfig+0x378>)
90002076:	68ab      	ldr	r3, [r5, #8]
90002078:	f003 030c 	and.w	r3, r3, #12
9000207c:	2b08      	cmp	r3, #8
9000207e:	d041      	beq.n	90002104 <HAL_RCC_OscConfig+0x324>
        __HAL_RCC_PLL_DISABLE();
90002080:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
90002082:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
90002084:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
90002088:	602b      	str	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
9000208a:	d12e      	bne.n	900020ea <HAL_RCC_OscConfig+0x30a>
        tickstart = HAL_GetTick();
9000208c:	f7ff f974 	bl	90001378 <HAL_GetTick>
90002090:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
90002092:	682b      	ldr	r3, [r5, #0]
90002094:	0199      	lsls	r1, r3, #6
90002096:	d422      	bmi.n	900020de <HAL_RCC_OscConfig+0x2fe>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
90002098:	6aa3      	ldr	r3, [r4, #40]	; 0x28
9000209a:	085b      	lsrs	r3, r3, #1
9000209c:	1e5a      	subs	r2, r3, #1
9000209e:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
900020a2:	430b      	orrs	r3, r1
900020a4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
900020a8:	6a62      	ldr	r2, [r4, #36]	; 0x24
900020aa:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
900020ae:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
900020b0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
900020b4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
900020b8:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
900020ba:	682b      	ldr	r3, [r5, #0]
900020bc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
900020c0:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
900020c2:	f7ff f959 	bl	90001378 <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
900020c6:	4d24      	ldr	r5, [pc, #144]	; (90002158 <HAL_RCC_OscConfig+0x378>)
        tickstart = HAL_GetTick();
900020c8:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
900020ca:	682b      	ldr	r3, [r5, #0]
900020cc:	019a      	lsls	r2, r3, #6
900020ce:	f53f ae9d 	bmi.w	90001e0c <HAL_RCC_OscConfig+0x2c>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
900020d2:	f7ff f951 	bl	90001378 <HAL_GetTick>
900020d6:	1b00      	subs	r0, r0, r4
900020d8:	2802      	cmp	r0, #2
900020da:	d9f6      	bls.n	900020ca <HAL_RCC_OscConfig+0x2ea>
900020dc:	e6c3      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
900020de:	f7ff f94b 	bl	90001378 <HAL_GetTick>
900020e2:	1b80      	subs	r0, r0, r6
900020e4:	2802      	cmp	r0, #2
900020e6:	d9d4      	bls.n	90002092 <HAL_RCC_OscConfig+0x2b2>
900020e8:	e6bd      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
        tickstart = HAL_GetTick();
900020ea:	f7ff f945 	bl	90001378 <HAL_GetTick>
900020ee:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
900020f0:	682b      	ldr	r3, [r5, #0]
900020f2:	019b      	lsls	r3, r3, #6
900020f4:	f57f ae8a 	bpl.w	90001e0c <HAL_RCC_OscConfig+0x2c>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
900020f8:	f7ff f93e 	bl	90001378 <HAL_GetTick>
900020fc:	1b00      	subs	r0, r0, r4
900020fe:	2802      	cmp	r0, #2
90002100:	d9f6      	bls.n	900020f0 <HAL_RCC_OscConfig+0x310>
90002102:	e6b0      	b.n	90001e66 <HAL_RCC_OscConfig+0x86>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90002104:	2a01      	cmp	r2, #1
      pll_config = RCC->PLLCFGR;
90002106:	686b      	ldr	r3, [r5, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90002108:	f43f ae97 	beq.w	90001e3a <HAL_RCC_OscConfig+0x5a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
9000210c:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90002110:	69e1      	ldr	r1, [r4, #28]
90002112:	428a      	cmp	r2, r1
90002114:	f47f ae91 	bne.w	90001e3a <HAL_RCC_OscConfig+0x5a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
90002118:	f003 023f 	and.w	r2, r3, #63	; 0x3f
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
9000211c:	6a21      	ldr	r1, [r4, #32]
9000211e:	428a      	cmp	r2, r1
90002120:	f47f ae8b 	bne.w	90001e3a <HAL_RCC_OscConfig+0x5a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
90002124:	f647 72c0 	movw	r2, #32704	; 0x7fc0
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
90002128:	6a61      	ldr	r1, [r4, #36]	; 0x24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
9000212a:	401a      	ands	r2, r3
9000212c:	ebb2 1f81 	cmp.w	r2, r1, lsl #6
90002130:	f47f ae83 	bne.w	90001e3a <HAL_RCC_OscConfig+0x5a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
90002134:	6aa2      	ldr	r2, [r4, #40]	; 0x28
90002136:	f403 3140 	and.w	r1, r3, #196608	; 0x30000
9000213a:	0852      	lsrs	r2, r2, #1
9000213c:	3a01      	subs	r2, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
9000213e:	ebb1 4f02 	cmp.w	r1, r2, lsl #16
90002142:	f47f ae7a 	bne.w	90001e3a <HAL_RCC_OscConfig+0x5a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
90002146:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
9000214a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
9000214c:	ebb3 6f02 	cmp.w	r3, r2, lsl #24
90002150:	f43f ae5c 	beq.w	90001e0c <HAL_RCC_OscConfig+0x2c>
90002154:	e671      	b.n	90001e3a <HAL_RCC_OscConfig+0x5a>
90002156:	bf00      	nop
90002158:	40023800 	.word	0x40023800

9000215c <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
9000215c:	4913      	ldr	r1, [pc, #76]	; (900021ac <HAL_RCC_GetSysClockFreq+0x50>)
{
9000215e:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
90002160:	688b      	ldr	r3, [r1, #8]
90002162:	f003 030c 	and.w	r3, r3, #12
90002166:	2b04      	cmp	r3, #4
90002168:	d01b      	beq.n	900021a2 <HAL_RCC_GetSysClockFreq+0x46>
9000216a:	2b08      	cmp	r3, #8
9000216c:	d11b      	bne.n	900021a6 <HAL_RCC_GetSysClockFreq+0x4a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
9000216e:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
90002170:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
90002172:	6849      	ldr	r1, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
90002174:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
90002178:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
9000217c:	f3c1 1188 	ubfx	r1, r1, #6, #9
90002180:	bf1a      	itte	ne
90002182:	480b      	ldrne	r0, [pc, #44]	; (900021b0 <HAL_RCC_GetSysClockFreq+0x54>)
90002184:	2300      	movne	r3, #0
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
90002186:	480b      	ldreq	r0, [pc, #44]	; (900021b4 <HAL_RCC_GetSysClockFreq+0x58>)
90002188:	fba1 0100 	umull	r0, r1, r1, r0
9000218c:	f7fe f83c 	bl	90000208 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
90002190:	4b06      	ldr	r3, [pc, #24]	; (900021ac <HAL_RCC_GetSysClockFreq+0x50>)
90002192:	685b      	ldr	r3, [r3, #4]
90002194:	f3c3 4301 	ubfx	r3, r3, #16, #2
90002198:	3301      	adds	r3, #1
9000219a:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
9000219c:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
900021a0:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
900021a2:	4803      	ldr	r0, [pc, #12]	; (900021b0 <HAL_RCC_GetSysClockFreq+0x54>)
900021a4:	e7fc      	b.n	900021a0 <HAL_RCC_GetSysClockFreq+0x44>
      sysclockfreq = HSI_VALUE;
900021a6:	4803      	ldr	r0, [pc, #12]	; (900021b4 <HAL_RCC_GetSysClockFreq+0x58>)
  return sysclockfreq;
900021a8:	e7fa      	b.n	900021a0 <HAL_RCC_GetSysClockFreq+0x44>
900021aa:	bf00      	nop
900021ac:	40023800 	.word	0x40023800
900021b0:	017d7840 	.word	0x017d7840
900021b4:	00f42400 	.word	0x00f42400

900021b8 <HAL_RCC_ClockConfig>:
{
900021b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900021bc:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
900021be:	4604      	mov	r4, r0
900021c0:	b910      	cbnz	r0, 900021c8 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
900021c2:	2001      	movs	r0, #1
}
900021c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
900021c8:	4a46      	ldr	r2, [pc, #280]	; (900022e4 <HAL_RCC_ClockConfig+0x12c>)
900021ca:	6813      	ldr	r3, [r2, #0]
900021cc:	f003 030f 	and.w	r3, r3, #15
900021d0:	428b      	cmp	r3, r1
900021d2:	d328      	bcc.n	90002226 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
900021d4:	6822      	ldr	r2, [r4, #0]
900021d6:	0797      	lsls	r7, r2, #30
900021d8:	d430      	bmi.n	9000223c <HAL_RCC_ClockConfig+0x84>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
900021da:	07d0      	lsls	r0, r2, #31
900021dc:	d444      	bmi.n	90002268 <HAL_RCC_ClockConfig+0xb0>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
900021de:	4a41      	ldr	r2, [pc, #260]	; (900022e4 <HAL_RCC_ClockConfig+0x12c>)
900021e0:	6813      	ldr	r3, [r2, #0]
900021e2:	f003 030f 	and.w	r3, r3, #15
900021e6:	42ab      	cmp	r3, r5
900021e8:	d867      	bhi.n	900022ba <HAL_RCC_ClockConfig+0x102>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
900021ea:	6822      	ldr	r2, [r4, #0]
900021ec:	0751      	lsls	r1, r2, #29
900021ee:	d470      	bmi.n	900022d2 <HAL_RCC_ClockConfig+0x11a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
900021f0:	0713      	lsls	r3, r2, #28
900021f2:	d507      	bpl.n	90002204 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
900021f4:	4a3c      	ldr	r2, [pc, #240]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
900021f6:	6921      	ldr	r1, [r4, #16]
900021f8:	6893      	ldr	r3, [r2, #8]
900021fa:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
900021fe:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
90002202:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
90002204:	f7ff ffaa 	bl	9000215c <HAL_RCC_GetSysClockFreq>
90002208:	4b37      	ldr	r3, [pc, #220]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
9000220a:	4a38      	ldr	r2, [pc, #224]	; (900022ec <HAL_RCC_ClockConfig+0x134>)
9000220c:	689b      	ldr	r3, [r3, #8]
9000220e:	f3c3 1303 	ubfx	r3, r3, #4, #4
90002212:	5cd3      	ldrb	r3, [r2, r3]
90002214:	40d8      	lsrs	r0, r3
90002216:	4b36      	ldr	r3, [pc, #216]	; (900022f0 <HAL_RCC_ClockConfig+0x138>)
90002218:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
9000221a:	4b36      	ldr	r3, [pc, #216]	; (900022f4 <HAL_RCC_ClockConfig+0x13c>)
9000221c:	6818      	ldr	r0, [r3, #0]
9000221e:	f7ff f86b 	bl	900012f8 <HAL_InitTick>
  return HAL_OK;
90002222:	2000      	movs	r0, #0
90002224:	e7ce      	b.n	900021c4 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
90002226:	6813      	ldr	r3, [r2, #0]
90002228:	f023 030f 	bic.w	r3, r3, #15
9000222c:	430b      	orrs	r3, r1
9000222e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
90002230:	6813      	ldr	r3, [r2, #0]
90002232:	f003 030f 	and.w	r3, r3, #15
90002236:	428b      	cmp	r3, r1
90002238:	d1c3      	bne.n	900021c2 <HAL_RCC_ClockConfig+0xa>
9000223a:	e7cb      	b.n	900021d4 <HAL_RCC_ClockConfig+0x1c>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
9000223c:	f012 0f04 	tst.w	r2, #4
90002240:	4b29      	ldr	r3, [pc, #164]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
90002242:	d003      	beq.n	9000224c <HAL_RCC_ClockConfig+0x94>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
90002244:	6899      	ldr	r1, [r3, #8]
90002246:	f441 51e0 	orr.w	r1, r1, #7168	; 0x1c00
9000224a:	6099      	str	r1, [r3, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
9000224c:	0716      	lsls	r6, r2, #28
9000224e:	d503      	bpl.n	90002258 <HAL_RCC_ClockConfig+0xa0>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
90002250:	6899      	ldr	r1, [r3, #8]
90002252:	f441 4160 	orr.w	r1, r1, #57344	; 0xe000
90002256:	6099      	str	r1, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
90002258:	4923      	ldr	r1, [pc, #140]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
9000225a:	68a0      	ldr	r0, [r4, #8]
9000225c:	688b      	ldr	r3, [r1, #8]
9000225e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
90002262:	4303      	orrs	r3, r0
90002264:	608b      	str	r3, [r1, #8]
90002266:	e7b8      	b.n	900021da <HAL_RCC_ClockConfig+0x22>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
90002268:	6861      	ldr	r1, [r4, #4]
9000226a:	4b1f      	ldr	r3, [pc, #124]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
9000226c:	2901      	cmp	r1, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
9000226e:	681a      	ldr	r2, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
90002270:	d11b      	bne.n	900022aa <HAL_RCC_ClockConfig+0xf2>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
90002272:	f412 3f00 	tst.w	r2, #131072	; 0x20000
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
90002276:	d0a4      	beq.n	900021c2 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
90002278:	689a      	ldr	r2, [r3, #8]
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
9000227a:	f241 3888 	movw	r8, #5000	; 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
9000227e:	4f1a      	ldr	r7, [pc, #104]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
90002280:	f022 0203 	bic.w	r2, r2, #3
90002284:	430a      	orrs	r2, r1
90002286:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
90002288:	f7ff f876 	bl	90001378 <HAL_GetTick>
9000228c:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
9000228e:	68bb      	ldr	r3, [r7, #8]
90002290:	6862      	ldr	r2, [r4, #4]
90002292:	f003 030c 	and.w	r3, r3, #12
90002296:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
9000229a:	d0a0      	beq.n	900021de <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
9000229c:	f7ff f86c 	bl	90001378 <HAL_GetTick>
900022a0:	1b80      	subs	r0, r0, r6
900022a2:	4540      	cmp	r0, r8
900022a4:	d9f3      	bls.n	9000228e <HAL_RCC_ClockConfig+0xd6>
        return HAL_TIMEOUT;
900022a6:	2003      	movs	r0, #3
900022a8:	e78c      	b.n	900021c4 <HAL_RCC_ClockConfig+0xc>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
900022aa:	2902      	cmp	r1, #2
900022ac:	d102      	bne.n	900022b4 <HAL_RCC_ClockConfig+0xfc>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
900022ae:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
900022b2:	e7e0      	b.n	90002276 <HAL_RCC_ClockConfig+0xbe>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
900022b4:	f012 0f02 	tst.w	r2, #2
900022b8:	e7dd      	b.n	90002276 <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
900022ba:	6813      	ldr	r3, [r2, #0]
900022bc:	f023 030f 	bic.w	r3, r3, #15
900022c0:	432b      	orrs	r3, r5
900022c2:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
900022c4:	6813      	ldr	r3, [r2, #0]
900022c6:	f003 030f 	and.w	r3, r3, #15
900022ca:	42ab      	cmp	r3, r5
900022cc:	f47f af79 	bne.w	900021c2 <HAL_RCC_ClockConfig+0xa>
900022d0:	e78b      	b.n	900021ea <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
900022d2:	4905      	ldr	r1, [pc, #20]	; (900022e8 <HAL_RCC_ClockConfig+0x130>)
900022d4:	68e0      	ldr	r0, [r4, #12]
900022d6:	688b      	ldr	r3, [r1, #8]
900022d8:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
900022dc:	4303      	orrs	r3, r0
900022de:	608b      	str	r3, [r1, #8]
900022e0:	e786      	b.n	900021f0 <HAL_RCC_ClockConfig+0x38>
900022e2:	bf00      	nop
900022e4:	40023c00 	.word	0x40023c00
900022e8:	40023800 	.word	0x40023800
900022ec:	900092ec 	.word	0x900092ec
900022f0:	2000002c 	.word	0x2000002c
900022f4:	20000034 	.word	0x20000034

900022f8 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
900022f8:	6803      	ldr	r3, [r0, #0]
{
900022fa:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
900022fe:	f013 0601 	ands.w	r6, r3, #1
{
90002302:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
90002304:	d00b      	beq.n	9000231e <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
90002306:	4aaa      	ldr	r2, [pc, #680]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002308:	6891      	ldr	r1, [r2, #8]
9000230a:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
9000230e:	6091      	str	r1, [r2, #8]
90002310:	6b46      	ldr	r6, [r0, #52]	; 0x34
90002312:	6891      	ldr	r1, [r2, #8]
90002314:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
90002316:	fab6 f686 	clz	r6, r6
9000231a:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
9000231c:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
9000231e:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
90002322:	d012      	beq.n	9000234a <HAL_RCCEx_PeriphCLKConfig+0x52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
90002324:	49a2      	ldr	r1, [pc, #648]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002326:	6be5      	ldr	r5, [r4, #60]	; 0x3c
90002328:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
9000232c:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
90002330:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
    {
      plli2sused = 1;
90002334:	bf08      	it	eq
90002336:	2601      	moveq	r6, #1
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
90002338:	ea42 0205 	orr.w	r2, r2, r5
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
9000233c:	bf16      	itet	ne
9000233e:	fab5 f585 	clzne	r5, r5
  uint32_t pllsaiused = 0;
90002342:	2500      	moveq	r5, #0
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
90002344:	096d      	lsrne	r5, r5, #5
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
90002346:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
9000234a:	02df      	lsls	r7, r3, #11
9000234c:	d510      	bpl.n	90002370 <HAL_RCCEx_PeriphCLKConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
9000234e:	4898      	ldr	r0, [pc, #608]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002350:	6c21      	ldr	r1, [r4, #64]	; 0x40
90002352:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
90002356:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
9000235a:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
9000235e:	ea42 0201 	orr.w	r2, r2, r1
90002362:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
90002366:	f000 8184 	beq.w	90002672 <HAL_RCCEx_PeriphCLKConfig+0x37a>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
9000236a:	2900      	cmp	r1, #0
9000236c:	bf08      	it	eq
9000236e:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
90002370:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
90002374:	bf18      	it	ne
90002376:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
90002378:	0698      	lsls	r0, r3, #26
9000237a:	d531      	bpl.n	900023e0 <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
9000237c:	4b8c      	ldr	r3, [pc, #560]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
9000237e:	4f8d      	ldr	r7, [pc, #564]	; (900025b4 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
    __HAL_RCC_PWR_CLK_ENABLE();
90002380:	6c1a      	ldr	r2, [r3, #64]	; 0x40
90002382:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
90002386:	641a      	str	r2, [r3, #64]	; 0x40
90002388:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000238a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
9000238e:	9301      	str	r3, [sp, #4]
90002390:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
90002392:	683b      	ldr	r3, [r7, #0]
90002394:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90002398:	603b      	str	r3, [r7, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
9000239a:	f7fe ffed 	bl	90001378 <HAL_GetTick>
9000239e:	4680      	mov	r8, r0

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
900023a0:	683b      	ldr	r3, [r7, #0]
900023a2:	05d9      	lsls	r1, r3, #23
900023a4:	f140 8167 	bpl.w	90002676 <HAL_RCCEx_PeriphCLKConfig+0x37e>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
900023a8:	4f81      	ldr	r7, [pc, #516]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900023aa:	6f3b      	ldr	r3, [r7, #112]	; 0x70

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
900023ac:	f413 7340 	ands.w	r3, r3, #768	; 0x300
900023b0:	f040 816c 	bne.w	9000268c <HAL_RCCEx_PeriphCLKConfig+0x394>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
900023b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
900023b6:	f403 7240 	and.w	r2, r3, #768	; 0x300
900023ba:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
900023be:	4a7c      	ldr	r2, [pc, #496]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900023c0:	f040 818a 	bne.w	900026d8 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
900023c4:	6891      	ldr	r1, [r2, #8]
900023c6:	f023 4070 	bic.w	r0, r3, #4026531840	; 0xf0000000
900023ca:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
900023ce:	f420 7040 	bic.w	r0, r0, #768	; 0x300
900023d2:	4301      	orrs	r1, r0
900023d4:	6091      	str	r1, [r2, #8]
900023d6:	f3c3 030b 	ubfx	r3, r3, #0, #12
900023da:	6f11      	ldr	r1, [r2, #112]	; 0x70
900023dc:	430b      	orrs	r3, r1
900023de:	6713      	str	r3, [r2, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
900023e0:	6823      	ldr	r3, [r4, #0]
900023e2:	06d8      	lsls	r0, r3, #27
900023e4:	d50c      	bpl.n	90002400 <HAL_RCCEx_PeriphCLKConfig+0x108>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
900023e6:	4a72      	ldr	r2, [pc, #456]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900023e8:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
900023ec:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
900023f0:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
900023f4:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
900023f8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
900023fa:	4301      	orrs	r1, r0
900023fc:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
90002400:	0459      	lsls	r1, r3, #17
90002402:	d508      	bpl.n	90002416 <HAL_RCCEx_PeriphCLKConfig+0x11e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
90002404:	496a      	ldr	r1, [pc, #424]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002406:	6e60      	ldr	r0, [r4, #100]	; 0x64
90002408:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
9000240c:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
90002410:	4302      	orrs	r2, r0
90002412:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
90002416:	041a      	lsls	r2, r3, #16
90002418:	d508      	bpl.n	9000242c <HAL_RCCEx_PeriphCLKConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
9000241a:	4965      	ldr	r1, [pc, #404]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
9000241c:	6ea0      	ldr	r0, [r4, #104]	; 0x68
9000241e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002422:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
90002426:	4302      	orrs	r2, r0
90002428:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
9000242c:	03df      	lsls	r7, r3, #15
9000242e:	d508      	bpl.n	90002442 <HAL_RCCEx_PeriphCLKConfig+0x14a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
90002430:	495f      	ldr	r1, [pc, #380]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002432:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
90002434:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002438:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
9000243c:	4302      	orrs	r2, r0
9000243e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
90002442:	0398      	lsls	r0, r3, #14
90002444:	d508      	bpl.n	90002458 <HAL_RCCEx_PeriphCLKConfig+0x160>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
90002446:	495a      	ldr	r1, [pc, #360]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002448:	6f20      	ldr	r0, [r4, #112]	; 0x70
9000244a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
9000244e:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
90002452:	4302      	orrs	r2, r0
90002454:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
90002458:	0659      	lsls	r1, r3, #25
9000245a:	d508      	bpl.n	9000246e <HAL_RCCEx_PeriphCLKConfig+0x176>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
9000245c:	4954      	ldr	r1, [pc, #336]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
9000245e:	6c60      	ldr	r0, [r4, #68]	; 0x44
90002460:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002464:	f022 0203 	bic.w	r2, r2, #3
90002468:	4302      	orrs	r2, r0
9000246a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
9000246e:	061a      	lsls	r2, r3, #24
90002470:	d508      	bpl.n	90002484 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
90002472:	494f      	ldr	r1, [pc, #316]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002474:	6ca0      	ldr	r0, [r4, #72]	; 0x48
90002476:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
9000247a:	f022 020c 	bic.w	r2, r2, #12
9000247e:	4302      	orrs	r2, r0
90002480:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
90002484:	05df      	lsls	r7, r3, #23
90002486:	d508      	bpl.n	9000249a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
90002488:	4949      	ldr	r1, [pc, #292]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
9000248a:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
9000248c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002490:	f022 0230 	bic.w	r2, r2, #48	; 0x30
90002494:	4302      	orrs	r2, r0
90002496:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
9000249a:	0598      	lsls	r0, r3, #22
9000249c:	d508      	bpl.n	900024b0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
9000249e:	4944      	ldr	r1, [pc, #272]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900024a0:	6d20      	ldr	r0, [r4, #80]	; 0x50
900024a2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
900024a6:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
900024aa:	4302      	orrs	r2, r0
900024ac:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
900024b0:	0559      	lsls	r1, r3, #21
900024b2:	d508      	bpl.n	900024c6 <HAL_RCCEx_PeriphCLKConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
900024b4:	493e      	ldr	r1, [pc, #248]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900024b6:	6d60      	ldr	r0, [r4, #84]	; 0x54
900024b8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
900024bc:	f422 7240 	bic.w	r2, r2, #768	; 0x300
900024c0:	4302      	orrs	r2, r0
900024c2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
900024c6:	051a      	lsls	r2, r3, #20
900024c8:	d508      	bpl.n	900024dc <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
900024ca:	4939      	ldr	r1, [pc, #228]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900024cc:	6da0      	ldr	r0, [r4, #88]	; 0x58
900024ce:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
900024d2:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
900024d6:	4302      	orrs	r2, r0
900024d8:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
900024dc:	04df      	lsls	r7, r3, #19
900024de:	d508      	bpl.n	900024f2 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
900024e0:	4933      	ldr	r1, [pc, #204]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900024e2:	6de0      	ldr	r0, [r4, #92]	; 0x5c
900024e4:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
900024e8:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
900024ec:	4302      	orrs	r2, r0
900024ee:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
900024f2:	0498      	lsls	r0, r3, #18
900024f4:	d508      	bpl.n	90002508 <HAL_RCCEx_PeriphCLKConfig+0x210>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
900024f6:	492e      	ldr	r1, [pc, #184]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
900024f8:	6e20      	ldr	r0, [r4, #96]	; 0x60
900024fa:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
900024fe:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
90002502:	4302      	orrs	r2, r0
90002504:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
90002508:	0259      	lsls	r1, r3, #9
9000250a:	d508      	bpl.n	9000251e <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
9000250c:	4928      	ldr	r1, [pc, #160]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
9000250e:	6fa0      	ldr	r0, [r4, #120]	; 0x78
90002510:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002514:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
90002518:	4302      	orrs	r2, r0
9000251a:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
9000251e:	029a      	lsls	r2, r3, #10
90002520:	d50c      	bpl.n	9000253c <HAL_RCCEx_PeriphCLKConfig+0x244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
90002522:	4823      	ldr	r0, [pc, #140]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002524:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
90002526:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
9000252a:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
9000252e:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1;
90002532:	bf08      	it	eq
90002534:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
90002536:	430a      	orrs	r2, r1
90002538:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
9000253c:	f013 0f08 	tst.w	r3, #8
90002540:	bf18      	it	ne
90002542:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
90002544:	035f      	lsls	r7, r3, #13
90002546:	d508      	bpl.n	9000255a <HAL_RCCEx_PeriphCLKConfig+0x262>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
90002548:	4919      	ldr	r1, [pc, #100]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
9000254a:	6f60      	ldr	r0, [r4, #116]	; 0x74
9000254c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002550:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
90002554:	4302      	orrs	r2, r0
90002556:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
9000255a:	0218      	lsls	r0, r3, #8
9000255c:	d509      	bpl.n	90002572 <HAL_RCCEx_PeriphCLKConfig+0x27a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
9000255e:	4914      	ldr	r1, [pc, #80]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002560:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
90002564:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
90002568:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
9000256c:	4302      	orrs	r2, r0
9000256e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
90002572:	2e01      	cmp	r6, #1
90002574:	f000 80b4 	beq.w	900026e0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
90002578:	0199      	lsls	r1, r3, #6
9000257a:	f100 80b1 	bmi.w	900026e0 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
9000257e:	2d01      	cmp	r5, #1
90002580:	d175      	bne.n	9000266e <HAL_RCCEx_PeriphCLKConfig+0x376>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
90002582:	4d0b      	ldr	r5, [pc, #44]	; (900025b0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
90002584:	682b      	ldr	r3, [r5, #0]
90002586:	462e      	mov	r6, r5
90002588:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
9000258c:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
9000258e:	f7fe fef3 	bl	90001378 <HAL_GetTick>
90002592:	4607      	mov	r7, r0

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
90002594:	682b      	ldr	r3, [r5, #0]
90002596:	009b      	lsls	r3, r3, #2
90002598:	f100 8126 	bmi.w	900027e8 <HAL_RCCEx_PeriphCLKConfig+0x4f0>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
9000259c:	6822      	ldr	r2, [r4, #0]
9000259e:	0315      	lsls	r5, r2, #12
900025a0:	d501      	bpl.n	900025a6 <HAL_RCCEx_PeriphCLKConfig+0x2ae>
900025a2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
900025a4:	b143      	cbz	r3, 900025b8 <HAL_RCCEx_PeriphCLKConfig+0x2c0>
900025a6:	02d0      	lsls	r0, r2, #11
900025a8:	d521      	bpl.n	900025ee <HAL_RCCEx_PeriphCLKConfig+0x2f6>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
900025aa:	6c23      	ldr	r3, [r4, #64]	; 0x40
900025ac:	b9fb      	cbnz	r3, 900025ee <HAL_RCCEx_PeriphCLKConfig+0x2f6>
900025ae:	e003      	b.n	900025b8 <HAL_RCCEx_PeriphCLKConfig+0x2c0>
900025b0:	40023800 	.word	0x40023800
900025b4:	40007000 	.word	0x40007000
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
900025b8:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
900025bc:	f8d6 1088 	ldr.w	r1, [r6, #136]	; 0x88
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
900025c0:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
900025c4:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
900025c8:	430b      	orrs	r3, r1
900025ca:	6961      	ldr	r1, [r4, #20]
900025cc:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
900025d0:	69a1      	ldr	r1, [r4, #24]
900025d2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
900025d6:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
900025da:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
900025de:	6aa1      	ldr	r1, [r4, #40]	; 0x28
900025e0:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
900025e4:	3901      	subs	r1, #1
900025e6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
900025ea:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
900025ee:	0291      	lsls	r1, r2, #10
900025f0:	d515      	bpl.n	9000261e <HAL_RCCEx_PeriphCLKConfig+0x326>
900025f2:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
900025f4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
900025f8:	d111      	bne.n	9000261e <HAL_RCCEx_PeriphCLKConfig+0x326>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
900025fa:	4982      	ldr	r1, [pc, #520]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
900025fc:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
90002600:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
90002604:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
90002608:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
9000260c:	4303      	orrs	r3, r0
9000260e:	6960      	ldr	r0, [r4, #20]
90002610:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
90002614:	6a20      	ldr	r0, [r4, #32]
90002616:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
9000261a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
9000261e:	0712      	lsls	r2, r2, #28
90002620:	d519      	bpl.n	90002656 <HAL_RCCEx_PeriphCLKConfig+0x35e>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
90002622:	4a78      	ldr	r2, [pc, #480]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
90002624:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
90002628:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
9000262c:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
90002630:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
90002634:	430b      	orrs	r3, r1
90002636:	6961      	ldr	r1, [r4, #20]
90002638:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
9000263c:	69e1      	ldr	r1, [r4, #28]
9000263e:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
90002642:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
90002646:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
9000264a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
9000264c:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
90002650:	430b      	orrs	r3, r1
90002652:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
90002656:	4c6b      	ldr	r4, [pc, #428]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
90002658:	6823      	ldr	r3, [r4, #0]
9000265a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
9000265e:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90002660:	f7fe fe8a 	bl	90001378 <HAL_GetTick>
90002664:	4605      	mov	r5, r0

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
90002666:	6823      	ldr	r3, [r4, #0]
90002668:	009b      	lsls	r3, r3, #2
9000266a:	f140 80c4 	bpl.w	900027f6 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
9000266e:	2000      	movs	r0, #0
90002670:	e009      	b.n	90002686 <HAL_RCCEx_PeriphCLKConfig+0x38e>
      plli2sused = 1;
90002672:	2601      	movs	r6, #1
90002674:	e67c      	b.n	90002370 <HAL_RCCEx_PeriphCLKConfig+0x78>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
90002676:	f7fe fe7f 	bl	90001378 <HAL_GetTick>
9000267a:	eba0 0008 	sub.w	r0, r0, r8
9000267e:	2864      	cmp	r0, #100	; 0x64
90002680:	f67f ae8e 	bls.w	900023a0 <HAL_RCCEx_PeriphCLKConfig+0xa8>
        return HAL_TIMEOUT;
90002684:	2003      	movs	r0, #3
}
90002686:	b003      	add	sp, #12
90002688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
9000268c:	6b22      	ldr	r2, [r4, #48]	; 0x30
9000268e:	f402 7240 	and.w	r2, r2, #768	; 0x300
90002692:	4293      	cmp	r3, r2
90002694:	f43f ae8e 	beq.w	900023b4 <HAL_RCCEx_PeriphCLKConfig+0xbc>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
90002698:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
9000269a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
9000269c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
900026a0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900026a4:	673a      	str	r2, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
900026a6:	6f3a      	ldr	r2, [r7, #112]	; 0x70
900026a8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
900026ac:	673a      	str	r2, [r7, #112]	; 0x70
      RCC->BDCR = tmpreg0;
900026ae:	673b      	str	r3, [r7, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
900026b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
900026b2:	07da      	lsls	r2, r3, #31
900026b4:	f57f ae7e 	bpl.w	900023b4 <HAL_RCCEx_PeriphCLKConfig+0xbc>
        tickstart = HAL_GetTick();
900026b8:	f7fe fe5e 	bl	90001378 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900026bc:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
900026c0:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
900026c2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
900026c4:	079b      	lsls	r3, r3, #30
900026c6:	f53f ae75 	bmi.w	900023b4 <HAL_RCCEx_PeriphCLKConfig+0xbc>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900026ca:	f7fe fe55 	bl	90001378 <HAL_GetTick>
900026ce:	eba0 0008 	sub.w	r0, r0, r8
900026d2:	4548      	cmp	r0, r9
900026d4:	d9f5      	bls.n	900026c2 <HAL_RCCEx_PeriphCLKConfig+0x3ca>
900026d6:	e7d5      	b.n	90002684 <HAL_RCCEx_PeriphCLKConfig+0x38c>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
900026d8:	6891      	ldr	r1, [r2, #8]
900026da:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
900026de:	e679      	b.n	900023d4 <HAL_RCCEx_PeriphCLKConfig+0xdc>
    __HAL_RCC_PLLI2S_DISABLE();
900026e0:	4e48      	ldr	r6, [pc, #288]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
900026e2:	6833      	ldr	r3, [r6, #0]
900026e4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
900026e8:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
900026ea:	f7fe fe45 	bl	90001378 <HAL_GetTick>
900026ee:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
900026f0:	6833      	ldr	r3, [r6, #0]
900026f2:	011a      	lsls	r2, r3, #4
900026f4:	d472      	bmi.n	900027dc <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
900026f6:	6822      	ldr	r2, [r4, #0]
900026f8:	07d3      	lsls	r3, r2, #31
900026fa:	d512      	bpl.n	90002722 <HAL_RCCEx_PeriphCLKConfig+0x42a>
900026fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
900026fe:	b983      	cbnz	r3, 90002722 <HAL_RCCEx_PeriphCLKConfig+0x42a>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
90002700:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
90002704:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
90002708:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
9000270c:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
90002710:	430b      	orrs	r3, r1
90002712:	6861      	ldr	r1, [r4, #4]
90002714:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
90002718:	68a1      	ldr	r1, [r4, #8]
9000271a:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
9000271e:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
90002722:	0317      	lsls	r7, r2, #12
90002724:	d503      	bpl.n	9000272e <HAL_RCCEx_PeriphCLKConfig+0x436>
90002726:	6be3      	ldr	r3, [r4, #60]	; 0x3c
90002728:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
9000272c:	d005      	beq.n	9000273a <HAL_RCCEx_PeriphCLKConfig+0x442>
9000272e:	02d6      	lsls	r6, r2, #11
90002730:	d51e      	bpl.n	90002770 <HAL_RCCEx_PeriphCLKConfig+0x478>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
90002732:	6c23      	ldr	r3, [r4, #64]	; 0x40
90002734:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90002738:	d11a      	bne.n	90002770 <HAL_RCCEx_PeriphCLKConfig+0x478>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
9000273a:	4932      	ldr	r1, [pc, #200]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
9000273c:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
90002740:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
90002744:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
90002748:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
9000274c:	4303      	orrs	r3, r0
9000274e:	6860      	ldr	r0, [r4, #4]
90002750:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
90002754:	68e0      	ldr	r0, [r4, #12]
90002756:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
9000275a:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
9000275e:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
90002762:	6a63      	ldr	r3, [r4, #36]	; 0x24
90002764:	f020 001f 	bic.w	r0, r0, #31
90002768:	3b01      	subs	r3, #1
9000276a:	4303      	orrs	r3, r0
9000276c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
90002770:	01d0      	lsls	r0, r2, #7
90002772:	d511      	bpl.n	90002798 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
90002774:	4923      	ldr	r1, [pc, #140]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
90002776:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
9000277a:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
9000277e:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
90002782:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
90002786:	4303      	orrs	r3, r0
90002788:	6860      	ldr	r0, [r4, #4]
9000278a:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
9000278e:	6920      	ldr	r0, [r4, #16]
90002790:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
90002794:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
90002798:	0191      	lsls	r1, r2, #6
9000279a:	d50d      	bpl.n	900027b8 <HAL_RCCEx_PeriphCLKConfig+0x4c0>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
9000279c:	6923      	ldr	r3, [r4, #16]
9000279e:	6862      	ldr	r2, [r4, #4]
900027a0:	041b      	lsls	r3, r3, #16
900027a2:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
900027a6:	68e2      	ldr	r2, [r4, #12]
900027a8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
900027ac:	68a2      	ldr	r2, [r4, #8]
900027ae:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
900027b2:	4a14      	ldr	r2, [pc, #80]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
900027b4:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
900027b8:	4e12      	ldr	r6, [pc, #72]	; (90002804 <HAL_RCCEx_PeriphCLKConfig+0x50c>)
900027ba:	6833      	ldr	r3, [r6, #0]
900027bc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
900027c0:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
900027c2:	f7fe fdd9 	bl	90001378 <HAL_GetTick>
900027c6:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
900027c8:	6833      	ldr	r3, [r6, #0]
900027ca:	011a      	lsls	r2, r3, #4
900027cc:	f53f aed7 	bmi.w	9000257e <HAL_RCCEx_PeriphCLKConfig+0x286>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
900027d0:	f7fe fdd2 	bl	90001378 <HAL_GetTick>
900027d4:	1bc0      	subs	r0, r0, r7
900027d6:	2864      	cmp	r0, #100	; 0x64
900027d8:	d9f6      	bls.n	900027c8 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
900027da:	e753      	b.n	90002684 <HAL_RCCEx_PeriphCLKConfig+0x38c>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
900027dc:	f7fe fdcc 	bl	90001378 <HAL_GetTick>
900027e0:	1bc0      	subs	r0, r0, r7
900027e2:	2864      	cmp	r0, #100	; 0x64
900027e4:	d984      	bls.n	900026f0 <HAL_RCCEx_PeriphCLKConfig+0x3f8>
900027e6:	e74d      	b.n	90002684 <HAL_RCCEx_PeriphCLKConfig+0x38c>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
900027e8:	f7fe fdc6 	bl	90001378 <HAL_GetTick>
900027ec:	1bc0      	subs	r0, r0, r7
900027ee:	2864      	cmp	r0, #100	; 0x64
900027f0:	f67f aed0 	bls.w	90002594 <HAL_RCCEx_PeriphCLKConfig+0x29c>
900027f4:	e746      	b.n	90002684 <HAL_RCCEx_PeriphCLKConfig+0x38c>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
900027f6:	f7fe fdbf 	bl	90001378 <HAL_GetTick>
900027fa:	1b40      	subs	r0, r0, r5
900027fc:	2864      	cmp	r0, #100	; 0x64
900027fe:	f67f af32 	bls.w	90002666 <HAL_RCCEx_PeriphCLKConfig+0x36e>
90002802:	e73f      	b.n	90002684 <HAL_RCCEx_PeriphCLKConfig+0x38c>
90002804:	40023800 	.word	0x40023800

90002808 <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
90002808:	b5f0      	push	{r4, r5, r6, r7, lr}
9000280a:	4605      	mov	r5, r0
9000280c:	b089      	sub	sp, #36	; 0x24
9000280e:	460e      	mov	r6, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
90002810:	f7fe fdb2 	bl	90001378 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
90002814:	2300      	movs	r3, #0
  uint32_t tickstart = HAL_GetTick();
90002816:	4607      	mov	r7, r0
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
90002818:	2108      	movs	r1, #8
9000281a:	6828      	ldr	r0, [r5, #0]
  uint32_t tempscr[2U] = {0U, 0U};
9000281c:	e9cd 3300 	strd	r3, r3, [sp]
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
90002820:	f000 febb 	bl	9000359a <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
90002824:	4604      	mov	r4, r0
90002826:	b9d8      	cbnz	r0, 90002860 <SD_FindSCR+0x58>
  {
    return errorstate;
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
90002828:	6d29      	ldr	r1, [r5, #80]	; 0x50
9000282a:	6828      	ldr	r0, [r5, #0]
9000282c:	0409      	lsls	r1, r1, #16
9000282e:	f000 ffc1 	bl	900037b4 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
90002832:	4604      	mov	r4, r0
90002834:	b9a0      	cbnz	r0, 90002860 <SD_FindSCR+0x58>
  {
    return errorstate;
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 8U;
90002836:	f04f 32ff 	mov.w	r2, #4294967295
9000283a:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000283c:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
9000283e:	9006      	str	r0, [sp, #24]
  config.DPSM          = SDMMC_DPSM_ENABLE;
  (void)SDMMC_ConfigData(hsd->Instance, &config);
90002840:	6828      	ldr	r0, [r5, #0]
  config.DataLength    = 8U;
90002842:	e9cd 2302 	strd	r2, r3, [sp, #8]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90002846:	2302      	movs	r3, #2
90002848:	e9cd 1304 	strd	r1, r3, [sp, #16]
  config.DPSM          = SDMMC_DPSM_ENABLE;
9000284c:	2301      	movs	r3, #1
  (void)SDMMC_ConfigData(hsd->Instance, &config);
9000284e:	a902      	add	r1, sp, #8
  config.DPSM          = SDMMC_DPSM_ENABLE;
90002850:	9307      	str	r3, [sp, #28]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
90002852:	f000 fe8f 	bl	90003574 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
90002856:	6828      	ldr	r0, [r5, #0]
90002858:	f000 fff5 	bl	90003846 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
9000285c:	4604      	mov	r4, r0
9000285e:	b190      	cbz	r0, 90002886 <SD_FindSCR+0x7e>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
90002860:	4620      	mov	r0, r4
90002862:	b009      	add	sp, #36	; 0x24
90002864:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL))
90002866:	6b42      	ldr	r2, [r0, #52]	; 0x34
90002868:	0293      	lsls	r3, r2, #10
9000286a:	d512      	bpl.n	90002892 <SD_FindSCR+0x8a>
      *(tempscr + index) = SDMMC_ReadFIFO(hsd->Instance);
9000286c:	f000 fe58 	bl	90003520 <SDMMC_ReadFIFO>
90002870:	ab08      	add	r3, sp, #32
90002872:	eb03 0384 	add.w	r3, r3, r4, lsl #2
      index++;
90002876:	3401      	adds	r4, #1
      *(tempscr + index) = SDMMC_ReadFIFO(hsd->Instance);
90002878:	f843 0c20 	str.w	r0, [r3, #-32]
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
9000287c:	f7fe fd7c 	bl	90001378 <HAL_GetTick>
90002880:	1bc0      	subs	r0, r0, r7
90002882:	3001      	adds	r0, #1
90002884:	d023      	beq.n	900028ce <SD_FindSCR+0xc6>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT))
90002886:	6828      	ldr	r0, [r5, #0]
90002888:	6b42      	ldr	r2, [r0, #52]	; 0x34
9000288a:	f012 0f2a 	tst.w	r2, #42	; 0x2a
9000288e:	d0ea      	beq.n	90002866 <SD_FindSCR+0x5e>
90002890:	e002      	b.n	90002898 <SD_FindSCR+0x90>
    else if(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXACT))
90002892:	6b42      	ldr	r2, [r0, #52]	; 0x34
90002894:	0491      	lsls	r1, r2, #18
90002896:	d4f1      	bmi.n	9000287c <SD_FindSCR+0x74>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
90002898:	6b42      	ldr	r2, [r0, #52]	; 0x34
9000289a:	0712      	lsls	r2, r2, #28
9000289c:	d502      	bpl.n	900028a4 <SD_FindSCR+0x9c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
9000289e:	2408      	movs	r4, #8
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
900028a0:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
900028a2:	e7dd      	b.n	90002860 <SD_FindSCR+0x58>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
900028a4:	6b42      	ldr	r2, [r0, #52]	; 0x34
900028a6:	0793      	lsls	r3, r2, #30
900028a8:	d501      	bpl.n	900028ae <SD_FindSCR+0xa6>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
900028aa:	2402      	movs	r4, #2
900028ac:	e7f8      	b.n	900028a0 <SD_FindSCR+0x98>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
900028ae:	6b44      	ldr	r4, [r0, #52]	; 0x34
900028b0:	f014 0420 	ands.w	r4, r4, #32
900028b4:	d001      	beq.n	900028ba <SD_FindSCR+0xb2>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
900028b6:	2420      	movs	r4, #32
900028b8:	e7f2      	b.n	900028a0 <SD_FindSCR+0x98>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
900028ba:	9b01      	ldr	r3, [sp, #4]
900028bc:	f240 523a 	movw	r2, #1338	; 0x53a
900028c0:	ba1b      	rev	r3, r3
900028c2:	6382      	str	r2, [r0, #56]	; 0x38
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
900028c4:	6033      	str	r3, [r6, #0]
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
900028c6:	9b00      	ldr	r3, [sp, #0]
900028c8:	ba1b      	rev	r3, r3
900028ca:	6073      	str	r3, [r6, #4]
  return HAL_SD_ERROR_NONE;
900028cc:	e7c8      	b.n	90002860 <SD_FindSCR+0x58>
      return HAL_SD_ERROR_TIMEOUT;
900028ce:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
900028d2:	e7c5      	b.n	90002860 <SD_FindSCR+0x58>

900028d4 <HAL_SD_MspInit>:
}
900028d4:	4770      	bx	lr
	...

900028d8 <HAL_SD_ReadBlocks>:
{
900028d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
900028dc:	460d      	mov	r5, r1
900028de:	b087      	sub	sp, #28
900028e0:	4604      	mov	r4, r0
900028e2:	4616      	mov	r6, r2
900028e4:	469a      	mov	sl, r3
  uint32_t tickstart = HAL_GetTick();
900028e6:	f7fe fd47 	bl	90001378 <HAL_GetTick>
900028ea:	4680      	mov	r8, r0
  if(NULL == pData)
900028ec:	b92d      	cbnz	r5, 900028fa <HAL_SD_ReadBlocks+0x22>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
900028ee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
900028f0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    return HAL_ERROR;
900028f4:	2701      	movs	r7, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
900028f6:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
900028f8:	e010      	b.n	9000291c <HAL_SD_ReadBlocks+0x44>
  if(hsd->State == HAL_SD_STATE_READY)
900028fa:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
900028fe:	2b01      	cmp	r3, #1
90002900:	b2df      	uxtb	r7, r3
90002902:	f040 80df 	bne.w	90002ac4 <HAL_SD_ReadBlocks+0x1ec>
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90002906:	eb06 030a 	add.w	r3, r6, sl
9000290a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
9000290c:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
9000290e:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90002910:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90002912:	d907      	bls.n	90002924 <HAL_SD_ReadBlocks+0x4c>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
90002914:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002916:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
9000291a:	63a3      	str	r3, [r4, #56]	; 0x38
}
9000291c:	4638      	mov	r0, r7
9000291e:	b007      	add	sp, #28
90002920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    hsd->State = HAL_SD_STATE_BUSY;
90002924:	2303      	movs	r3, #3
    hsd->Instance->DCTRL = 0U;
90002926:	6820      	ldr	r0, [r4, #0]
    config.DPSM          = SDMMC_DPSM_ENABLE;
90002928:	2200      	movs	r2, #0
9000292a:	f04f 0b01 	mov.w	fp, #1
    hsd->State = HAL_SD_STATE_BUSY;
9000292e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90002932:	f04f 0902 	mov.w	r9, #2
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
90002936:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hsd->Instance->DCTRL = 0U;
90002938:	62c1      	str	r1, [r0, #44]	; 0x2c
    (void)SDMMC_ConfigData(hsd->Instance, &config);
9000293a:	4669      	mov	r1, sp
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
9000293c:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
9000293e:	f04f 33ff 	mov.w	r3, #4294967295
90002942:	9300      	str	r3, [sp, #0]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
90002944:	ea4f 234a 	mov.w	r3, sl, lsl #9
      add *= 512U;
90002948:	bf18      	it	ne
9000294a:	0276      	lslne	r6, r6, #9
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
9000294c:	9301      	str	r3, [sp, #4]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000294e:	2390      	movs	r3, #144	; 0x90
    config.DPSM          = SDMMC_DPSM_ENABLE;
90002950:	e9cd 2b04 	strd	r2, fp, [sp, #16]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90002954:	e9cd 3902 	strd	r3, r9, [sp, #8]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90002958:	f000 fe0c 	bl	90003574 <SDMMC_ConfigData>
    if(NumberOfBlocks > 1U)
9000295c:	45da      	cmp	sl, fp
9000295e:	d912      	bls.n	90002986 <HAL_SD_ReadBlocks+0xae>
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
90002960:	4631      	mov	r1, r6
90002962:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
90002964:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
90002968:	f000 fe47 	bl	900035fa <SDMMC_CmdReadMultiBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
9000296c:	b190      	cbz	r0, 90002994 <HAL_SD_ReadBlocks+0xbc>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
9000296e:	6823      	ldr	r3, [r4, #0]
90002970:	4a56      	ldr	r2, [pc, #344]	; (90002acc <HAL_SD_ReadBlocks+0x1f4>)
90002972:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
90002974:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002976:	4318      	orrs	r0, r3
90002978:	63a0      	str	r0, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
9000297a:	2301      	movs	r3, #1
9000297c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
90002980:	2300      	movs	r3, #0
90002982:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_ERROR;
90002984:	e7ca      	b.n	9000291c <HAL_SD_ReadBlocks+0x44>
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
90002986:	4631      	mov	r1, r6
90002988:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
9000298a:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
9000298e:	f000 fe1c 	bl	900035ca <SDMMC_CmdReadSingleBlock>
90002992:	e7eb      	b.n	9000296c <HAL_SD_ReadBlocks+0x94>
    dataremaining = config.DataLength;
90002994:	9e01      	ldr	r6, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
90002996:	6820      	ldr	r0, [r4, #0]
90002998:	6b43      	ldr	r3, [r0, #52]	; 0x34
9000299a:	f413 7f95 	tst.w	r3, #298	; 0x12a
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining > 0U))
9000299e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
900029a0:	d017      	beq.n	900029d2 <HAL_SD_ReadBlocks+0xfa>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
900029a2:	05db      	lsls	r3, r3, #23
900029a4:	d509      	bpl.n	900029ba <HAL_SD_ReadBlocks+0xe2>
900029a6:	f1ba 0f01 	cmp.w	sl, #1
900029aa:	d906      	bls.n	900029ba <HAL_SD_ReadBlocks+0xe2>
      if(hsd->SdCard.CardType != CARD_SECURED)
900029ac:	6c63      	ldr	r3, [r4, #68]	; 0x44
900029ae:	2b03      	cmp	r3, #3
900029b0:	d003      	beq.n	900029ba <HAL_SD_ReadBlocks+0xe2>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
900029b2:	f000 fe6b 	bl	9000368c <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
900029b6:	2800      	cmp	r0, #0
900029b8:	d1d9      	bne.n	9000296e <HAL_SD_ReadBlocks+0x96>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
900029ba:	6823      	ldr	r3, [r4, #0]
900029bc:	6b59      	ldr	r1, [r3, #52]	; 0x34
900029be:	f011 0108 	ands.w	r1, r1, #8
900029c2:	d036      	beq.n	90002a32 <HAL_SD_ReadBlocks+0x15a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900029c4:	4a41      	ldr	r2, [pc, #260]	; (90002acc <HAL_SD_ReadBlocks+0x1f4>)
900029c6:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
900029c8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
900029ca:	f043 0308 	orr.w	r3, r3, #8
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
900029ce:	63a3      	str	r3, [r4, #56]	; 0x38
900029d0:	e7d3      	b.n	9000297a <HAL_SD_ReadBlocks+0xa2>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining > 0U))
900029d2:	041a      	lsls	r2, r3, #16
900029d4:	d518      	bpl.n	90002a08 <HAL_SD_ReadBlocks+0x130>
900029d6:	b1be      	cbz	r6, 90002a08 <HAL_SD_ReadBlocks+0x130>
900029d8:	f105 0b04 	add.w	fp, r5, #4
900029dc:	f105 0924 	add.w	r9, r5, #36	; 0x24
          data = SDMMC_ReadFIFO(hsd->Instance);
900029e0:	6820      	ldr	r0, [r4, #0]
900029e2:	f10b 0b04 	add.w	fp, fp, #4
900029e6:	f000 fd9b 	bl	90003520 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
900029ea:	f80b 0c08 	strb.w	r0, [fp, #-8]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
900029ee:	0a02      	lsrs	r2, r0, #8
900029f0:	f80b 2c07 	strb.w	r2, [fp, #-7]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
900029f4:	0c02      	lsrs	r2, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
900029f6:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
900029f8:	f80b 2c06 	strb.w	r2, [fp, #-6]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
900029fc:	f80b 0c05 	strb.w	r0, [fp, #-5]
        for(count = 0U; count < 8U; count++)
90002a00:	45d9      	cmp	r9, fp
90002a02:	d1ed      	bne.n	900029e0 <HAL_SD_ReadBlocks+0x108>
90002a04:	3520      	adds	r5, #32
90002a06:	3e20      	subs	r6, #32
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
90002a08:	f7fe fcb6 	bl	90001378 <HAL_GetTick>
90002a0c:	9b10      	ldr	r3, [sp, #64]	; 0x40
90002a0e:	eba0 0008 	sub.w	r0, r0, r8
90002a12:	4298      	cmp	r0, r3
90002a14:	d3bf      	bcc.n	90002996 <HAL_SD_ReadBlocks+0xbe>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002a16:	6823      	ldr	r3, [r4, #0]
        return HAL_TIMEOUT;
90002a18:	2703      	movs	r7, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002a1a:	4a2c      	ldr	r2, [pc, #176]	; (90002acc <HAL_SD_ReadBlocks+0x1f4>)
90002a1c:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
90002a1e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002a20:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
90002a24:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
90002a26:	2301      	movs	r3, #1
90002a28:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
90002a2c:	2300      	movs	r3, #0
90002a2e:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
90002a30:	e774      	b.n	9000291c <HAL_SD_ReadBlocks+0x44>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
90002a32:	6b5a      	ldr	r2, [r3, #52]	; 0x34
90002a34:	f012 0202 	ands.w	r2, r2, #2
90002a38:	d00a      	beq.n	90002a50 <HAL_SD_ReadBlocks+0x178>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002a3a:	4a24      	ldr	r2, [pc, #144]	; (90002acc <HAL_SD_ReadBlocks+0x1f4>)
90002a3c:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
90002a3e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002a40:	f043 0302 	orr.w	r3, r3, #2
90002a44:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
90002a46:	2301      	movs	r3, #1
90002a48:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
90002a4c:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
90002a4e:	e765      	b.n	9000291c <HAL_SD_ReadBlocks+0x44>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
90002a50:	6b59      	ldr	r1, [r3, #52]	; 0x34
90002a52:	0689      	lsls	r1, r1, #26
90002a54:	d527      	bpl.n	90002aa6 <HAL_SD_ReadBlocks+0x1ce>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002a56:	491d      	ldr	r1, [pc, #116]	; (90002acc <HAL_SD_ReadBlocks+0x1f4>)
90002a58:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
90002a5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002a5c:	f043 0320 	orr.w	r3, r3, #32
90002a60:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
90002a62:	2301      	movs	r3, #1
90002a64:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
90002a68:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
90002a6a:	e757      	b.n	9000291c <HAL_SD_ReadBlocks+0x44>
      data = SDMMC_ReadFIFO(hsd->Instance);
90002a6c:	f000 fd58 	bl	90003520 <SDMMC_ReadFIFO>
      *tempbuff = (uint8_t)(data & 0xFFU);
90002a70:	f805 0c04 	strb.w	r0, [r5, #-4]
      *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
90002a74:	0a03      	lsrs	r3, r0, #8
      dataremaining--;
90002a76:	3e04      	subs	r6, #4
90002a78:	3504      	adds	r5, #4
      *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
90002a7a:	f805 3c07 	strb.w	r3, [r5, #-7]
      *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
90002a7e:	0c03      	lsrs	r3, r0, #16
90002a80:	f805 3c06 	strb.w	r3, [r5, #-6]
      *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
90002a84:	0e03      	lsrs	r3, r0, #24
90002a86:	f805 3c05 	strb.w	r3, [r5, #-5]
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
90002a8a:	f7fe fc75 	bl	90001378 <HAL_GetTick>
90002a8e:	9b10      	ldr	r3, [sp, #64]	; 0x40
90002a90:	eba0 0008 	sub.w	r0, r0, r8
90002a94:	4298      	cmp	r0, r3
90002a96:	d307      	bcc.n	90002aa8 <HAL_SD_ReadBlocks+0x1d0>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002a98:	6823      	ldr	r3, [r4, #0]
90002a9a:	4a0c      	ldr	r2, [pc, #48]	; (90002acc <HAL_SD_ReadBlocks+0x1f4>)
90002a9c:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
90002a9e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002aa0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
90002aa4:	e793      	b.n	900029ce <HAL_SD_ReadBlocks+0xf6>
90002aa6:	3504      	adds	r5, #4
    while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL)) && (dataremaining > 0U))
90002aa8:	6820      	ldr	r0, [r4, #0]
90002aaa:	6b43      	ldr	r3, [r0, #52]	; 0x34
90002aac:	029b      	lsls	r3, r3, #10
90002aae:	d501      	bpl.n	90002ab4 <HAL_SD_ReadBlocks+0x1dc>
90002ab0:	2e00      	cmp	r6, #0
90002ab2:	d1db      	bne.n	90002a6c <HAL_SD_ReadBlocks+0x194>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90002ab4:	f240 533a 	movw	r3, #1338	; 0x53a
    return HAL_OK;
90002ab8:	2700      	movs	r7, #0
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90002aba:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
90002abc:	2301      	movs	r3, #1
90002abe:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_OK;
90002ac2:	e72b      	b.n	9000291c <HAL_SD_ReadBlocks+0x44>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
90002ac4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002ac6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
90002aca:	e713      	b.n	900028f4 <HAL_SD_ReadBlocks+0x1c>
90002acc:	004005ff 	.word	0x004005ff

90002ad0 <HAL_SD_WriteBlocks>:
{
90002ad0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90002ad4:	460d      	mov	r5, r1
90002ad6:	b089      	sub	sp, #36	; 0x24
90002ad8:	4604      	mov	r4, r0
90002ada:	4692      	mov	sl, r2
90002adc:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
90002ade:	f7fe fc4b 	bl	90001378 <HAL_GetTick>
90002ae2:	4681      	mov	r9, r0
  if(NULL == pData)
90002ae4:	b935      	cbnz	r5, 90002af4 <HAL_SD_WriteBlocks+0x24>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
90002ae6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002ae8:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    return HAL_ERROR;
90002aec:	f04f 0801 	mov.w	r8, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
90002af0:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
90002af2:	e011      	b.n	90002b18 <HAL_SD_WriteBlocks+0x48>
  if(hsd->State == HAL_SD_STATE_READY)
90002af4:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
90002af8:	2b01      	cmp	r3, #1
90002afa:	fa5f f883 	uxtb.w	r8, r3
90002afe:	f040 80ac 	bne.w	90002c5a <HAL_SD_WriteBlocks+0x18a>
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90002b02:	eb0a 0307 	add.w	r3, sl, r7
90002b06:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90002b08:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90002b0a:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90002b0c:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90002b0e:	d907      	bls.n	90002b20 <HAL_SD_WriteBlocks+0x50>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
90002b10:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002b12:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
90002b16:	63a3      	str	r3, [r4, #56]	; 0x38
}
90002b18:	4640      	mov	r0, r8
90002b1a:	b009      	add	sp, #36	; 0x24
90002b1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    hsd->State = HAL_SD_STATE_BUSY;
90002b20:	2303      	movs	r3, #3
    hsd->Instance->DCTRL = 0U;
90002b22:	6820      	ldr	r0, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
90002b24:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
90002b28:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hsd->Instance->DCTRL = 0U;
90002b2a:	62c1      	str	r1, [r0, #44]	; 0x2c
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
90002b2c:	2190      	movs	r1, #144	; 0x90
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
90002b2e:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
90002b30:	f04f 33ff 	mov.w	r3, #4294967295
90002b34:	9302      	str	r3, [sp, #8]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
90002b36:	ea4f 2347 	mov.w	r3, r7, lsl #9
      add *= 512U;
90002b3a:	bf18      	it	ne
90002b3c:	ea4f 2a4a 	movne.w	sl, sl, lsl #9
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
90002b40:	9303      	str	r3, [sp, #12]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
90002b42:	2300      	movs	r3, #0
90002b44:	e9cd 1304 	strd	r1, r3, [sp, #16]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90002b48:	9306      	str	r3, [sp, #24]
    config.DPSM          = SDMMC_DPSM_ENABLE;
90002b4a:	2301      	movs	r3, #1
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90002b4c:	a902      	add	r1, sp, #8
    config.DPSM          = SDMMC_DPSM_ENABLE;
90002b4e:	9307      	str	r3, [sp, #28]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90002b50:	f000 fd10 	bl	90003574 <SDMMC_ConfigData>
    if(NumberOfBlocks > 1U)
90002b54:	2f01      	cmp	r7, #1
90002b56:	d912      	bls.n	90002b7e <HAL_SD_WriteBlocks+0xae>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
90002b58:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
90002b5a:	4651      	mov	r1, sl
90002b5c:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
90002b5e:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
90002b60:	f000 fd7b 	bl	9000365a <SDMMC_CmdWriteMultiBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
90002b64:	b190      	cbz	r0, 90002b8c <HAL_SD_WriteBlocks+0xbc>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002b66:	6823      	ldr	r3, [r4, #0]
90002b68:	4a3e      	ldr	r2, [pc, #248]	; (90002c64 <HAL_SD_WriteBlocks+0x194>)
90002b6a:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
90002b6c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002b6e:	4318      	orrs	r0, r3
90002b70:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
90002b72:	2301      	movs	r3, #1
90002b74:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
90002b78:	2300      	movs	r3, #0
90002b7a:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_ERROR;
90002b7c:	e7cc      	b.n	90002b18 <HAL_SD_WriteBlocks+0x48>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
90002b7e:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
90002b80:	4651      	mov	r1, sl
90002b82:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
90002b84:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
90002b86:	f000 fd50 	bl	9000362a <SDMMC_CmdWriteSingleBlock>
90002b8a:	e7eb      	b.n	90002b64 <HAL_SD_WriteBlocks+0x94>
    dataremaining = config.DataLength;
90002b8c:	9e03      	ldr	r6, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
90002b8e:	6820      	ldr	r0, [r4, #0]
90002b90:	6b43      	ldr	r3, [r0, #52]	; 0x34
90002b92:	f413 7f8d 	tst.w	r3, #282	; 0x11a
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining > 0U))
90002b96:	6b43      	ldr	r3, [r0, #52]	; 0x34
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
90002b98:	d016      	beq.n	90002bc8 <HAL_SD_WriteBlocks+0xf8>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
90002b9a:	05db      	lsls	r3, r3, #23
90002b9c:	d508      	bpl.n	90002bb0 <HAL_SD_WriteBlocks+0xe0>
90002b9e:	2f01      	cmp	r7, #1
90002ba0:	d906      	bls.n	90002bb0 <HAL_SD_WriteBlocks+0xe0>
      if(hsd->SdCard.CardType != CARD_SECURED)
90002ba2:	6c63      	ldr	r3, [r4, #68]	; 0x44
90002ba4:	2b03      	cmp	r3, #3
90002ba6:	d003      	beq.n	90002bb0 <HAL_SD_WriteBlocks+0xe0>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
90002ba8:	f000 fd70 	bl	9000368c <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
90002bac:	2800      	cmp	r0, #0
90002bae:	d1da      	bne.n	90002b66 <HAL_SD_WriteBlocks+0x96>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
90002bb0:	6823      	ldr	r3, [r4, #0]
90002bb2:	6b58      	ldr	r0, [r3, #52]	; 0x34
90002bb4:	f010 0008 	ands.w	r0, r0, #8
90002bb8:	d029      	beq.n	90002c0e <HAL_SD_WriteBlocks+0x13e>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002bba:	4a2a      	ldr	r2, [pc, #168]	; (90002c64 <HAL_SD_WriteBlocks+0x194>)
90002bbc:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
90002bbe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002bc0:	f043 0308 	orr.w	r3, r3, #8
90002bc4:	63a3      	str	r3, [r4, #56]	; 0x38
90002bc6:	e7d4      	b.n	90002b72 <HAL_SD_WriteBlocks+0xa2>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining > 0U))
90002bc8:	045a      	lsls	r2, r3, #17
90002bca:	d50c      	bpl.n	90002be6 <HAL_SD_WriteBlocks+0x116>
90002bcc:	b15e      	cbz	r6, 90002be6 <HAL_SD_WriteBlocks+0x116>
90002bce:	f105 0b20 	add.w	fp, r5, #32
          data |= ((uint32_t)(*tempbuff) << 24U);
90002bd2:	f855 3b04 	ldr.w	r3, [r5], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
90002bd6:	a901      	add	r1, sp, #4
90002bd8:	6820      	ldr	r0, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
90002bda:	9301      	str	r3, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
90002bdc:	f000 fca3 	bl	90003526 <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
90002be0:	45ab      	cmp	fp, r5
90002be2:	d1f6      	bne.n	90002bd2 <HAL_SD_WriteBlocks+0x102>
90002be4:	3e20      	subs	r6, #32
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
90002be6:	f7fe fbc7 	bl	90001378 <HAL_GetTick>
90002bea:	9b12      	ldr	r3, [sp, #72]	; 0x48
90002bec:	eba0 0009 	sub.w	r0, r0, r9
90002bf0:	4298      	cmp	r0, r3
90002bf2:	d3cc      	bcc.n	90002b8e <HAL_SD_WriteBlocks+0xbe>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002bf4:	6823      	ldr	r3, [r4, #0]
        return HAL_TIMEOUT;
90002bf6:	f04f 0803 	mov.w	r8, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002bfa:	4a1a      	ldr	r2, [pc, #104]	; (90002c64 <HAL_SD_WriteBlocks+0x194>)
90002bfc:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
90002bfe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002c00:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
90002c02:	2301      	movs	r3, #1
90002c04:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
90002c08:	2300      	movs	r3, #0
90002c0a:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
90002c0c:	e784      	b.n	90002b18 <HAL_SD_WriteBlocks+0x48>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
90002c0e:	6b59      	ldr	r1, [r3, #52]	; 0x34
90002c10:	f011 0102 	ands.w	r1, r1, #2
90002c14:	d00a      	beq.n	90002c2c <HAL_SD_WriteBlocks+0x15c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002c16:	4a13      	ldr	r2, [pc, #76]	; (90002c64 <HAL_SD_WriteBlocks+0x194>)
90002c18:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
90002c1a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002c1c:	f043 0302 	orr.w	r3, r3, #2
90002c20:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
90002c22:	2301      	movs	r3, #1
90002c24:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
90002c28:	6320      	str	r0, [r4, #48]	; 0x30
      return HAL_ERROR;
90002c2a:	e775      	b.n	90002b18 <HAL_SD_WriteBlocks+0x48>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
90002c2c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
90002c2e:	f012 0210 	ands.w	r2, r2, #16
90002c32:	d00a      	beq.n	90002c4a <HAL_SD_WriteBlocks+0x17a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002c34:	4a0b      	ldr	r2, [pc, #44]	; (90002c64 <HAL_SD_WriteBlocks+0x194>)
90002c36:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
90002c38:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002c3a:	f043 0310 	orr.w	r3, r3, #16
90002c3e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
90002c40:	2301      	movs	r3, #1
90002c42:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
90002c46:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
90002c48:	e766      	b.n	90002b18 <HAL_SD_WriteBlocks+0x48>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90002c4a:	f240 513a 	movw	r1, #1338	; 0x53a
    return HAL_OK;
90002c4e:	4690      	mov	r8, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90002c50:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
90002c52:	2301      	movs	r3, #1
90002c54:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_OK;
90002c58:	e75e      	b.n	90002b18 <HAL_SD_WriteBlocks+0x48>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
90002c5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002c5c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
90002c60:	e744      	b.n	90002aec <HAL_SD_WriteBlocks+0x1c>
90002c62:	bf00      	nop
90002c64:	004005ff 	.word	0x004005ff

90002c68 <HAL_SD_GetCardCSD>:
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
90002c68:	6e43      	ldr	r3, [r0, #100]	; 0x64
90002c6a:	0f9a      	lsrs	r2, r3, #30
90002c6c:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
90002c6e:	f3c3 6283 	ubfx	r2, r3, #26, #4
90002c72:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
90002c74:	f3c3 6201 	ubfx	r2, r3, #24, #2
90002c78:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
90002c7a:	f3c3 4207 	ubfx	r2, r3, #16, #8
90002c7e:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
90002c80:	f3c3 2207 	ubfx	r2, r3, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
90002c84:	b2db      	uxtb	r3, r3
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
90002c86:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
90002c88:	714b      	strb	r3, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
90002c8a:	6e83      	ldr	r3, [r0, #104]	; 0x68
90002c8c:	0d1a      	lsrs	r2, r3, #20
90002c8e:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
90002c90:	f3c3 4203 	ubfx	r2, r3, #16, #4
90002c94:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
90002c96:	f3c3 32c0 	ubfx	r2, r3, #15, #1
90002c9a:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
90002c9c:	f3c3 3280 	ubfx	r2, r3, #14, #1
90002ca0:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
90002ca2:	f3c3 3240 	ubfx	r2, r3, #13, #1
90002ca6:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
90002ca8:	f3c3 3200 	ubfx	r2, r3, #12, #1
90002cac:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
90002cae:	2200      	movs	r2, #0
90002cb0:	734a      	strb	r2, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
90002cb2:	6c42      	ldr	r2, [r0, #68]	; 0x44
{
90002cb4:	b510      	push	{r4, lr}
  if(hsd->SdCard.CardType == CARD_SDSC)
90002cb6:	2a00      	cmp	r2, #0
90002cb8:	d16b      	bne.n	90002d92 <HAL_SD_GetCardCSD+0x12a>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
90002cba:	f640 74fc 	movw	r4, #4092	; 0xffc
90002cbe:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
90002cc0:	ea04 0383 	and.w	r3, r4, r3, lsl #2
90002cc4:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
90002cc8:	610b      	str	r3, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
90002cca:	f3c2 63c2 	ubfx	r3, r2, #27, #3
90002cce:	750b      	strb	r3, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
90002cd0:	f3c2 6302 	ubfx	r3, r2, #24, #3
90002cd4:	754b      	strb	r3, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
90002cd6:	f3c2 5342 	ubfx	r3, r2, #21, #3
90002cda:	758b      	strb	r3, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
90002cdc:	f3c2 4382 	ubfx	r3, r2, #18, #3
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
90002ce0:	f3c2 32c2 	ubfx	r2, r2, #15, #3
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
90002ce4:	75cb      	strb	r3, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
90002ce6:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
90002ce8:	690b      	ldr	r3, [r1, #16]
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
90002cea:	7e0a      	ldrb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
90002cec:	3301      	adds	r3, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
90002cee:	f002 0207 	and.w	r2, r2, #7
90002cf2:	3202      	adds	r2, #2
90002cf4:	4093      	lsls	r3, r2
90002cf6:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
90002cf8:	7a0a      	ldrb	r2, [r1, #8]
90002cfa:	f002 040f 	and.w	r4, r2, #15
90002cfe:	2201      	movs	r2, #1
90002d00:	40a2      	lsls	r2, r4
90002d02:	6582      	str	r2, [r0, #88]	; 0x58
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
90002d04:	0a52      	lsrs	r2, r2, #9
90002d06:	4353      	muls	r3, r2
90002d08:	65c3      	str	r3, [r0, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = 512U;
90002d0a:	f44f 7300 	mov.w	r3, #512	; 0x200
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
90002d0e:	6603      	str	r3, [r0, #96]	; 0x60
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
90002d10:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
90002d12:	f3c3 3280 	ubfx	r2, r3, #14, #1
90002d16:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
90002d18:	f3c3 12c6 	ubfx	r2, r3, #7, #7
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
90002d1c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
90002d20:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
90002d22:	76cb      	strb	r3, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
90002d24:	6f03      	ldr	r3, [r0, #112]	; 0x70
  pCSD->Reserved3 = 0;
90002d26:	2000      	movs	r0, #0
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
90002d28:	0fda      	lsrs	r2, r3, #31
90002d2a:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
90002d2c:	f3c3 7241 	ubfx	r2, r3, #29, #2
90002d30:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
90002d32:	f3c3 6282 	ubfx	r2, r3, #26, #3
90002d36:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
90002d38:	f3c3 5283 	ubfx	r2, r3, #22, #4
90002d3c:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
90002d3e:	f3c3 5240 	ubfx	r2, r3, #21, #1
90002d42:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
90002d46:	f3c3 4200 	ubfx	r2, r3, #16, #1
  pCSD->Reserved3 = 0;
90002d4a:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
90002d4e:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
90002d52:	f3c3 32c0 	ubfx	r2, r3, #15, #1
90002d56:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
90002d5a:	f3c3 3280 	ubfx	r2, r3, #14, #1
90002d5e:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
90002d62:	f3c3 3240 	ubfx	r2, r3, #13, #1
90002d66:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
90002d6a:	f3c3 3200 	ubfx	r2, r3, #12, #1
90002d6e:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
90002d72:	f3c3 2281 	ubfx	r2, r3, #10, #2
90002d76:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
90002d7a:	f3c3 2201 	ubfx	r2, r3, #8, #2
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
90002d7e:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
90002d82:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
90002d86:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
90002d8a:	2301      	movs	r3, #1
90002d8c:	f881 302a 	strb.w	r3, [r1, #42]	; 0x2a
}
90002d90:	bd10      	pop	{r4, pc}
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
90002d92:	2a01      	cmp	r2, #1
90002d94:	d10f      	bne.n	90002db6 <HAL_SD_GetCardCSD+0x14e>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
90002d96:	041b      	lsls	r3, r3, #16
90002d98:	f8b0 206e 	ldrh.w	r2, [r0, #110]	; 0x6e
90002d9c:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
90002da0:	4313      	orrs	r3, r2
90002da2:	610b      	str	r3, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
90002da4:	690b      	ldr	r3, [r1, #16]
90002da6:	3301      	adds	r3, #1
90002da8:	029b      	lsls	r3, r3, #10
90002daa:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
90002dac:	65c3      	str	r3, [r0, #92]	; 0x5c
    hsd->SdCard.BlockSize = 512U;
90002dae:	f44f 7300 	mov.w	r3, #512	; 0x200
90002db2:	6583      	str	r3, [r0, #88]	; 0x58
90002db4:	e7ab      	b.n	90002d0e <HAL_SD_GetCardCSD+0xa6>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002db6:	6803      	ldr	r3, [r0, #0]
90002db8:	4a05      	ldr	r2, [pc, #20]	; (90002dd0 <HAL_SD_GetCardCSD+0x168>)
90002dba:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90002dbc:	6b83      	ldr	r3, [r0, #56]	; 0x38
90002dbe:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90002dc2:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
90002dc4:	2301      	movs	r3, #1
90002dc6:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    return HAL_ERROR;
90002dca:	4618      	mov	r0, r3
90002dcc:	e7e0      	b.n	90002d90 <HAL_SD_GetCardCSD+0x128>
90002dce:	bf00      	nop
90002dd0:	004005ff 	.word	0x004005ff

90002dd4 <HAL_SD_InitCard>:
{
90002dd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
90002dd8:	2300      	movs	r3, #0
{
90002dda:	b098      	sub	sp, #96	; 0x60
90002ddc:	4604      	mov	r4, r0
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
90002dde:	930b      	str	r3, [sp, #44]	; 0x2c
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
90002de0:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
90002de4:	e9cd 3307 	strd	r3, r3, [sp, #28]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
90002de8:	2376      	movs	r3, #118	; 0x76
90002dea:	930c      	str	r3, [sp, #48]	; 0x30
  status = SDMMC_Init(hsd->Instance, Init);
90002dec:	ab0a      	add	r3, sp, #40	; 0x28
90002dee:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
90002df2:	ab07      	add	r3, sp, #28
90002df4:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
90002df8:	6820      	ldr	r0, [r4, #0]
90002dfa:	cb0e      	ldmia	r3, {r1, r2, r3}
90002dfc:	f000 fb74 	bl	900034e8 <SDMMC_Init>
  if(status != HAL_OK)
90002e00:	4605      	mov	r5, r0
90002e02:	bb50      	cbnz	r0, 90002e5a <HAL_SD_InitCard+0x86>
  __HAL_SD_DISABLE(hsd);
90002e04:	6820      	ldr	r0, [r4, #0]
90002e06:	6843      	ldr	r3, [r0, #4]
90002e08:	f423 7380 	bic.w	r3, r3, #256	; 0x100
90002e0c:	6043      	str	r3, [r0, #4]
  (void)SDMMC_PowerState_ON(hsd->Instance);
90002e0e:	f000 fb8f 	bl	90003530 <SDMMC_PowerState_ON>
  __HAL_SD_ENABLE(hsd);
90002e12:	6820      	ldr	r0, [r4, #0]
90002e14:	6843      	ldr	r3, [r0, #4]
90002e16:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90002e1a:	6043      	str	r3, [r0, #4]
  __IO uint32_t count = 0U;
90002e1c:	9506      	str	r5, [sp, #24]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90002e1e:	f000 fc67 	bl	900036f0 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
90002e22:	4605      	mov	r5, r0
90002e24:	b998      	cbnz	r0, 90002e4e <HAL_SD_InitCard+0x7a>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
90002e26:	6820      	ldr	r0, [r4, #0]
90002e28:	f000 fc88 	bl	9000373c <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
90002e2c:	b130      	cbz	r0, 90002e3c <HAL_SD_InitCard+0x68>
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90002e2e:	6820      	ldr	r0, [r4, #0]
    hsd->SdCard.CardVersion = CARD_V1_X;
90002e30:	64a5      	str	r5, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90002e32:	f000 fc5d 	bl	900036f0 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
90002e36:	b190      	cbz	r0, 90002e5e <HAL_SD_InitCard+0x8a>
90002e38:	4605      	mov	r5, r0
90002e3a:	e008      	b.n	90002e4e <HAL_SD_InitCard+0x7a>
    hsd->SdCard.CardVersion = CARD_V2_X;
90002e3c:	2301      	movs	r3, #1
90002e3e:	64a3      	str	r3, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
90002e40:	2100      	movs	r1, #0
90002e42:	6820      	ldr	r0, [r4, #0]
90002e44:	f000 fcb6 	bl	900037b4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
90002e48:	b160      	cbz	r0, 90002e64 <HAL_SD_InitCard+0x90>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90002e4a:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    hsd->State = HAL_SD_STATE_READY;
90002e4e:	2001      	movs	r0, #1
90002e50:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
90002e54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002e56:	432b      	orrs	r3, r5
90002e58:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
90002e5a:	2501      	movs	r5, #1
90002e5c:	e0b3      	b.n	90002fc6 <HAL_SD_InitCard+0x1f2>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
90002e5e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
90002e60:	2b01      	cmp	r3, #1
90002e62:	d0ed      	beq.n	90002e40 <HAL_SD_InitCard+0x6c>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
90002e64:	f64f 76fe 	movw	r6, #65534	; 0xfffe
{
90002e68:	2100      	movs	r1, #0
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
90002e6a:	f8df 8168 	ldr.w	r8, [pc, #360]	; 90002fd4 <HAL_SD_InitCard+0x200>
90002e6e:	4637      	mov	r7, r6
90002e70:	e014      	b.n	90002e9c <HAL_SD_InitCard+0xc8>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
90002e72:	6820      	ldr	r0, [r4, #0]
90002e74:	f000 fc9e 	bl	900037b4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
90002e78:	4605      	mov	r5, r0
90002e7a:	2800      	cmp	r0, #0
90002e7c:	d1e7      	bne.n	90002e4e <HAL_SD_InitCard+0x7a>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
90002e7e:	4641      	mov	r1, r8
90002e80:	6820      	ldr	r0, [r4, #0]
90002e82:	f000 fcaf 	bl	900037e4 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
90002e86:	2800      	cmp	r0, #0
90002e88:	d1df      	bne.n	90002e4a <HAL_SD_InitCard+0x76>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90002e8a:	4629      	mov	r1, r5
90002e8c:	6820      	ldr	r0, [r4, #0]
90002e8e:	f000 fb6e 	bl	9000356e <SDMMC_GetResponse>
    count++;
90002e92:	9b06      	ldr	r3, [sp, #24]
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90002e94:	4605      	mov	r5, r0
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
90002e96:	0fc1      	lsrs	r1, r0, #31
    count++;
90002e98:	3301      	adds	r3, #1
90002e9a:	9306      	str	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
90002e9c:	9b06      	ldr	r3, [sp, #24]
90002e9e:	42b3      	cmp	r3, r6
90002ea0:	d801      	bhi.n	90002ea6 <HAL_SD_InitCard+0xd2>
90002ea2:	2900      	cmp	r1, #0
90002ea4:	d0e5      	beq.n	90002e72 <HAL_SD_InitCard+0x9e>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
90002ea6:	9b06      	ldr	r3, [sp, #24]
90002ea8:	42bb      	cmp	r3, r7
90002eaa:	d80c      	bhi.n	90002ec6 <HAL_SD_InitCard+0xf2>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
90002eac:	f3c5 7580 	ubfx	r5, r5, #30, #1
  uint16_t sd_rca = 1U;
90002eb0:	2301      	movs	r3, #1
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
90002eb2:	6820      	ldr	r0, [r4, #0]
90002eb4:	6465      	str	r5, [r4, #68]	; 0x44
  uint16_t sd_rca = 1U;
90002eb6:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
90002eba:	f000 fb41 	bl	90003540 <SDMMC_GetPowerState>
90002ebe:	b928      	cbnz	r0, 90002ecc <HAL_SD_InitCard+0xf8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
90002ec0:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
90002ec4:	e079      	b.n	90002fba <HAL_SD_InitCard+0x1e6>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
90002ec6:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
90002eca:	e7c0      	b.n	90002e4e <HAL_SD_InitCard+0x7a>
  if(hsd->SdCard.CardType != CARD_SECURED)
90002ecc:	6c63      	ldr	r3, [r4, #68]	; 0x44
90002ece:	2b03      	cmp	r3, #3
90002ed0:	d043      	beq.n	90002f5a <HAL_SD_InitCard+0x186>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
90002ed2:	6820      	ldr	r0, [r4, #0]
90002ed4:	f000 fccf 	bl	90003876 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
90002ed8:	2800      	cmp	r0, #0
90002eda:	d16e      	bne.n	90002fba <HAL_SD_InitCard+0x1e6>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90002edc:	4601      	mov	r1, r0
90002ede:	6820      	ldr	r0, [r4, #0]
90002ee0:	f000 fb45 	bl	9000356e <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90002ee4:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90002ee6:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90002ee8:	6820      	ldr	r0, [r4, #0]
90002eea:	f000 fb40 	bl	9000356e <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90002eee:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90002ef0:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90002ef2:	6820      	ldr	r0, [r4, #0]
90002ef4:	f000 fb3b 	bl	9000356e <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90002ef8:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90002efa:	67e0      	str	r0, [r4, #124]	; 0x7c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90002efc:	6820      	ldr	r0, [r4, #0]
90002efe:	f000 fb36 	bl	9000356e <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
90002f02:	6c63      	ldr	r3, [r4, #68]	; 0x44
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90002f04:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
  if(hsd->SdCard.CardType != CARD_SECURED)
90002f08:	2b03      	cmp	r3, #3
90002f0a:	d026      	beq.n	90002f5a <HAL_SD_InitCard+0x186>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
90002f0c:	f10d 0116 	add.w	r1, sp, #22
90002f10:	6820      	ldr	r0, [r4, #0]
90002f12:	f000 fcdb 	bl	900038cc <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
90002f16:	2800      	cmp	r0, #0
90002f18:	d14f      	bne.n	90002fba <HAL_SD_InitCard+0x1e6>
  if(hsd->SdCard.CardType != CARD_SECURED)
90002f1a:	6c63      	ldr	r3, [r4, #68]	; 0x44
90002f1c:	6820      	ldr	r0, [r4, #0]
90002f1e:	2b03      	cmp	r3, #3
90002f20:	d01b      	beq.n	90002f5a <HAL_SD_InitCard+0x186>
    hsd->SdCard.RelCardAdd = sd_rca;
90002f22:	f8bd 1016 	ldrh.w	r1, [sp, #22]
90002f26:	6521      	str	r1, [r4, #80]	; 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90002f28:	0409      	lsls	r1, r1, #16
90002f2a:	f000 fcb9 	bl	900038a0 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
90002f2e:	2800      	cmp	r0, #0
90002f30:	d143      	bne.n	90002fba <HAL_SD_InitCard+0x1e6>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90002f32:	4601      	mov	r1, r0
90002f34:	6820      	ldr	r0, [r4, #0]
90002f36:	f000 fb1a 	bl	9000356e <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90002f3a:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90002f3c:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90002f3e:	6820      	ldr	r0, [r4, #0]
90002f40:	f000 fb15 	bl	9000356e <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90002f44:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90002f46:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90002f48:	6820      	ldr	r0, [r4, #0]
90002f4a:	f000 fb10 	bl	9000356e <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90002f4e:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90002f50:	66e0      	str	r0, [r4, #108]	; 0x6c
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90002f52:	6820      	ldr	r0, [r4, #0]
90002f54:	f000 fb0b 	bl	9000356e <SDMMC_GetResponse>
90002f58:	6720      	str	r0, [r4, #112]	; 0x70
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
90002f5a:	2104      	movs	r1, #4
90002f5c:	6820      	ldr	r0, [r4, #0]
90002f5e:	f000 fb06 	bl	9000356e <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
90002f62:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
90002f64:	0d00      	lsrs	r0, r0, #20
90002f66:	64e0      	str	r0, [r4, #76]	; 0x4c
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
90002f68:	4620      	mov	r0, r4
90002f6a:	f7ff fe7d 	bl	90002c68 <HAL_SD_GetCardCSD>
90002f6e:	4605      	mov	r5, r0
90002f70:	bb08      	cbnz	r0, 90002fb6 <HAL_SD_InitCard+0x1e2>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
90002f72:	6d22      	ldr	r2, [r4, #80]	; 0x50
90002f74:	4603      	mov	r3, r0
90002f76:	6820      	ldr	r0, [r4, #0]
90002f78:	0412      	lsls	r2, r2, #16
90002f7a:	f000 fba1 	bl	900036c0 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
90002f7e:	b9e0      	cbnz	r0, 90002fba <HAL_SD_InitCard+0x1e6>
  (void)SDMMC_Init(hsd->Instance, hsd->Init);
90002f80:	f104 0310 	add.w	r3, r4, #16
90002f84:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
90002f88:	1d23      	adds	r3, r4, #4
90002f8a:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
90002f8e:	6820      	ldr	r0, [r4, #0]
90002f90:	cb0e      	ldmia	r3, {r1, r2, r3}
90002f92:	f000 faa9 	bl	900034e8 <SDMMC_Init>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
90002f96:	f44f 7100 	mov.w	r1, #512	; 0x200
90002f9a:	6820      	ldr	r0, [r4, #0]
90002f9c:	f000 fafd 	bl	9000359a <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
90002fa0:	b188      	cbz	r0, 90002fc6 <HAL_SD_InitCard+0x1f2>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002fa2:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
90002fa4:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90002fa6:	4a0a      	ldr	r2, [pc, #40]	; (90002fd0 <HAL_SD_InitCard+0x1fc>)
90002fa8:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
90002faa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90002fac:	4318      	orrs	r0, r3
90002fae:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
90002fb0:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    return HAL_ERROR;
90002fb4:	e007      	b.n	90002fc6 <HAL_SD_InitCard+0x1f2>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90002fb6:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    hsd->State = HAL_SD_STATE_READY;
90002fba:	2501      	movs	r5, #1
90002fbc:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
90002fc0:	6ba1      	ldr	r1, [r4, #56]	; 0x38
90002fc2:	4301      	orrs	r1, r0
90002fc4:	63a1      	str	r1, [r4, #56]	; 0x38
}
90002fc6:	4628      	mov	r0, r5
90002fc8:	b018      	add	sp, #96	; 0x60
90002fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
90002fce:	bf00      	nop
90002fd0:	004005ff 	.word	0x004005ff
90002fd4:	c1100000 	.word	0xc1100000

90002fd8 <HAL_SD_Init>:
{
90002fd8:	b510      	push	{r4, lr}
  if(hsd == NULL)
90002fda:	4604      	mov	r4, r0
90002fdc:	b908      	cbnz	r0, 90002fe2 <HAL_SD_Init+0xa>
    return HAL_ERROR;
90002fde:	2001      	movs	r0, #1
}
90002fe0:	bd10      	pop	{r4, pc}
  if(hsd->State == HAL_SD_STATE_RESET)
90002fe2:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
90002fe6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
90002fea:	b913      	cbnz	r3, 90002ff2 <HAL_SD_Init+0x1a>
    hsd->Lock = HAL_UNLOCKED;
90002fec:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
90002fee:	f7ff fc71 	bl	900028d4 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
90002ff2:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
90002ff4:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
90002ff6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
90002ffa:	f7ff feeb 	bl	90002dd4 <HAL_SD_InitCard>
90002ffe:	2800      	cmp	r0, #0
90003000:	d1ed      	bne.n	90002fde <HAL_SD_Init+0x6>
  hsd->State = HAL_SD_STATE_READY;
90003002:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
90003004:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
90003006:	6320      	str	r0, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
90003008:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
9000300c:	e7e8      	b.n	90002fe0 <HAL_SD_Init+0x8>

9000300e <HAL_SD_GetCardInfo>:
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
9000300e:	6c43      	ldr	r3, [r0, #68]	; 0x44
90003010:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
90003012:	6c83      	ldr	r3, [r0, #72]	; 0x48
90003014:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
90003016:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
90003018:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
9000301a:	6d03      	ldr	r3, [r0, #80]	; 0x50
9000301c:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
9000301e:	6d43      	ldr	r3, [r0, #84]	; 0x54
90003020:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
90003022:	6d83      	ldr	r3, [r0, #88]	; 0x58
90003024:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
90003026:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
90003028:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
9000302a:	6e03      	ldr	r3, [r0, #96]	; 0x60
}
9000302c:	2000      	movs	r0, #0
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
9000302e:	61cb      	str	r3, [r1, #28]
}
90003030:	4770      	bx	lr
	...

90003034 <HAL_SD_ConfigWideBusOperation>:
  hsd->State = HAL_SD_STATE_BUSY;
90003034:	2303      	movs	r3, #3
{
90003036:	b5f0      	push	{r4, r5, r6, r7, lr}
  hsd->State = HAL_SD_STATE_BUSY;
90003038:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
{
9000303c:	b08b      	sub	sp, #44	; 0x2c
  if(hsd->SdCard.CardType != CARD_SECURED)
9000303e:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
90003040:	4604      	mov	r4, r0
90003042:	460d      	mov	r5, r1
  if(hsd->SdCard.CardType != CARD_SECURED)
90003044:	2b03      	cmp	r3, #3
90003046:	d002      	beq.n	9000304e <HAL_SD_ConfigWideBusOperation+0x1a>
    if(WideMode == SDMMC_BUS_WIDE_8B)
90003048:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
9000304c:	d103      	bne.n	90003056 <HAL_SD_ConfigWideBusOperation+0x22>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
9000304e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90003050:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90003054:	e065      	b.n	90003122 <HAL_SD_ConfigWideBusOperation+0xee>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
90003056:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
9000305a:	6800      	ldr	r0, [r0, #0]
9000305c:	d13c      	bne.n	900030d8 <HAL_SD_ConfigWideBusOperation+0xa4>
  uint32_t scr[2U] = {0U, 0U};
9000305e:	2100      	movs	r1, #0
90003060:	e9cd 1104 	strd	r1, r1, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90003064:	f000 fa83 	bl	9000356e <SDMMC_GetResponse>
90003068:	0180      	lsls	r0, r0, #6
9000306a:	d430      	bmi.n	900030ce <HAL_SD_ConfigWideBusOperation+0x9a>
  errorstate = SD_FindSCR(hsd, scr);
9000306c:	a904      	add	r1, sp, #16
9000306e:	4620      	mov	r0, r4
90003070:	f7ff fbca 	bl	90002808 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
90003074:	b960      	cbnz	r0, 90003090 <HAL_SD_ConfigWideBusOperation+0x5c>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
90003076:	9b05      	ldr	r3, [sp, #20]
90003078:	0359      	lsls	r1, r3, #13
9000307a:	d52a      	bpl.n	900030d2 <HAL_SD_ConfigWideBusOperation+0x9e>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
9000307c:	6d21      	ldr	r1, [r4, #80]	; 0x50
9000307e:	6820      	ldr	r0, [r4, #0]
90003080:	0409      	lsls	r1, r1, #16
90003082:	f000 fb97 	bl	900037b4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
90003086:	b918      	cbnz	r0, 90003090 <HAL_SD_ConfigWideBusOperation+0x5c>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
90003088:	2102      	movs	r1, #2
9000308a:	6820      	ldr	r0, [r4, #0]
9000308c:	f000 fbc3 	bl	90003816 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
90003090:	6ba3      	ldr	r3, [r4, #56]	; 0x38
90003092:	4318      	orrs	r0, r3
      hsd->ErrorCode |= errorstate;
90003094:	63a0      	str	r0, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
90003096:	6ba6      	ldr	r6, [r4, #56]	; 0x38
90003098:	6827      	ldr	r7, [r4, #0]
9000309a:	2e00      	cmp	r6, #0
9000309c:	d043      	beq.n	90003126 <HAL_SD_ConfigWideBusOperation+0xf2>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
9000309e:	4b2d      	ldr	r3, [pc, #180]	; (90003154 <HAL_SD_ConfigWideBusOperation+0x120>)
    hsd->State = HAL_SD_STATE_READY;
900030a0:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900030a2:	63bb      	str	r3, [r7, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
900030a4:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
900030a8:	f44f 7100 	mov.w	r1, #512	; 0x200
900030ac:	6820      	ldr	r0, [r4, #0]
900030ae:	f000 fa74 	bl	9000359a <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
900030b2:	b130      	cbz	r0, 900030c2 <HAL_SD_ConfigWideBusOperation+0x8e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900030b4:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
900030b6:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900030b8:	4a26      	ldr	r2, [pc, #152]	; (90003154 <HAL_SD_ConfigWideBusOperation+0x120>)
900030ba:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
900030bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
900030be:	4318      	orrs	r0, r3
900030c0:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
900030c2:	2301      	movs	r3, #1
}
900030c4:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
900030c6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
900030ca:	b00b      	add	sp, #44	; 0x2c
900030cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
900030ce:	4628      	mov	r0, r5
900030d0:	e7de      	b.n	90003090 <HAL_SD_ConfigWideBusOperation+0x5c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
900030d2:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
900030d6:	e7db      	b.n	90003090 <HAL_SD_ConfigWideBusOperation+0x5c>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
900030d8:	bb01      	cbnz	r1, 9000311c <HAL_SD_ConfigWideBusOperation+0xe8>
  uint32_t scr[2U] = {0U, 0U};
900030da:	e9cd 1104 	strd	r1, r1, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
900030de:	f000 fa46 	bl	9000356e <SDMMC_GetResponse>
900030e2:	0182      	lsls	r2, r0, #6
900030e4:	d414      	bmi.n	90003110 <HAL_SD_ConfigWideBusOperation+0xdc>
  errorstate = SD_FindSCR(hsd, scr);
900030e6:	a904      	add	r1, sp, #16
900030e8:	4620      	mov	r0, r4
900030ea:	f7ff fb8d 	bl	90002808 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
900030ee:	b960      	cbnz	r0, 9000310a <HAL_SD_ConfigWideBusOperation+0xd6>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
900030f0:	9b05      	ldr	r3, [sp, #20]
900030f2:	03db      	lsls	r3, r3, #15
900030f4:	d50f      	bpl.n	90003116 <HAL_SD_ConfigWideBusOperation+0xe2>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
900030f6:	6d21      	ldr	r1, [r4, #80]	; 0x50
900030f8:	6820      	ldr	r0, [r4, #0]
900030fa:	0409      	lsls	r1, r1, #16
900030fc:	f000 fb5a 	bl	900037b4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
90003100:	b918      	cbnz	r0, 9000310a <HAL_SD_ConfigWideBusOperation+0xd6>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
90003102:	4601      	mov	r1, r0
90003104:	6820      	ldr	r0, [r4, #0]
90003106:	f000 fb86 	bl	90003816 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
9000310a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
9000310c:	4308      	orrs	r0, r1
9000310e:	e7c1      	b.n	90003094 <HAL_SD_ConfigWideBusOperation+0x60>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
90003110:	f44f 6000 	mov.w	r0, #2048	; 0x800
90003114:	e7f9      	b.n	9000310a <HAL_SD_ConfigWideBusOperation+0xd6>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
90003116:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
9000311a:	e7f6      	b.n	9000310a <HAL_SD_ConfigWideBusOperation+0xd6>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
9000311c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
9000311e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90003122:	63a3      	str	r3, [r4, #56]	; 0x38
90003124:	e7b7      	b.n	90003096 <HAL_SD_ConfigWideBusOperation+0x62>
    Init.ClockEdge           = hsd->Init.ClockEdge;
90003126:	6863      	ldr	r3, [r4, #4]
90003128:	9304      	str	r3, [sp, #16]
    Init.ClockBypass         = hsd->Init.ClockBypass;
9000312a:	68a3      	ldr	r3, [r4, #8]
9000312c:	9305      	str	r3, [sp, #20]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
9000312e:	68e3      	ldr	r3, [r4, #12]
    Init.BusWide             = WideMode;
90003130:	e9cd 3506 	strd	r3, r5, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
90003134:	6963      	ldr	r3, [r4, #20]
  HAL_StatusTypeDef status = HAL_OK;
90003136:	4635      	mov	r5, r6
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
90003138:	9308      	str	r3, [sp, #32]
    Init.ClockDiv            = hsd->Init.ClockDiv;
9000313a:	69a3      	ldr	r3, [r4, #24]
9000313c:	9309      	str	r3, [sp, #36]	; 0x24
    (void)SDMMC_Init(hsd->Instance, Init);
9000313e:	ab0a      	add	r3, sp, #40	; 0x28
90003140:	e913 0007 	ldmdb	r3, {r0, r1, r2}
90003144:	ab04      	add	r3, sp, #16
90003146:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
9000314a:	4638      	mov	r0, r7
9000314c:	cb0e      	ldmia	r3, {r1, r2, r3}
9000314e:	f000 f9cb 	bl	900034e8 <SDMMC_Init>
90003152:	e7a9      	b.n	900030a8 <HAL_SD_ConfigWideBusOperation+0x74>
90003154:	004005ff 	.word	0x004005ff

90003158 <HAL_SD_GetCardState>:
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90003158:	6d01      	ldr	r1, [r0, #80]	; 0x50
{
9000315a:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
9000315c:	0409      	lsls	r1, r1, #16
{
9000315e:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90003160:	6800      	ldr	r0, [r0, #0]
90003162:	f000 fc05 	bl	90003970 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
90003166:	b930      	cbnz	r0, 90003176 <HAL_SD_GetCardState+0x1e>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90003168:	4601      	mov	r1, r0
9000316a:	6820      	ldr	r0, [r4, #0]
9000316c:	f000 f9ff 	bl	9000356e <SDMMC_GetResponse>
}
90003170:	f3c0 2043 	ubfx	r0, r0, #9, #4
90003174:	bd10      	pop	{r4, pc}
    hsd->ErrorCode |= errorstate;
90003176:	6ba1      	ldr	r1, [r4, #56]	; 0x38
90003178:	4308      	orrs	r0, r1
9000317a:	63a0      	str	r0, [r4, #56]	; 0x38
  uint32_t resp1 = 0;
9000317c:	2000      	movs	r0, #0
9000317e:	e7f7      	b.n	90003170 <HAL_SD_GetCardState+0x18>

90003180 <HAL_SDRAM_MspInit>:
  UNUSED(hsdram);
 
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
90003180:	4770      	bx	lr

90003182 <HAL_SDRAM_Init>:
{   
90003182:	b538      	push	{r3, r4, r5, lr}
90003184:	460d      	mov	r5, r1
  if(hsdram == NULL)
90003186:	4604      	mov	r4, r0
90003188:	b1c8      	cbz	r0, 900031be <HAL_SDRAM_Init+0x3c>
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
9000318a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
9000318e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
90003192:	b91b      	cbnz	r3, 9000319c <HAL_SDRAM_Init+0x1a>
    hsdram->Lock = HAL_UNLOCKED;
90003194:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
90003198:	f7ff fff2 	bl	90003180 <HAL_SDRAM_MspInit>
  hsdram->State = HAL_SDRAM_STATE_BUSY;
9000319c:	2302      	movs	r3, #2
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
9000319e:	1d21      	adds	r1, r4, #4
900031a0:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
900031a2:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
900031a6:	f000 f835 	bl	90003214 <FMC_SDRAM_Init>
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
900031aa:	6862      	ldr	r2, [r4, #4]
900031ac:	4629      	mov	r1, r5
900031ae:	6820      	ldr	r0, [r4, #0]
900031b0:	f000 f866 	bl	90003280 <FMC_SDRAM_Timing_Init>
  hsdram->State = HAL_SDRAM_STATE_READY;
900031b4:	2301      	movs	r3, #1
  return HAL_OK;
900031b6:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
900031b8:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
900031bc:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
900031be:	2001      	movs	r0, #1
900031c0:	e7fc      	b.n	900031bc <HAL_SDRAM_Init+0x3a>

900031c2 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
900031c2:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
900031c4:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
900031c8:	4604      	mov	r4, r0
900031ca:	460d      	mov	r5, r1
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
900031cc:	2b02      	cmp	r3, #2
900031ce:	b2d8      	uxtb	r0, r3
900031d0:	d00d      	beq.n	900031ee <HAL_SDRAM_SendCommand+0x2c>
  {
    return HAL_BUSY;
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
900031d2:	2302      	movs	r3, #2
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
900031d4:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
900031d6:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
900031da:	f000 f894 	bl	90003306 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
900031de:	682b      	ldr	r3, [r5, #0]
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  
  return HAL_OK;  
900031e0:	2000      	movs	r0, #0
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
900031e2:	2b02      	cmp	r3, #2
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
900031e4:	bf0c      	ite	eq
900031e6:	2305      	moveq	r3, #5
    hsdram->State = HAL_SDRAM_STATE_READY;
900031e8:	2301      	movne	r3, #1
900031ea:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
900031ee:	bd38      	pop	{r3, r4, r5, pc}

900031f0 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
900031f0:	b510      	push	{r4, lr}
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
900031f2:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
{
900031f6:	4604      	mov	r4, r0
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
900031f8:	2b02      	cmp	r3, #2
900031fa:	b2d8      	uxtb	r0, r3
900031fc:	d009      	beq.n	90003212 <HAL_SDRAM_ProgramRefreshRate+0x22>
  {
    return HAL_BUSY;
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
900031fe:	2302      	movs	r3, #2
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
90003200:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
90003202:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
90003206:	f000 f890 	bl	9000332a <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
9000320a:	2301      	movs	r3, #1
  
  return HAL_OK;   
9000320c:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
9000320e:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
90003212:	bd10      	pop	{r4, pc}

90003214 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
90003214:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
90003218:	6a4a      	ldr	r2, [r1, #36]	; 0x24
9000321a:	e9d1 4307 	ldrd	r4, r3, [r1, #28]
9000321e:	e9d1 5801 	ldrd	r5, r8, [r1, #4]
90003222:	e9d1 ec03 	ldrd	lr, ip, [r1, #12]
90003226:	e9d1 7605 	ldrd	r7, r6, [r1, #20]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
9000322a:	6809      	ldr	r1, [r1, #0]
9000322c:	4323      	orrs	r3, r4
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
9000322e:	6804      	ldr	r4, [r0, #0]
  if (Init->SDBank != FMC_SDRAM_BANK2) 
90003230:	2901      	cmp	r1, #1
90003232:	4912      	ldr	r1, [pc, #72]	; (9000327c <FMC_SDRAM_Init+0x68>)
90003234:	d00f      	beq.n	90003256 <FMC_SDRAM_Init+0x42>
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
90003236:	431a      	orrs	r2, r3
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
90003238:	4021      	ands	r1, r4
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
9000323a:	432a      	orrs	r2, r5
9000323c:	ea42 0308 	orr.w	r3, r2, r8
90003240:	ea43 030e 	orr.w	r3, r3, lr
90003244:	ea43 030c 	orr.w	r3, r3, ip
90003248:	433b      	orrs	r3, r7
9000324a:	4333      	orrs	r3, r6
9000324c:	430b      	orrs	r3, r1
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
9000324e:	6003      	str	r3, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
90003250:	2000      	movs	r0, #0
90003252:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
90003256:	4313      	orrs	r3, r2
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
90003258:	6842      	ldr	r2, [r0, #4]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
9000325a:	f424 44f8 	bic.w	r4, r4, #31744	; 0x7c00
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
9000325e:	4011      	ands	r1, r2
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
90003260:	ea45 0208 	orr.w	r2, r5, r8
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
90003264:	4323      	orrs	r3, r4
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
90003266:	ea42 020e 	orr.w	r2, r2, lr
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
9000326a:	6003      	str	r3, [r0, #0]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
9000326c:	ea42 020c 	orr.w	r2, r2, ip
90003270:	433a      	orrs	r2, r7
90003272:	4332      	orrs	r2, r6
90003274:	430a      	orrs	r2, r1
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
90003276:	6042      	str	r2, [r0, #4]
90003278:	e7ea      	b.n	90003250 <FMC_SDRAM_Init+0x3c>
9000327a:	bf00      	nop
9000327c:	ffff8000 	.word	0xffff8000

90003280 <FMC_SDRAM_Timing_Init>:
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
90003280:	68cb      	ldr	r3, [r1, #12]
90003282:	2a01      	cmp	r2, #1
{
90003284:	b5f0      	push	{r4, r5, r6, r7, lr}
90003286:	680c      	ldr	r4, [r1, #0]
90003288:	f103 37ff 	add.w	r7, r3, #4294967295
9000328c:	694b      	ldr	r3, [r1, #20]
9000328e:	688e      	ldr	r6, [r1, #8]
90003290:	f104 3cff 	add.w	ip, r4, #4294967295
90003294:	690d      	ldr	r5, [r1, #16]
90003296:	f103 33ff 	add.w	r3, r3, #4294967295
9000329a:	684c      	ldr	r4, [r1, #4]
9000329c:	f106 36ff 	add.w	r6, r6, #4294967295
900032a0:	6989      	ldr	r1, [r1, #24]
900032a2:	ea4f 5303 	mov.w	r3, r3, lsl #20
900032a6:	f104 34ff 	add.w	r4, r4, #4294967295
900032aa:	f105 35ff 	add.w	r5, r5, #4294967295
900032ae:	f101 31ff 	add.w	r1, r1, #4294967295
900032b2:	ea4f 2606 	mov.w	r6, r6, lsl #8
900032b6:	ea4f 1404 	mov.w	r4, r4, lsl #4
900032ba:	ea4f 4505 	mov.w	r5, r5, lsl #16
900032be:	ea4f 6101 	mov.w	r1, r1, lsl #24
900032c2:	ea43 3307 	orr.w	r3, r3, r7, lsl #12
  if (Bank != FMC_SDRAM_BANK2) 
900032c6:	d00c      	beq.n	900032e2 <FMC_SDRAM_Timing_Init+0x62>
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032c8:	ea43 030c 	orr.w	r3, r3, ip
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
900032cc:	6882      	ldr	r2, [r0, #8]
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032ce:	4323      	orrs	r3, r4
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
900032d0:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032d4:	4333      	orrs	r3, r6
900032d6:	432b      	orrs	r3, r5
900032d8:	430b      	orrs	r3, r1
900032da:	4313      	orrs	r3, r2
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
900032dc:	6083      	str	r3, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
900032de:	2000      	movs	r0, #0
900032e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
900032e2:	6887      	ldr	r7, [r0, #8]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032e4:	4334      	orrs	r4, r6
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
900032e6:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032ea:	ea44 020c 	orr.w	r2, r4, ip
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
900032ee:	f427 4770 	bic.w	r7, r7, #61440	; 0xf000
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032f2:	432a      	orrs	r2, r5
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
900032f4:	433b      	orrs	r3, r7
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
900032f6:	68c7      	ldr	r7, [r0, #12]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
900032f8:	430a      	orrs	r2, r1
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
900032fa:	f007 4770 	and.w	r7, r7, #4026531840	; 0xf0000000
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
900032fe:	6083      	str	r3, [r0, #8]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90003300:	433a      	orrs	r2, r7
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
90003302:	60c2      	str	r2, [r0, #12]
90003304:	e7eb      	b.n	900032de <FMC_SDRAM_Timing_Init+0x5e>

90003306 <FMC_SDRAM_SendCommand>:
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | 
90003306:	6902      	ldr	r2, [r0, #16]
{ 
90003308:	b510      	push	{r4, lr}
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | 
9000330a:	e9d1 3400 	ldrd	r3, r4, [r1]
9000330e:	0d92      	lsrs	r2, r2, #22
90003310:	4323      	orrs	r3, r4
90003312:	68cc      	ldr	r4, [r1, #12]
90003314:	0592      	lsls	r2, r2, #22
90003316:	ea43 2344 	orr.w	r3, r3, r4, lsl #9
9000331a:	4313      	orrs	r3, r2
9000331c:	688a      	ldr	r2, [r1, #8]
9000331e:	3a01      	subs	r2, #1
90003320:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
90003324:	6103      	str	r3, [r0, #16]
             FMC_SDCMR_NRFS | FMC_SDCMR_MRD), ((Command->CommandMode) | 
             (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
             ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  
  return HAL_OK;  
}
90003326:	2000      	movs	r0, #0
90003328:	bd10      	pop	{r4, pc}

9000332a <FMC_SDRAM_ProgramRefreshRate>:
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
9000332a:	6943      	ldr	r3, [r0, #20]
9000332c:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
90003330:	6141      	str	r1, [r0, #20]
  
  return HAL_OK;   
}
90003332:	2000      	movs	r0, #0
90003334:	4770      	bx	lr
	...

90003338 <SDMMC_GetCmdResp2>:
static uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
90003338:	4b11      	ldr	r3, [pc, #68]	; (90003380 <SDMMC_GetCmdResp2+0x48>)
9000333a:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
{
9000333e:	4602      	mov	r2, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
90003340:	681b      	ldr	r3, [r3, #0]
90003342:	fbb3 f1f1 	udiv	r1, r3, r1
90003346:	f241 3388 	movw	r3, #5000	; 0x1388
9000334a:	434b      	muls	r3, r1
  
  do
  {
    if (count-- == 0U)
9000334c:	3b01      	subs	r3, #1
9000334e:	d313      	bcc.n	90003378 <SDMMC_GetCmdResp2+0x40>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
90003350:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
90003352:	f011 0f45 	tst.w	r1, #69	; 0x45
90003356:	d0f9      	beq.n	9000334c <SDMMC_GetCmdResp2+0x14>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90003358:	0509      	lsls	r1, r1, #20
9000335a:	d4f7      	bmi.n	9000334c <SDMMC_GetCmdResp2+0x14>
    
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
9000335c:	6b53      	ldr	r3, [r2, #52]	; 0x34
9000335e:	075b      	lsls	r3, r3, #29
90003360:	d502      	bpl.n	90003368 <SDMMC_GetCmdResp2+0x30>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90003362:	2004      	movs	r0, #4
90003364:	6390      	str	r0, [r2, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
90003366:	4770      	bx	lr
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90003368:	6b50      	ldr	r0, [r2, #52]	; 0x34
9000336a:	f010 0001 	ands.w	r0, r0, #1
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
9000336e:	bf14      	ite	ne
90003370:	2301      	movne	r3, #1
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90003372:	23c5      	moveq	r3, #197	; 0xc5
90003374:	6393      	str	r3, [r2, #56]	; 0x38
  }

  return SDMMC_ERROR_NONE;
90003376:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
90003378:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
9000337c:	4770      	bx	lr
9000337e:	bf00      	nop
90003380:	2000002c 	.word	0x2000002c

90003384 <SDMMC_GetCmdResp3>:
static uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
90003384:	4b0f      	ldr	r3, [pc, #60]	; (900033c4 <SDMMC_GetCmdResp3+0x40>)
90003386:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
{
9000338a:	4602      	mov	r2, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
9000338c:	681b      	ldr	r3, [r3, #0]
9000338e:	fbb3 f1f1 	udiv	r1, r3, r1
90003392:	f241 3388 	movw	r3, #5000	; 0x1388
90003396:	434b      	muls	r3, r1
  
  do
  {
    if (count-- == 0U)
90003398:	3b01      	subs	r3, #1
9000339a:	d30f      	bcc.n	900033bc <SDMMC_GetCmdResp3+0x38>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
9000339c:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
9000339e:	f011 0f45 	tst.w	r1, #69	; 0x45
900033a2:	d0f9      	beq.n	90003398 <SDMMC_GetCmdResp3+0x14>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
900033a4:	0509      	lsls	r1, r1, #20
900033a6:	d4f7      	bmi.n	90003398 <SDMMC_GetCmdResp3+0x14>
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
900033a8:	6b50      	ldr	r0, [r2, #52]	; 0x34
900033aa:	f010 0004 	ands.w	r0, r0, #4
900033ae:	d002      	beq.n	900033b6 <SDMMC_GetCmdResp3+0x32>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
900033b0:	2004      	movs	r0, #4
900033b2:	6390      	str	r0, [r2, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
900033b4:	4770      	bx	lr
  }
  else
  {  
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
900033b6:	23c5      	movs	r3, #197	; 0xc5
900033b8:	6393      	str	r3, [r2, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
900033ba:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
900033bc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
900033c0:	4770      	bx	lr
900033c2:	bf00      	nop
900033c4:	2000002c 	.word	0x2000002c

900033c8 <SDMMC_GetCmdResp1>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
900033c8:	4b45      	ldr	r3, [pc, #276]	; (900034e0 <SDMMC_GetCmdResp1+0x118>)
{
900033ca:	b510      	push	{r4, lr}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
900033cc:	681b      	ldr	r3, [r3, #0]
{
900033ce:	4604      	mov	r4, r0
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
900033d0:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
900033d4:	fbb3 f3f0 	udiv	r3, r3, r0
900033d8:	435a      	muls	r2, r3
    if (count-- == 0U)
900033da:	2a00      	cmp	r2, #0
900033dc:	d049      	beq.n	90003472 <SDMMC_GetCmdResp1+0xaa>
    sta_reg = SDMMCx->STA;
900033de:	6b63      	ldr	r3, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
900033e0:	f013 0f45 	tst.w	r3, #69	; 0x45
900033e4:	d007      	beq.n	900033f6 <SDMMC_GetCmdResp1+0x2e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
900033e6:	051b      	lsls	r3, r3, #20
900033e8:	d405      	bmi.n	900033f6 <SDMMC_GetCmdResp1+0x2e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
900033ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
900033ec:	0758      	lsls	r0, r3, #29
900033ee:	d504      	bpl.n	900033fa <SDMMC_GetCmdResp1+0x32>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
900033f0:	2004      	movs	r0, #4
900033f2:	63a0      	str	r0, [r4, #56]	; 0x38
}
900033f4:	bd10      	pop	{r4, pc}
900033f6:	3a01      	subs	r2, #1
900033f8:	e7ef      	b.n	900033da <SDMMC_GetCmdResp1+0x12>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
900033fa:	6b60      	ldr	r0, [r4, #52]	; 0x34
900033fc:	f010 0001 	ands.w	r0, r0, #1
90003400:	d002      	beq.n	90003408 <SDMMC_GetCmdResp1+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
90003402:	2301      	movs	r3, #1
90003404:	63a3      	str	r3, [r4, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
90003406:	e7f5      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90003408:	23c5      	movs	r3, #197	; 0xc5
9000340a:	63a3      	str	r3, [r4, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
9000340c:	6923      	ldr	r3, [r4, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
9000340e:	b2db      	uxtb	r3, r3
90003410:	4299      	cmp	r1, r3
90003412:	d131      	bne.n	90003478 <SDMMC_GetCmdResp1+0xb0>
  return (*(__IO uint32_t *) tmp);
90003414:	6963      	ldr	r3, [r4, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
90003416:	4833      	ldr	r0, [pc, #204]	; (900034e4 <SDMMC_GetCmdResp1+0x11c>)
90003418:	4018      	ands	r0, r3
9000341a:	2800      	cmp	r0, #0
9000341c:	d0ea      	beq.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
9000341e:	2b00      	cmp	r3, #0
90003420:	db2c      	blt.n	9000347c <SDMMC_GetCmdResp1+0xb4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
90003422:	005a      	lsls	r2, r3, #1
90003424:	d42d      	bmi.n	90003482 <SDMMC_GetCmdResp1+0xba>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
90003426:	009c      	lsls	r4, r3, #2
90003428:	d42d      	bmi.n	90003486 <SDMMC_GetCmdResp1+0xbe>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
9000342a:	00d9      	lsls	r1, r3, #3
9000342c:	d42d      	bmi.n	9000348a <SDMMC_GetCmdResp1+0xc2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
9000342e:	011a      	lsls	r2, r3, #4
90003430:	d42e      	bmi.n	90003490 <SDMMC_GetCmdResp1+0xc8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
90003432:	015c      	lsls	r4, r3, #5
90003434:	d42f      	bmi.n	90003496 <SDMMC_GetCmdResp1+0xce>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
90003436:	01d9      	lsls	r1, r3, #7
90003438:	d430      	bmi.n	9000349c <SDMMC_GetCmdResp1+0xd4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
9000343a:	021a      	lsls	r2, r3, #8
9000343c:	d431      	bmi.n	900034a2 <SDMMC_GetCmdResp1+0xda>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
9000343e:	025c      	lsls	r4, r3, #9
90003440:	d432      	bmi.n	900034a8 <SDMMC_GetCmdResp1+0xe0>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
90003442:	0299      	lsls	r1, r3, #10
90003444:	d433      	bmi.n	900034ae <SDMMC_GetCmdResp1+0xe6>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
90003446:	02da      	lsls	r2, r3, #11
90003448:	d434      	bmi.n	900034b4 <SDMMC_GetCmdResp1+0xec>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
9000344a:	035c      	lsls	r4, r3, #13
9000344c:	d435      	bmi.n	900034ba <SDMMC_GetCmdResp1+0xf2>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
9000344e:	0399      	lsls	r1, r3, #14
90003450:	d436      	bmi.n	900034c0 <SDMMC_GetCmdResp1+0xf8>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
90003452:	03da      	lsls	r2, r3, #15
90003454:	d437      	bmi.n	900034c6 <SDMMC_GetCmdResp1+0xfe>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
90003456:	041c      	lsls	r4, r3, #16
90003458:	d438      	bmi.n	900034cc <SDMMC_GetCmdResp1+0x104>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
9000345a:	0459      	lsls	r1, r3, #17
9000345c:	d439      	bmi.n	900034d2 <SDMMC_GetCmdResp1+0x10a>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
9000345e:	049a      	lsls	r2, r3, #18
90003460:	d43a      	bmi.n	900034d8 <SDMMC_GetCmdResp1+0x110>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
90003462:	f013 0f08 	tst.w	r3, #8
90003466:	bf14      	ite	ne
90003468:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
9000346c:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
90003470:	e7c0      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
      return SDMMC_ERROR_TIMEOUT;
90003472:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
90003476:	e7bd      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
90003478:	2001      	movs	r0, #1
9000347a:	e7bb      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
9000347c:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
90003480:	e7b8      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ADDR_MISALIGNED;
90003482:	2040      	movs	r0, #64	; 0x40
90003484:	e7b6      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
90003486:	2080      	movs	r0, #128	; 0x80
90003488:	e7b4      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
9000348a:	f44f 7080 	mov.w	r0, #256	; 0x100
9000348e:	e7b1      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
90003490:	f44f 7000 	mov.w	r0, #512	; 0x200
90003494:	e7ae      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
90003496:	f44f 6080 	mov.w	r0, #1024	; 0x400
9000349a:	e7ab      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
9000349c:	f44f 6000 	mov.w	r0, #2048	; 0x800
900034a0:	e7a8      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_COM_CRC_FAILED;
900034a2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
900034a6:	e7a5      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ILLEGAL_CMD;
900034a8:	f44f 5000 	mov.w	r0, #8192	; 0x2000
900034ac:	e7a2      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CARD_ECC_FAILED;
900034ae:	f44f 4080 	mov.w	r0, #16384	; 0x4000
900034b2:	e79f      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CC_ERR;
900034b4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
900034b8:	e79c      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
900034ba:	f44f 3000 	mov.w	r0, #131072	; 0x20000
900034be:	e799      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
900034c0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
900034c4:	e796      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
900034c6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
900034ca:	e793      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_WP_ERASE_SKIP;
900034cc:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
900034d0:	e790      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
900034d2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
900034d6:	e78d      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
    return SDMMC_ERROR_ERASE_RESET;
900034d8:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
900034dc:	e78a      	b.n	900033f4 <SDMMC_GetCmdResp1+0x2c>
900034de:	bf00      	nop
900034e0:	2000002c 	.word	0x2000002c
900034e4:	fdffe008 	.word	0xfdffe008

900034e8 <SDMMC_Init>:
{
900034e8:	b084      	sub	sp, #16
900034ea:	b510      	push	{r4, lr}
900034ec:	ac03      	add	r4, sp, #12
900034ee:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  tmpreg |= (Init.ClockEdge           |\
900034f2:	460b      	mov	r3, r1
900034f4:	9904      	ldr	r1, [sp, #16]
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
900034f6:	6842      	ldr	r2, [r0, #4]
  tmpreg |= (Init.ClockEdge           |\
900034f8:	430b      	orrs	r3, r1
             Init.ClockBypass         |\
900034fa:	9905      	ldr	r1, [sp, #20]
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
900034fc:	f422 42fd 	bic.w	r2, r2, #32384	; 0x7e80
             Init.ClockBypass         |\
90003500:	430b      	orrs	r3, r1
             Init.ClockPowerSave      |\
90003502:	9906      	ldr	r1, [sp, #24]
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
90003504:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
             Init.ClockPowerSave      |\
90003508:	430b      	orrs	r3, r1
             Init.BusWide             |\
9000350a:	9907      	ldr	r1, [sp, #28]
9000350c:	430b      	orrs	r3, r1
             Init.HardwareFlowControl |\
9000350e:	9908      	ldr	r1, [sp, #32]
90003510:	430b      	orrs	r3, r1
}
90003512:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
90003516:	4313      	orrs	r3, r2
}
90003518:	b004      	add	sp, #16
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
9000351a:	6043      	str	r3, [r0, #4]
}
9000351c:	2000      	movs	r0, #0
9000351e:	4770      	bx	lr

90003520 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
90003520:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
90003524:	4770      	bx	lr

90003526 <SDMMC_WriteFIFO>:
  SDMMCx->FIFO = *pWriteData;
90003526:	680b      	ldr	r3, [r1, #0]
90003528:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
}
9000352c:	2000      	movs	r0, #0
9000352e:	4770      	bx	lr

90003530 <SDMMC_PowerState_ON>:
{  
90003530:	b508      	push	{r3, lr}
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
90003532:	2303      	movs	r3, #3
90003534:	6003      	str	r3, [r0, #0]
  HAL_Delay(2);
90003536:	2002      	movs	r0, #2
90003538:	f7fd ff24 	bl	90001384 <HAL_Delay>
}
9000353c:	2000      	movs	r0, #0
9000353e:	bd08      	pop	{r3, pc}

90003540 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
90003540:	6800      	ldr	r0, [r0, #0]
}
90003542:	f000 0003 	and.w	r0, r0, #3
90003546:	4770      	bx	lr

90003548 <SDMMC_SendCommand>:
  SDMMCx->ARG = Command->Argument;
90003548:	680b      	ldr	r3, [r1, #0]
{
9000354a:	b510      	push	{r4, lr}
  SDMMCx->ARG = Command->Argument;
9000354c:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
9000354e:	68c2      	ldr	r2, [r0, #12]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
90003550:	e9d1 3401 	ldrd	r3, r4, [r1, #4]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
90003554:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
90003558:	4323      	orrs	r3, r4
                       Command->Response         |\
9000355a:	68cc      	ldr	r4, [r1, #12]
                       Command->WaitForInterrupt |\
9000355c:	6909      	ldr	r1, [r1, #16]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
9000355e:	f022 020f 	bic.w	r2, r2, #15
                       Command->Response         |\
90003562:	4323      	orrs	r3, r4
                       Command->WaitForInterrupt |\
90003564:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
90003566:	4313      	orrs	r3, r2
90003568:	60c3      	str	r3, [r0, #12]
}
9000356a:	2000      	movs	r0, #0
9000356c:	bd10      	pop	{r4, pc}

9000356e <SDMMC_GetResponse>:
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
9000356e:	3014      	adds	r0, #20
  return (*(__IO uint32_t *) tmp);
90003570:	5840      	ldr	r0, [r0, r1]
}  
90003572:	4770      	bx	lr

90003574 <SDMMC_ConfigData>:
  SDMMCx->DTIMER = Data->DataTimeOut;
90003574:	680b      	ldr	r3, [r1, #0]
{
90003576:	b510      	push	{r4, lr}
  SDMMCx->DTIMER = Data->DataTimeOut;
90003578:	6243      	str	r3, [r0, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
9000357a:	684b      	ldr	r3, [r1, #4]
9000357c:	6283      	str	r3, [r0, #40]	; 0x28
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
9000357e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
90003580:	e9d1 3402 	ldrd	r3, r4, [r1, #8]
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
90003584:	f022 02f7 	bic.w	r2, r2, #247	; 0xf7
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
90003588:	4323      	orrs	r3, r4
                       Data->TransferDir   |\
9000358a:	690c      	ldr	r4, [r1, #16]
                       Data->TransferMode  |\
9000358c:	6949      	ldr	r1, [r1, #20]
                       Data->TransferDir   |\
9000358e:	4323      	orrs	r3, r4
                       Data->TransferMode  |\
90003590:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
90003592:	4313      	orrs	r3, r2
90003594:	62c3      	str	r3, [r0, #44]	; 0x2c
}
90003596:	2000      	movs	r0, #0
90003598:	bd10      	pop	{r4, pc}

9000359a <SDMMC_CmdBlockLength>:
{
9000359a:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000359c:	2340      	movs	r3, #64	; 0x40
{
9000359e:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900035a0:	2510      	movs	r5, #16
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900035a2:	2200      	movs	r2, #0
{
900035a4:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
900035a6:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900035a8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900035aa:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900035ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
900035b2:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900035b6:	f7ff ffc7 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
900035ba:	f241 3288 	movw	r2, #5000	; 0x1388
900035be:	4629      	mov	r1, r5
900035c0:	4620      	mov	r0, r4
900035c2:	f7ff ff01 	bl	900033c8 <SDMMC_GetCmdResp1>
}
900035c6:	b007      	add	sp, #28
900035c8:	bd30      	pop	{r4, r5, pc}

900035ca <SDMMC_CmdReadSingleBlock>:
{
900035ca:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900035cc:	2340      	movs	r3, #64	; 0x40
{
900035ce:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900035d0:	2511      	movs	r5, #17
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900035d2:	2200      	movs	r2, #0
{
900035d4:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
900035d6:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900035d8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900035da:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900035de:	f44f 6380 	mov.w	r3, #1024	; 0x400
900035e2:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900035e6:	f7ff ffaf 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
900035ea:	f241 3288 	movw	r2, #5000	; 0x1388
900035ee:	4629      	mov	r1, r5
900035f0:	4620      	mov	r0, r4
900035f2:	f7ff fee9 	bl	900033c8 <SDMMC_GetCmdResp1>
}
900035f6:	b007      	add	sp, #28
900035f8:	bd30      	pop	{r4, r5, pc}

900035fa <SDMMC_CmdReadMultiBlock>:
{
900035fa:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900035fc:	2340      	movs	r3, #64	; 0x40
{
900035fe:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003600:	2512      	movs	r5, #18
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003602:	2200      	movs	r2, #0
{
90003604:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
90003606:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003608:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000360a:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000360e:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003612:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003616:	f7ff ff97 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
9000361a:	f241 3288 	movw	r2, #5000	; 0x1388
9000361e:	4629      	mov	r1, r5
90003620:	4620      	mov	r0, r4
90003622:	f7ff fed1 	bl	900033c8 <SDMMC_GetCmdResp1>
}
90003626:	b007      	add	sp, #28
90003628:	bd30      	pop	{r4, r5, pc}

9000362a <SDMMC_CmdWriteSingleBlock>:
{
9000362a:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000362c:	2340      	movs	r3, #64	; 0x40
{
9000362e:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003630:	2518      	movs	r5, #24
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003632:	2200      	movs	r2, #0
{
90003634:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
90003636:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003638:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000363a:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000363e:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003642:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003646:	f7ff ff7f 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
9000364a:	f241 3288 	movw	r2, #5000	; 0x1388
9000364e:	4629      	mov	r1, r5
90003650:	4620      	mov	r0, r4
90003652:	f7ff feb9 	bl	900033c8 <SDMMC_GetCmdResp1>
}
90003656:	b007      	add	sp, #28
90003658:	bd30      	pop	{r4, r5, pc}

9000365a <SDMMC_CmdWriteMultiBlock>:
{
9000365a:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000365c:	2340      	movs	r3, #64	; 0x40
{
9000365e:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003660:	2519      	movs	r5, #25
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003662:	2200      	movs	r2, #0
{
90003664:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
90003666:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003668:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000366a:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000366e:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003672:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003676:	f7ff ff67 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
9000367a:	f241 3288 	movw	r2, #5000	; 0x1388
9000367e:	4629      	mov	r1, r5
90003680:	4620      	mov	r0, r4
90003682:	f7ff fea1 	bl	900033c8 <SDMMC_GetCmdResp1>
}
90003686:	b007      	add	sp, #28
90003688:	bd30      	pop	{r4, r5, pc}
	...

9000368c <SDMMC_CmdStopTransfer>:
{
9000368c:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
9000368e:	2300      	movs	r3, #0
{
90003690:	b087      	sub	sp, #28
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
90003692:	250c      	movs	r5, #12
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003694:	2240      	movs	r2, #64	; 0x40
{
90003696:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003698:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000369a:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
9000369e:	e9cd 3501 	strd	r3, r5, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900036a2:	f44f 6380 	mov.w	r3, #1024	; 0x400
900036a6:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900036a8:	f7ff ff4e 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
900036ac:	4a03      	ldr	r2, [pc, #12]	; (900036bc <SDMMC_CmdStopTransfer+0x30>)
900036ae:	4629      	mov	r1, r5
900036b0:	4620      	mov	r0, r4
900036b2:	f7ff fe89 	bl	900033c8 <SDMMC_GetCmdResp1>
}
900036b6:	b007      	add	sp, #28
900036b8:	bd30      	pop	{r4, r5, pc}
900036ba:	bf00      	nop
900036bc:	05f5e100 	.word	0x05f5e100

900036c0 <SDMMC_CmdSelDesel>:
{
900036c0:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900036c2:	2340      	movs	r3, #64	; 0x40
{
900036c4:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900036c6:	2507      	movs	r5, #7
{
900036c8:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
900036ca:	9201      	str	r2, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900036cc:	2200      	movs	r2, #0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900036ce:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900036d0:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900036d4:	f44f 6380 	mov.w	r3, #1024	; 0x400
900036d8:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900036dc:	f7ff ff34 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
900036e0:	f241 3288 	movw	r2, #5000	; 0x1388
900036e4:	4629      	mov	r1, r5
900036e6:	4620      	mov	r0, r4
900036e8:	f7ff fe6e 	bl	900033c8 <SDMMC_GetCmdResp1>
}
900036ec:	b007      	add	sp, #28
900036ee:	bd30      	pop	{r4, r5, pc}

900036f0 <SDMMC_CmdGoIdleState>:
{
900036f0:	b510      	push	{r4, lr}
  sdmmc_cmdinit.Argument         = 0U;
900036f2:	2300      	movs	r3, #0
{
900036f4:	b086      	sub	sp, #24
900036f6:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900036f8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
900036fa:	e9cd 3301 	strd	r3, r3, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900036fe:	e9cd 3303 	strd	r3, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003702:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003706:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003708:	f7ff ff1e 	bl	90003548 <SDMMC_SendCommand>
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
9000370c:	4b0a      	ldr	r3, [pc, #40]	; (90003738 <SDMMC_CmdGoIdleState+0x48>)
9000370e:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
90003712:	681b      	ldr	r3, [r3, #0]
90003714:	fbb3 f2f2 	udiv	r2, r3, r2
90003718:	f241 3388 	movw	r3, #5000	; 0x1388
9000371c:	4353      	muls	r3, r2
    if (count-- == 0U)
9000371e:	3b01      	subs	r3, #1
90003720:	d307      	bcc.n	90003732 <SDMMC_CmdGoIdleState+0x42>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
90003722:	6b62      	ldr	r2, [r4, #52]	; 0x34
90003724:	0612      	lsls	r2, r2, #24
90003726:	d5fa      	bpl.n	9000371e <SDMMC_CmdGoIdleState+0x2e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90003728:	23c5      	movs	r3, #197	; 0xc5
  return SDMMC_ERROR_NONE;
9000372a:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
9000372c:	63a3      	str	r3, [r4, #56]	; 0x38
}
9000372e:	b006      	add	sp, #24
90003730:	bd10      	pop	{r4, pc}
      return SDMMC_ERROR_TIMEOUT;
90003732:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  return errorstate;
90003736:	e7fa      	b.n	9000372e <SDMMC_CmdGoIdleState+0x3e>
90003738:	2000002c 	.word	0x2000002c

9000373c <SDMMC_CmdOperCond>:
{
9000373c:	b510      	push	{r4, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
9000373e:	f44f 7cd5 	mov.w	ip, #426	; 0x1aa
{
90003742:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
90003744:	2308      	movs	r3, #8
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90003746:	f04f 0e40 	mov.w	lr, #64	; 0x40
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000374a:	a901      	add	r1, sp, #4
{
9000374c:	4604      	mov	r4, r0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
9000374e:	e9cd c301 	strd	ip, r3, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90003752:	2300      	movs	r3, #0
90003754:	e9cd e303 	strd	lr, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003758:	f44f 6380 	mov.w	r3, #1024	; 0x400
9000375c:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000375e:	f7ff fef3 	bl	90003548 <SDMMC_SendCommand>
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
90003762:	4b13      	ldr	r3, [pc, #76]	; (900037b0 <SDMMC_CmdOperCond+0x74>)
90003764:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
90003768:	681b      	ldr	r3, [r3, #0]
9000376a:	fbb3 f2f2 	udiv	r2, r3, r2
9000376e:	f241 3388 	movw	r3, #5000	; 0x1388
90003772:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
90003774:	3b01      	subs	r3, #1
90003776:	d318      	bcc.n	900037aa <SDMMC_CmdOperCond+0x6e>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
90003778:	6b62      	ldr	r2, [r4, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
9000377a:	f012 0f45 	tst.w	r2, #69	; 0x45
9000377e:	d0f9      	beq.n	90003774 <SDMMC_CmdOperCond+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90003780:	0511      	lsls	r1, r2, #20
90003782:	d4f7      	bmi.n	90003774 <SDMMC_CmdOperCond+0x38>
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90003784:	6b63      	ldr	r3, [r4, #52]	; 0x34
90003786:	075a      	lsls	r2, r3, #29
90003788:	d503      	bpl.n	90003792 <SDMMC_CmdOperCond+0x56>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
9000378a:	2004      	movs	r0, #4
9000378c:	63a0      	str	r0, [r4, #56]	; 0x38
}
9000378e:	b006      	add	sp, #24
90003790:	bd10      	pop	{r4, pc}
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90003792:	6b60      	ldr	r0, [r4, #52]	; 0x34
90003794:	f010 0001 	ands.w	r0, r0, #1
90003798:	d002      	beq.n	900037a0 <SDMMC_CmdOperCond+0x64>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
9000379a:	2301      	movs	r3, #1
  }
  
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
9000379c:	63a3      	str	r3, [r4, #56]	; 0x38
9000379e:	e7f6      	b.n	9000378e <SDMMC_CmdOperCond+0x52>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
900037a0:	6b63      	ldr	r3, [r4, #52]	; 0x34
900037a2:	065b      	lsls	r3, r3, #25
900037a4:	d5f3      	bpl.n	9000378e <SDMMC_CmdOperCond+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
900037a6:	2340      	movs	r3, #64	; 0x40
900037a8:	e7f8      	b.n	9000379c <SDMMC_CmdOperCond+0x60>
      return SDMMC_ERROR_TIMEOUT;
900037aa:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
900037ae:	e7ee      	b.n	9000378e <SDMMC_CmdOperCond+0x52>
900037b0:	2000002c 	.word	0x2000002c

900037b4 <SDMMC_CmdAppCommand>:
{
900037b4:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900037b6:	2340      	movs	r3, #64	; 0x40
{
900037b8:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900037ba:	2537      	movs	r5, #55	; 0x37
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900037bc:	2200      	movs	r2, #0
{
900037be:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
900037c0:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900037c2:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900037c4:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900037c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
900037cc:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900037d0:	f7ff feba 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
900037d4:	f241 3288 	movw	r2, #5000	; 0x1388
900037d8:	4629      	mov	r1, r5
900037da:	4620      	mov	r0, r4
900037dc:	f7ff fdf4 	bl	900033c8 <SDMMC_GetCmdResp1>
}
900037e0:	b007      	add	sp, #28
900037e2:	bd30      	pop	{r4, r5, pc}

900037e4 <SDMMC_CmdAppOperCommand>:
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
900037e4:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900037e8:	2229      	movs	r2, #41	; 0x29
900037ea:	2340      	movs	r3, #64	; 0x40
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
900037ec:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
{
900037f0:	b510      	push	{r4, lr}
900037f2:	b086      	sub	sp, #24
900037f4:	4604      	mov	r4, r0
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900037f6:	e9cd 2302 	strd	r2, r3, [sp, #8]
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
900037fa:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900037fc:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003800:	2100      	movs	r1, #0
90003802:	e9cd 1304 	strd	r1, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003806:	a901      	add	r1, sp, #4
90003808:	f7ff fe9e 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
9000380c:	4620      	mov	r0, r4
9000380e:	f7ff fdb9 	bl	90003384 <SDMMC_GetCmdResp3>
}
90003812:	b006      	add	sp, #24
90003814:	bd10      	pop	{r4, pc}

90003816 <SDMMC_CmdBusWidth>:
{
90003816:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003818:	2340      	movs	r3, #64	; 0x40
{
9000381a:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000381c:	2506      	movs	r5, #6
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000381e:	2200      	movs	r2, #0
{
90003820:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
90003822:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003824:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003826:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000382a:	f44f 6380 	mov.w	r3, #1024	; 0x400
9000382e:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003832:	f7ff fe89 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
90003836:	f241 3288 	movw	r2, #5000	; 0x1388
9000383a:	4629      	mov	r1, r5
9000383c:	4620      	mov	r0, r4
9000383e:	f7ff fdc3 	bl	900033c8 <SDMMC_GetCmdResp1>
}
90003842:	b007      	add	sp, #28
90003844:	bd30      	pop	{r4, r5, pc}

90003846 <SDMMC_CmdSendSCR>:
{
90003846:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
90003848:	2300      	movs	r3, #0
{
9000384a:	b087      	sub	sp, #28
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
9000384c:	2533      	movs	r5, #51	; 0x33
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000384e:	2240      	movs	r2, #64	; 0x40
{
90003850:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003852:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90003854:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
90003858:	e9cd 3501 	strd	r3, r5, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000385c:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003860:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003862:	f7ff fe71 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
90003866:	f241 3288 	movw	r2, #5000	; 0x1388
9000386a:	4629      	mov	r1, r5
9000386c:	4620      	mov	r0, r4
9000386e:	f7ff fdab 	bl	900033c8 <SDMMC_GetCmdResp1>
}
90003872:	b007      	add	sp, #28
90003874:	bd30      	pop	{r4, r5, pc}

90003876 <SDMMC_CmdSendCID>:
{
90003876:	b510      	push	{r4, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
90003878:	2300      	movs	r3, #0
{
9000387a:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
9000387c:	2202      	movs	r2, #2
{
9000387e:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003880:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
90003882:	e9cd 3201 	strd	r3, r2, [sp, #4]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
90003886:	22c0      	movs	r2, #192	; 0xc0
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90003888:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000388c:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003890:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90003892:	f7ff fe59 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
90003896:	4620      	mov	r0, r4
90003898:	f7ff fd4e 	bl	90003338 <SDMMC_GetCmdResp2>
}
9000389c:	b006      	add	sp, #24
9000389e:	bd10      	pop	{r4, pc}

900038a0 <SDMMC_CmdSendCSD>:
{
900038a0:	b510      	push	{r4, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900038a2:	2209      	movs	r2, #9
{
900038a4:	b086      	sub	sp, #24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900038a6:	23c0      	movs	r3, #192	; 0xc0
{
900038a8:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
900038aa:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900038ac:	2100      	movs	r1, #0
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900038ae:	e9cd 2302 	strd	r2, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900038b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
900038b6:	e9cd 1304 	strd	r1, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900038ba:	a901      	add	r1, sp, #4
900038bc:	f7ff fe44 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
900038c0:	4620      	mov	r0, r4
900038c2:	f7ff fd39 	bl	90003338 <SDMMC_GetCmdResp2>
}
900038c6:	b006      	add	sp, #24
900038c8:	bd10      	pop	{r4, pc}
	...

900038cc <SDMMC_CmdSetRelAdd>:
{
900038cc:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
900038ce:	2300      	movs	r3, #0
{
900038d0:	b087      	sub	sp, #28
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
900038d2:	2203      	movs	r2, #3
{
900038d4:	460d      	mov	r5, r1
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900038d6:	a901      	add	r1, sp, #4
{
900038d8:	4604      	mov	r4, r0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
900038da:	e9cd 3201 	strd	r3, r2, [sp, #4]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900038de:	2240      	movs	r2, #64	; 0x40
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900038e0:	e9cd 2303 	strd	r2, r3, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900038e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
900038e8:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900038ea:	f7ff fe2d 	bl	90003548 <SDMMC_SendCommand>
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
900038ee:	4b1f      	ldr	r3, [pc, #124]	; (9000396c <SDMMC_CmdSetRelAdd+0xa0>)
900038f0:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
900038f4:	681b      	ldr	r3, [r3, #0]
900038f6:	fbb3 f2f2 	udiv	r2, r3, r2
900038fa:	f241 3388 	movw	r3, #5000	; 0x1388
900038fe:	4353      	muls	r3, r2
    if (count-- == 0U)
90003900:	3b01      	subs	r3, #1
90003902:	d32a      	bcc.n	9000395a <SDMMC_CmdSetRelAdd+0x8e>
    sta_reg = SDMMCx->STA;
90003904:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
90003906:	f012 0f45 	tst.w	r2, #69	; 0x45
9000390a:	d0f9      	beq.n	90003900 <SDMMC_CmdSetRelAdd+0x34>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
9000390c:	0510      	lsls	r0, r2, #20
9000390e:	d4f7      	bmi.n	90003900 <SDMMC_CmdSetRelAdd+0x34>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90003910:	6b63      	ldr	r3, [r4, #52]	; 0x34
90003912:	0759      	lsls	r1, r3, #29
90003914:	d503      	bpl.n	9000391e <SDMMC_CmdSetRelAdd+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90003916:	2004      	movs	r0, #4
90003918:	63a0      	str	r0, [r4, #56]	; 0x38
}
9000391a:	b007      	add	sp, #28
9000391c:	bd30      	pop	{r4, r5, pc}
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
9000391e:	6b60      	ldr	r0, [r4, #52]	; 0x34
90003920:	f010 0001 	ands.w	r0, r0, #1
90003924:	d002      	beq.n	9000392c <SDMMC_CmdSetRelAdd+0x60>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
90003926:	2301      	movs	r3, #1
90003928:	63a3      	str	r3, [r4, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
9000392a:	e7f6      	b.n	9000391a <SDMMC_CmdSetRelAdd+0x4e>
  return (uint8_t)(SDMMCx->RESPCMD);
9000392c:	6923      	ldr	r3, [r4, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
9000392e:	b2db      	uxtb	r3, r3
90003930:	2b03      	cmp	r3, #3
90003932:	d115      	bne.n	90003960 <SDMMC_CmdSetRelAdd+0x94>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90003934:	23c5      	movs	r3, #197	; 0xc5
90003936:	63a3      	str	r3, [r4, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
90003938:	6963      	ldr	r3, [r4, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
9000393a:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
9000393e:	d102      	bne.n	90003946 <SDMMC_CmdSetRelAdd+0x7a>
    *pRCA = (uint16_t) (response_r1 >> 16);
90003940:	0c1b      	lsrs	r3, r3, #16
90003942:	802b      	strh	r3, [r5, #0]
    return SDMMC_ERROR_NONE;
90003944:	e7e9      	b.n	9000391a <SDMMC_CmdSetRelAdd+0x4e>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
90003946:	045a      	lsls	r2, r3, #17
90003948:	d40c      	bmi.n	90003964 <SDMMC_CmdSetRelAdd+0x98>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
9000394a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
9000394e:	bf14      	ite	ne
90003950:	f44f 5080 	movne.w	r0, #4096	; 0x1000
90003954:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
90003958:	e7df      	b.n	9000391a <SDMMC_CmdSetRelAdd+0x4e>
      return SDMMC_ERROR_TIMEOUT;
9000395a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
9000395e:	e7dc      	b.n	9000391a <SDMMC_CmdSetRelAdd+0x4e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
90003960:	2001      	movs	r0, #1
90003962:	e7da      	b.n	9000391a <SDMMC_CmdSetRelAdd+0x4e>
    return SDMMC_ERROR_ILLEGAL_CMD;
90003964:	f44f 5000 	mov.w	r0, #8192	; 0x2000
90003968:	e7d7      	b.n	9000391a <SDMMC_CmdSetRelAdd+0x4e>
9000396a:	bf00      	nop
9000396c:	2000002c 	.word	0x2000002c

90003970 <SDMMC_CmdSendStatus>:
{
90003970:	b530      	push	{r4, r5, lr}
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003972:	2340      	movs	r3, #64	; 0x40
{
90003974:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003976:	250d      	movs	r5, #13
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003978:	2200      	movs	r2, #0
{
9000397a:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
9000397c:	9101      	str	r1, [sp, #4]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000397e:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90003980:	e9cd 5302 	strd	r5, r3, [sp, #8]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90003984:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003988:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000398c:	f7ff fddc 	bl	90003548 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
90003990:	f241 3288 	movw	r2, #5000	; 0x1388
90003994:	4629      	mov	r1, r5
90003996:	4620      	mov	r0, r4
90003998:	f7ff fd16 	bl	900033c8 <SDMMC_GetCmdResp1>
}
9000399c:	b007      	add	sp, #28
9000399e:	bd30      	pop	{r4, r5, pc}

900039a0 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
900039a0:	4b03      	ldr	r3, [pc, #12]	; (900039b0 <disk_status+0x10>)
900039a2:	181a      	adds	r2, r3, r0
900039a4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
900039a8:	6843      	ldr	r3, [r0, #4]
900039aa:	7b10      	ldrb	r0, [r2, #12]
900039ac:	685b      	ldr	r3, [r3, #4]
900039ae:	4718      	bx	r3
900039b0:	20000434 	.word	0x20000434

900039b4 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
900039b4:	4b06      	ldr	r3, [pc, #24]	; (900039d0 <disk_initialize+0x1c>)
900039b6:	5c1a      	ldrb	r2, [r3, r0]
900039b8:	b942      	cbnz	r2, 900039cc <disk_initialize+0x18>
  {
    disk.is_initialized[pdrv] = 1;
900039ba:	2201      	movs	r2, #1
900039bc:	541a      	strb	r2, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
900039be:	181a      	adds	r2, r3, r0
900039c0:	eb03 0380 	add.w	r3, r3, r0, lsl #2
900039c4:	7b10      	ldrb	r0, [r2, #12]
900039c6:	685b      	ldr	r3, [r3, #4]
900039c8:	681b      	ldr	r3, [r3, #0]
900039ca:	4718      	bx	r3
  }
  return stat;
}
900039cc:	2000      	movs	r0, #0
900039ce:	4770      	bx	lr
900039d0:	20000434 	.word	0x20000434

900039d4 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
900039d4:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
900039d6:	4c05      	ldr	r4, [pc, #20]	; (900039ec <disk_read+0x18>)
900039d8:	1825      	adds	r5, r4, r0
900039da:	eb04 0080 	add.w	r0, r4, r0, lsl #2
900039de:	6840      	ldr	r0, [r0, #4]
900039e0:	6884      	ldr	r4, [r0, #8]
900039e2:	7b28      	ldrb	r0, [r5, #12]
900039e4:	46a4      	mov	ip, r4
  return res;
}
900039e6:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
900039e8:	4760      	bx	ip
900039ea:	bf00      	nop
900039ec:	20000434 	.word	0x20000434

900039f0 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
900039f0:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
900039f2:	4c05      	ldr	r4, [pc, #20]	; (90003a08 <disk_write+0x18>)
900039f4:	1825      	adds	r5, r4, r0
900039f6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
900039fa:	6840      	ldr	r0, [r0, #4]
900039fc:	68c4      	ldr	r4, [r0, #12]
900039fe:	7b28      	ldrb	r0, [r5, #12]
90003a00:	46a4      	mov	ip, r4
  return res;
}
90003a02:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
90003a04:	4760      	bx	ip
90003a06:	bf00      	nop
90003a08:	20000434 	.word	0x20000434

90003a0c <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
90003a0c:	4b05      	ldr	r3, [pc, #20]	; (90003a24 <disk_ioctl+0x18>)
{
90003a0e:	b410      	push	{r4}
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
90003a10:	181c      	adds	r4, r3, r0
90003a12:	eb03 0080 	add.w	r0, r3, r0, lsl #2
90003a16:	6843      	ldr	r3, [r0, #4]
90003a18:	7b20      	ldrb	r0, [r4, #12]
90003a1a:	691b      	ldr	r3, [r3, #16]
  return res;
}
90003a1c:	f85d 4b04 	ldr.w	r4, [sp], #4
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
90003a20:	4718      	bx	r3
90003a22:	bf00      	nop
90003a24:	20000434 	.word	0x20000434

90003a28 <get_fattime>:
  * @retval Time in DWORD
  */
__weak DWORD get_fattime (void)
{
  return 0;
}
90003a28:	2000      	movs	r0, #0
90003a2a:	4770      	bx	lr

90003a2c <ld_dword>:
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
	DWORD rv;

	rv = ptr[3];
	rv = rv << 8 | ptr[2];
90003a2c:	8842      	ldrh	r2, [r0, #2]
	rv = rv << 8 | ptr[1];
90003a2e:	7843      	ldrb	r3, [r0, #1]
	rv = rv << 8 | ptr[0];
90003a30:	7800      	ldrb	r0, [r0, #0]
	rv = rv << 8 | ptr[1];
90003a32:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	return rv;
}
90003a36:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
90003a3a:	4770      	bx	lr

90003a3c <st_dword>:
}

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
	*ptr++ = (BYTE)val; val >>= 8;
90003a3c:	0a0b      	lsrs	r3, r1, #8
90003a3e:	7001      	strb	r1, [r0, #0]
	*ptr++ = (BYTE)val; val >>= 8;
90003a40:	7043      	strb	r3, [r0, #1]
90003a42:	0c0b      	lsrs	r3, r1, #16
	*ptr++ = (BYTE)val; val >>= 8;
90003a44:	0e09      	lsrs	r1, r1, #24
90003a46:	7083      	strb	r3, [r0, #2]
	*ptr++ = (BYTE)val;
90003a48:	70c1      	strb	r1, [r0, #3]
}
90003a4a:	4770      	bx	lr

90003a4c <mem_set>:
}

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
90003a4c:	4402      	add	r2, r0

	do {
		*d++ = (BYTE)val;
90003a4e:	f800 1b01 	strb.w	r1, [r0], #1
	} while (--cnt);
90003a52:	4290      	cmp	r0, r2
90003a54:	d1fb      	bne.n	90003a4e <mem_set+0x2>
}
90003a56:	4770      	bx	lr

90003a58 <chk_lock>:
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs) {	/* Existing entry */
90003a58:	4a1b      	ldr	r2, [pc, #108]	; (90003ac8 <chk_lock+0x70>)
90003a5a:	6813      	ldr	r3, [r2, #0]
{
90003a5c:	b530      	push	{r4, r5, lr}
		if (Files[i].fs) {	/* Existing entry */
90003a5e:	b163      	cbz	r3, 90003a7a <chk_lock+0x22>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
90003a60:	6804      	ldr	r4, [r0, #0]
90003a62:	429c      	cmp	r4, r3
90003a64:	d107      	bne.n	90003a76 <chk_lock+0x1e>
90003a66:	6854      	ldr	r4, [r2, #4]
90003a68:	6883      	ldr	r3, [r0, #8]
90003a6a:	429c      	cmp	r4, r3
90003a6c:	d103      	bne.n	90003a76 <chk_lock+0x1e>
				Files[i].clu == dp->obj.sclust &&
90003a6e:	6894      	ldr	r4, [r2, #8]
90003a70:	6943      	ldr	r3, [r0, #20]
90003a72:	429c      	cmp	r4, r3
90003a74:	d020      	beq.n	90003ab8 <chk_lock+0x60>
	for (i = be = 0; i < _FS_LOCK; i++) {
90003a76:	2400      	movs	r4, #0
90003a78:	e000      	b.n	90003a7c <chk_lock+0x24>
				Files[i].ofs == dp->dptr) break;
		} else {			/* Blank entry */
			be = 1;
90003a7a:	2401      	movs	r4, #1
		if (Files[i].fs) {	/* Existing entry */
90003a7c:	6913      	ldr	r3, [r2, #16]
90003a7e:	b1cb      	cbz	r3, 90003ab4 <chk_lock+0x5c>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
90003a80:	6805      	ldr	r5, [r0, #0]
90003a82:	42ab      	cmp	r3, r5
90003a84:	d107      	bne.n	90003a96 <chk_lock+0x3e>
90003a86:	6955      	ldr	r5, [r2, #20]
90003a88:	6883      	ldr	r3, [r0, #8]
90003a8a:	429d      	cmp	r5, r3
90003a8c:	d103      	bne.n	90003a96 <chk_lock+0x3e>
				Files[i].clu == dp->obj.sclust &&
90003a8e:	6995      	ldr	r5, [r2, #24]
90003a90:	6943      	ldr	r3, [r0, #20]
90003a92:	429d      	cmp	r5, r3
90003a94:	d015      	beq.n	90003ac2 <chk_lock+0x6a>
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
90003a96:	b96c      	cbnz	r4, 90003ab4 <chk_lock+0x5c>
90003a98:	2902      	cmp	r1, #2
90003a9a:	bf0c      	ite	eq
90003a9c:	2000      	moveq	r0, #0
90003a9e:	2012      	movne	r0, #18
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
90003aa0:	bd30      	pop	{r4, r5, pc}
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
90003aa2:	eb02 1203 	add.w	r2, r2, r3, lsl #4
90003aa6:	8993      	ldrh	r3, [r2, #12]
90003aa8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90003aac:	bf14      	ite	ne
90003aae:	2000      	movne	r0, #0
90003ab0:	2010      	moveq	r0, #16
90003ab2:	e7f5      	b.n	90003aa0 <chk_lock+0x48>
90003ab4:	2000      	movs	r0, #0
90003ab6:	e7f3      	b.n	90003aa0 <chk_lock+0x48>
	for (i = be = 0; i < _FS_LOCK; i++) {
90003ab8:	2300      	movs	r3, #0
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
90003aba:	2900      	cmp	r1, #0
90003abc:	d0f1      	beq.n	90003aa2 <chk_lock+0x4a>
90003abe:	2010      	movs	r0, #16
90003ac0:	e7ee      	b.n	90003aa0 <chk_lock+0x48>
	for (i = be = 0; i < _FS_LOCK; i++) {
90003ac2:	2301      	movs	r3, #1
90003ac4:	e7f9      	b.n	90003aba <chk_lock+0x62>
90003ac6:	bf00      	nop
90003ac8:	20000408 	.word	0x20000408

90003acc <inc_lock>:
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->obj.fs &&
90003acc:	4a1f      	ldr	r2, [pc, #124]	; (90003b4c <inc_lock+0x80>)
{
90003ace:	b5f0      	push	{r4, r5, r6, r7, lr}
		if (Files[i].fs == dp->obj.fs &&
90003ad0:	6813      	ldr	r3, [r2, #0]
90003ad2:	6806      	ldr	r6, [r0, #0]
90003ad4:	429e      	cmp	r6, r3
90003ad6:	d107      	bne.n	90003ae8 <inc_lock+0x1c>
90003ad8:	6855      	ldr	r5, [r2, #4]
90003ada:	6884      	ldr	r4, [r0, #8]
90003adc:	42a5      	cmp	r5, r4
90003ade:	d103      	bne.n	90003ae8 <inc_lock+0x1c>
			Files[i].clu == dp->obj.sclust &&
90003ae0:	6945      	ldr	r5, [r0, #20]
90003ae2:	6894      	ldr	r4, [r2, #8]
90003ae4:	42a5      	cmp	r5, r4
90003ae6:	d01b      	beq.n	90003b20 <inc_lock+0x54>
		if (Files[i].fs == dp->obj.fs &&
90003ae8:	6914      	ldr	r4, [r2, #16]
90003aea:	42b4      	cmp	r4, r6
90003aec:	d107      	bne.n	90003afe <inc_lock+0x32>
90003aee:	6957      	ldr	r7, [r2, #20]
90003af0:	6885      	ldr	r5, [r0, #8]
90003af2:	42af      	cmp	r7, r5
90003af4:	d103      	bne.n	90003afe <inc_lock+0x32>
			Files[i].clu == dp->obj.sclust &&
90003af6:	6997      	ldr	r7, [r2, #24]
90003af8:	6945      	ldr	r5, [r0, #20]
90003afa:	42af      	cmp	r7, r5
90003afc:	d019      	beq.n	90003b32 <inc_lock+0x66>
			Files[i].ofs == dp->dptr) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
90003afe:	b10b      	cbz	r3, 90003b04 <inc_lock+0x38>
90003b00:	b9ac      	cbnz	r4, 90003b2e <inc_lock+0x62>
90003b02:	2301      	movs	r3, #1
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
		Files[i].fs = dp->obj.fs;
90003b04:	011d      	lsls	r5, r3, #4
90003b06:	eb02 1403 	add.w	r4, r2, r3, lsl #4
90003b0a:	5156      	str	r6, [r2, r5]
		Files[i].clu = dp->obj.sclust;
90003b0c:	6885      	ldr	r5, [r0, #8]
		Files[i].ofs = dp->dptr;
90003b0e:	6940      	ldr	r0, [r0, #20]
		Files[i].clu = dp->obj.sclust;
90003b10:	6065      	str	r5, [r4, #4]
		Files[i].ofs = dp->dptr;
90003b12:	60a0      	str	r0, [r4, #8]
		Files[i].ctr = 0;
90003b14:	2000      	movs	r0, #0
90003b16:	81a0      	strh	r0, [r4, #12]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
90003b18:	b169      	cbz	r1, 90003b36 <inc_lock+0x6a>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
90003b1a:	f44f 7180 	mov.w	r1, #256	; 0x100
90003b1e:	e00f      	b.n	90003b40 <inc_lock+0x74>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
90003b20:	2300      	movs	r3, #0
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
90003b22:	b141      	cbz	r1, 90003b36 <inc_lock+0x6a>
90003b24:	eb02 1103 	add.w	r1, r2, r3, lsl #4
90003b28:	8989      	ldrh	r1, [r1, #12]
90003b2a:	2900      	cmp	r1, #0
90003b2c:	d0f5      	beq.n	90003b1a <inc_lock+0x4e>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
90003b2e:	2000      	movs	r0, #0
90003b30:	e00a      	b.n	90003b48 <inc_lock+0x7c>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
90003b32:	2301      	movs	r3, #1
90003b34:	e7f5      	b.n	90003b22 <inc_lock+0x56>
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
90003b36:	eb02 1103 	add.w	r1, r2, r3, lsl #4
90003b3a:	8989      	ldrh	r1, [r1, #12]
90003b3c:	3101      	adds	r1, #1
90003b3e:	b289      	uxth	r1, r1
90003b40:	eb02 1203 	add.w	r2, r2, r3, lsl #4

	return i + 1;
90003b44:	1c58      	adds	r0, r3, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
90003b46:	8191      	strh	r1, [r2, #12]
}
90003b48:	bdf0      	pop	{r4, r5, r6, r7, pc}
90003b4a:	bf00      	nop
90003b4c:	20000408 	.word	0x20000408

90003b50 <dec_lock>:
{
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
90003b50:	3801      	subs	r0, #1
90003b52:	2801      	cmp	r0, #1
90003b54:	d815      	bhi.n	90003b82 <dec_lock+0x32>
		n = Files[i].ctr;
90003b56:	4a0c      	ldr	r2, [pc, #48]	; (90003b88 <dec_lock+0x38>)
90003b58:	0101      	lsls	r1, r0, #4
90003b5a:	eb02 1000 	add.w	r0, r2, r0, lsl #4
90003b5e:	8983      	ldrh	r3, [r0, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
90003b60:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90003b64:	d104      	bne.n	90003b70 <dec_lock+0x20>
		if (n > 0) n--;				/* Decrement read mode open count */
		Files[i].ctr = n;
90003b66:	2300      	movs	r3, #0
90003b68:	8183      	strh	r3, [r0, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
90003b6a:	2000      	movs	r0, #0
90003b6c:	5050      	str	r0, [r2, r1]
90003b6e:	4770      	bx	lr
		if (n > 0) n--;				/* Decrement read mode open count */
90003b70:	2b00      	cmp	r3, #0
90003b72:	d0fa      	beq.n	90003b6a <dec_lock+0x1a>
90003b74:	3b01      	subs	r3, #1
90003b76:	b29b      	uxth	r3, r3
		Files[i].ctr = n;
90003b78:	8183      	strh	r3, [r0, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
90003b7a:	2b00      	cmp	r3, #0
90003b7c:	d0f5      	beq.n	90003b6a <dec_lock+0x1a>
		res = FR_OK;
90003b7e:	2000      	movs	r0, #0
90003b80:	4770      	bx	lr
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
90003b82:	2002      	movs	r0, #2
	}
	return res;
}
90003b84:	4770      	bx	lr
90003b86:	bf00      	nop
90003b88:	20000408 	.word	0x20000408

90003b8c <clust2sect>:
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
90003b8c:	6983      	ldr	r3, [r0, #24]
	clst -= 2;
90003b8e:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
90003b90:	3b02      	subs	r3, #2
90003b92:	428b      	cmp	r3, r1
	return clst * fs->csize + fs->database;
90003b94:	bf83      	ittte	hi
90003b96:	8943      	ldrhhi	r3, [r0, #10]
90003b98:	6ac0      	ldrhi	r0, [r0, #44]	; 0x2c
90003b9a:	fb01 0003 	mlahi	r0, r1, r3, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
90003b9e:	2000      	movls	r0, #0
}
90003ba0:	4770      	bx	lr

90003ba2 <clmt_clust>:
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
90003ba2:	6802      	ldr	r2, [r0, #0]
90003ba4:	0a49      	lsrs	r1, r1, #9
	tbl = fp->cltbl + 1;	/* Top of CLMT */
90003ba6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
90003ba8:	8952      	ldrh	r2, [r2, #10]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
90003baa:	3304      	adds	r3, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
90003bac:	fbb1 f1f2 	udiv	r1, r1, r2
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
90003bb0:	6818      	ldr	r0, [r3, #0]
		if (ncl == 0) return 0;	/* End of table? (error) */
90003bb2:	b130      	cbz	r0, 90003bc2 <clmt_clust+0x20>
		if (cl < ncl) break;	/* In this fragment? */
90003bb4:	4281      	cmp	r1, r0
90003bb6:	d302      	bcc.n	90003bbe <clmt_clust+0x1c>
		cl -= ncl; tbl++;		/* Next fragment */
90003bb8:	1a09      	subs	r1, r1, r0
90003bba:	3308      	adds	r3, #8
		ncl = *tbl++;			/* Number of cluters in the fragment */
90003bbc:	e7f8      	b.n	90003bb0 <clmt_clust+0xe>
	}
	return cl + *tbl;	/* Return the cluster number */
90003bbe:	6858      	ldr	r0, [r3, #4]
90003bc0:	4408      	add	r0, r1
}
90003bc2:	4770      	bx	lr

90003bc4 <sum_sfn>:
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
	BYTE sum = 0;
	UINT n = 11;
90003bc4:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
90003bc8:	2200      	movs	r2, #0

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
90003bca:	01d3      	lsls	r3, r2, #7
90003bcc:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
90003bd0:	f810 2b01 	ldrb.w	r2, [r0], #1
90003bd4:	fa52 f383 	uxtab	r3, r2, r3
	} while (--n);
90003bd8:	4288      	cmp	r0, r1
		sum = (sum >> 1) + (sum << 7) + *dir++;
90003bda:	b2da      	uxtb	r2, r3
	} while (--n);
90003bdc:	d1f5      	bne.n	90003bca <sum_sfn+0x6>
	return sum;
}
90003bde:	4610      	mov	r0, r2
90003be0:	4770      	bx	lr

90003be2 <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
90003be2:	6803      	ldr	r3, [r0, #0]
{
90003be4:	4601      	mov	r1, r0
90003be6:	b510      	push	{r4, lr}
	if (*path) {	/* If the pointer is not a null */
90003be8:	b153      	cbz	r3, 90003c00 <get_ldnumber+0x1e>
90003bea:	4618      	mov	r0, r3
90003bec:	4602      	mov	r2, r0
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
90003bee:	f810 4b01 	ldrb.w	r4, [r0], #1
90003bf2:	2c1f      	cmp	r4, #31
90003bf4:	d910      	bls.n	90003c18 <get_ldnumber+0x36>
90003bf6:	2c3a      	cmp	r4, #58	; 0x3a
90003bf8:	d1f8      	bne.n	90003bec <get_ldnumber+0xa>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0';
90003bfa:	1c58      	adds	r0, r3, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
90003bfc:	4282      	cmp	r2, r0
90003bfe:	d002      	beq.n	90003c06 <get_ldnumber+0x24>
	int vol = -1;
90003c00:	f04f 30ff 	mov.w	r0, #4294967295
90003c04:	e007      	b.n	90003c16 <get_ldnumber+0x34>
			i = *tp++ - '0';
90003c06:	781b      	ldrb	r3, [r3, #0]
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
90003c08:	3b30      	subs	r3, #48	; 0x30
90003c0a:	b2d8      	uxtb	r0, r3
90003c0c:	2801      	cmp	r0, #1
90003c0e:	d8f7      	bhi.n	90003c00 <get_ldnumber+0x1e>
					vol = (int)i;
					*path = ++tt;
90003c10:	3201      	adds	r2, #1
			i = *tp++ - '0';
90003c12:	4618      	mov	r0, r3
					*path = ++tt;
90003c14:	600a      	str	r2, [r1, #0]
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
90003c16:	bd10      	pop	{r4, pc}
		vol = 0;		/* Drive 0 */
90003c18:	2000      	movs	r0, #0
90003c1a:	e7fc      	b.n	90003c16 <get_ldnumber+0x34>

90003c1c <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
90003c1c:	b538      	push	{r3, r4, r5, lr}
90003c1e:	460d      	mov	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
90003c20:	4604      	mov	r4, r0
90003c22:	b918      	cbnz	r0, 90003c2c <validate+0x10>
	FRESULT res = FR_INVALID_OBJECT;
90003c24:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
90003c26:	2300      	movs	r3, #0
90003c28:	602b      	str	r3, [r5, #0]
	return res;
}
90003c2a:	bd38      	pop	{r3, r4, r5, pc}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
90003c2c:	6803      	ldr	r3, [r0, #0]
90003c2e:	2b00      	cmp	r3, #0
90003c30:	d0f8      	beq.n	90003c24 <validate+0x8>
90003c32:	781a      	ldrb	r2, [r3, #0]
90003c34:	2a00      	cmp	r2, #0
90003c36:	d0f5      	beq.n	90003c24 <validate+0x8>
90003c38:	8881      	ldrh	r1, [r0, #4]
90003c3a:	88da      	ldrh	r2, [r3, #6]
90003c3c:	4291      	cmp	r1, r2
90003c3e:	d1f1      	bne.n	90003c24 <validate+0x8>
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
90003c40:	7858      	ldrb	r0, [r3, #1]
90003c42:	f7ff fead 	bl	900039a0 <disk_status>
90003c46:	f010 0001 	ands.w	r0, r0, #1
90003c4a:	d1eb      	bne.n	90003c24 <validate+0x8>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
90003c4c:	6823      	ldr	r3, [r4, #0]
90003c4e:	e7eb      	b.n	90003c28 <validate+0xc>

90003c50 <mem_cpy.part.0>:
void mem_cpy (void* dst, const void* src, UINT cnt) {
90003c50:	3801      	subs	r0, #1
90003c52:	440a      	add	r2, r1
			*d++ = *s++;
90003c54:	f811 3b01 	ldrb.w	r3, [r1], #1
		} while (--cnt);
90003c58:	4291      	cmp	r1, r2
			*d++ = *s++;
90003c5a:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
90003c5e:	d1f9      	bne.n	90003c54 <mem_cpy.part.0+0x4>
}
90003c60:	4770      	bx	lr

90003c62 <ld_clust.isra.0>:
	if (fs->fs_type == FS_FAT32) {
90003c62:	2803      	cmp	r0, #3
	rv = rv << 8 | ptr[0];
90003c64:	7eca      	ldrb	r2, [r1, #27]
90003c66:	7e8b      	ldrb	r3, [r1, #26]
90003c68:	bf08      	it	eq
90003c6a:	7d48      	ldrbeq	r0, [r1, #21]
	cl = ld_word(dir + DIR_FstClusLO);
90003c6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
90003c70:	bf02      	ittt	eq
90003c72:	7d0a      	ldrbeq	r2, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
90003c74:	ea42 2200 	orreq.w	r2, r2, r0, lsl #8
90003c78:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16
}
90003c7c:	4618      	mov	r0, r3
90003c7e:	4770      	bx	lr

90003c80 <st_clust.isra.0>:
	*ptr++ = (BYTE)val; val >>= 8;
90003c80:	f3c2 2307 	ubfx	r3, r2, #8, #8
90003c84:	768a      	strb	r2, [r1, #26]
	*ptr++ = (BYTE)val;
90003c86:	76cb      	strb	r3, [r1, #27]
	if (fs->fs_type == FS_FAT32) {
90003c88:	7803      	ldrb	r3, [r0, #0]
90003c8a:	2b03      	cmp	r3, #3
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
90003c8c:	bf01      	itttt	eq
90003c8e:	0c12      	lsreq	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
90003c90:	750a      	strbeq	r2, [r1, #20]
90003c92:	0a12      	lsreq	r2, r2, #8
	*ptr++ = (BYTE)val;
90003c94:	754a      	strbeq	r2, [r1, #21]
}
90003c96:	4770      	bx	lr

90003c98 <sync_window.part.0>:
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
90003c98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		wsect = fs->winsect;	/* Current sector number */
90003c9c:	6b06      	ldr	r6, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
90003c9e:	f100 0834 	add.w	r8, r0, #52	; 0x34
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
90003ca2:	4604      	mov	r4, r0
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
90003ca4:	2301      	movs	r3, #1
90003ca6:	4632      	mov	r2, r6
90003ca8:	4641      	mov	r1, r8
90003caa:	7840      	ldrb	r0, [r0, #1]
90003cac:	f7ff fea0 	bl	900039f0 <disk_write>
90003cb0:	4605      	mov	r5, r0
90003cb2:	b9a8      	cbnz	r0, 90003ce0 <sync_window.part.0+0x48>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
90003cb4:	6a63      	ldr	r3, [r4, #36]	; 0x24
90003cb6:	69e2      	ldr	r2, [r4, #28]
90003cb8:	1af3      	subs	r3, r6, r3
			fs->wflag = 0;
90003cba:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
90003cbc:	4293      	cmp	r3, r2
90003cbe:	d202      	bcs.n	90003cc6 <sync_window.part.0+0x2e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
90003cc0:	78a7      	ldrb	r7, [r4, #2]
90003cc2:	2f01      	cmp	r7, #1
90003cc4:	d802      	bhi.n	90003ccc <sync_window.part.0+0x34>
}
90003cc6:	4628      	mov	r0, r5
90003cc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					wsect += fs->fsize;
90003ccc:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
90003cce:	4641      	mov	r1, r8
90003cd0:	7860      	ldrb	r0, [r4, #1]
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
90003cd2:	3f01      	subs	r7, #1
					wsect += fs->fsize;
90003cd4:	441e      	add	r6, r3
					disk_write(fs->drv, fs->win, wsect, 1);
90003cd6:	2301      	movs	r3, #1
90003cd8:	4632      	mov	r2, r6
90003cda:	f7ff fe89 	bl	900039f0 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
90003cde:	e7f0      	b.n	90003cc2 <sync_window.part.0+0x2a>
			res = FR_DISK_ERR;
90003ce0:	2501      	movs	r5, #1
90003ce2:	e7f0      	b.n	90003cc6 <sync_window.part.0+0x2e>

90003ce4 <sync_window>:
	if (fs->wflag) {	/* Write back the sector if it is dirty */
90003ce4:	78c3      	ldrb	r3, [r0, #3]
90003ce6:	b10b      	cbz	r3, 90003cec <sync_window+0x8>
90003ce8:	f7ff bfd6 	b.w	90003c98 <sync_window.part.0>
}
90003cec:	4618      	mov	r0, r3
90003cee:	4770      	bx	lr

90003cf0 <move_window>:
{
90003cf0:	b538      	push	{r3, r4, r5, lr}
	if (sector != fs->winsect) {	/* Window offset changed? */
90003cf2:	6b03      	ldr	r3, [r0, #48]	; 0x30
{
90003cf4:	4605      	mov	r5, r0
90003cf6:	460c      	mov	r4, r1
	if (sector != fs->winsect) {	/* Window offset changed? */
90003cf8:	428b      	cmp	r3, r1
90003cfa:	d010      	beq.n	90003d1e <move_window+0x2e>
		res = sync_window(fs);		/* Write-back changes */
90003cfc:	f7ff fff2 	bl	90003ce4 <sync_window>
		if (res == FR_OK) {			/* Fill sector window with new data */
90003d00:	b960      	cbnz	r0, 90003d1c <move_window+0x2c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
90003d02:	4622      	mov	r2, r4
90003d04:	2301      	movs	r3, #1
90003d06:	f105 0134 	add.w	r1, r5, #52	; 0x34
90003d0a:	7868      	ldrb	r0, [r5, #1]
90003d0c:	f7ff fe62 	bl	900039d4 <disk_read>
				res = FR_DISK_ERR;
90003d10:	2800      	cmp	r0, #0
90003d12:	bf1c      	itt	ne
90003d14:	f04f 34ff 	movne.w	r4, #4294967295
90003d18:	2001      	movne	r0, #1
			fs->winsect = sector;
90003d1a:	632c      	str	r4, [r5, #48]	; 0x30
}
90003d1c:	bd38      	pop	{r3, r4, r5, pc}
	FRESULT res = FR_OK;
90003d1e:	2000      	movs	r0, #0
90003d20:	e7fc      	b.n	90003d1c <move_window+0x2c>
	...

90003d24 <check_fs>:
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
90003d24:	2300      	movs	r3, #0
{
90003d26:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
90003d28:	70c3      	strb	r3, [r0, #3]
90003d2a:	f04f 33ff 	mov.w	r3, #4294967295
{
90003d2e:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
90003d30:	6303      	str	r3, [r0, #48]	; 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
90003d32:	f7ff ffdd 	bl	90003cf0 <move_window>
90003d36:	4601      	mov	r1, r0
90003d38:	bb30      	cbnz	r0, 90003d88 <check_fs+0x64>
	rv = rv << 8 | ptr[0];
90003d3a:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
90003d3e:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
90003d42:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
90003d46:	f64a 2255 	movw	r2, #43605	; 0xaa55
90003d4a:	4293      	cmp	r3, r2
90003d4c:	d11e      	bne.n	90003d8c <check_fs+0x68>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
90003d4e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
90003d52:	2be9      	cmp	r3, #233	; 0xe9
90003d54:	d005      	beq.n	90003d62 <check_fs+0x3e>
90003d56:	6b63      	ldr	r3, [r4, #52]	; 0x34
90003d58:	4a0e      	ldr	r2, [pc, #56]	; (90003d94 <check_fs+0x70>)
90003d5a:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
90003d5e:	4293      	cmp	r3, r2
90003d60:	d116      	bne.n	90003d90 <check_fs+0x6c>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
90003d62:	f104 006a 	add.w	r0, r4, #106	; 0x6a
90003d66:	f7ff fe61 	bl	90003a2c <ld_dword>
90003d6a:	4b0b      	ldr	r3, [pc, #44]	; (90003d98 <check_fs+0x74>)
90003d6c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
90003d70:	4298      	cmp	r0, r3
90003d72:	d007      	beq.n	90003d84 <check_fs+0x60>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
90003d74:	f104 0086 	add.w	r0, r4, #134	; 0x86
90003d78:	f7ff fe58 	bl	90003a2c <ld_dword>
	return 2;
90003d7c:	4b07      	ldr	r3, [pc, #28]	; (90003d9c <check_fs+0x78>)
90003d7e:	4298      	cmp	r0, r3
90003d80:	bf18      	it	ne
90003d82:	2102      	movne	r1, #2
}
90003d84:	4608      	mov	r0, r1
90003d86:	bd10      	pop	{r4, pc}
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
90003d88:	2104      	movs	r1, #4
90003d8a:	e7fb      	b.n	90003d84 <check_fs+0x60>
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
90003d8c:	2103      	movs	r1, #3
90003d8e:	e7f9      	b.n	90003d84 <check_fs+0x60>
	return 2;
90003d90:	2102      	movs	r1, #2
90003d92:	e7f7      	b.n	90003d84 <check_fs+0x60>
90003d94:	009000eb 	.word	0x009000eb
90003d98:	00544146 	.word	0x00544146
90003d9c:	33544146 	.word	0x33544146

90003da0 <find_volume>:
	*rfs = 0;
90003da0:	2300      	movs	r3, #0
{
90003da2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*rfs = 0;
90003da6:	600b      	str	r3, [r1, #0]
{
90003da8:	b085      	sub	sp, #20
90003daa:	460d      	mov	r5, r1
90003dac:	4617      	mov	r7, r2
	vol = get_ldnumber(path);
90003dae:	f7ff ff18 	bl	90003be2 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
90003db2:	1e06      	subs	r6, r0, #0
90003db4:	f2c0 8151 	blt.w	9000405a <find_volume+0x2ba>
	fs = FatFs[vol];					/* Get pointer to the file system object */
90003db8:	4bac      	ldr	r3, [pc, #688]	; (9000406c <find_volume+0x2cc>)
90003dba:	eb03 0286 	add.w	r2, r3, r6, lsl #2
90003dbe:	4698      	mov	r8, r3
90003dc0:	6a14      	ldr	r4, [r2, #32]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
90003dc2:	2c00      	cmp	r4, #0
90003dc4:	f000 814b 	beq.w	9000405e <find_volume+0x2be>
	*rfs = fs;							/* Return pointer to the file system object */
90003dc8:	602c      	str	r4, [r5, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
90003dca:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	if (fs->fs_type) {					/* If the volume has been mounted */
90003dce:	7823      	ldrb	r3, [r4, #0]
90003dd0:	b17b      	cbz	r3, 90003df2 <find_volume+0x52>
		stat = disk_status(fs->drv);
90003dd2:	7860      	ldrb	r0, [r4, #1]
90003dd4:	f7ff fde4 	bl	900039a0 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
90003dd8:	07c1      	lsls	r1, r0, #31
90003dda:	d40a      	bmi.n	90003df2 <find_volume+0x52>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
90003ddc:	2f00      	cmp	r7, #0
90003dde:	f000 8140 	beq.w	90004062 <find_volume+0x2c2>
90003de2:	f010 0504 	ands.w	r5, r0, #4
90003de6:	d000      	beq.n	90003dea <find_volume+0x4a>
				return FR_WRITE_PROTECTED;
90003de8:	250a      	movs	r5, #10
}
90003dea:	4628      	mov	r0, r5
90003dec:	b005      	add	sp, #20
90003dee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	fs->fs_type = 0;					/* Clear the file system object */
90003df2:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
90003df4:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the file system object */
90003df6:	7023      	strb	r3, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
90003df8:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
90003dfa:	f7ff fddb 	bl	900039b4 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
90003dfe:	f010 0501 	ands.w	r5, r0, #1
90003e02:	f040 8130 	bne.w	90004066 <find_volume+0x2c6>
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
90003e06:	b10f      	cbz	r7, 90003e0c <find_volume+0x6c>
90003e08:	0742      	lsls	r2, r0, #29
90003e0a:	d4ed      	bmi.n	90003de8 <find_volume+0x48>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
90003e0c:	2100      	movs	r1, #0
90003e0e:	4620      	mov	r0, r4
90003e10:	f7ff ff88 	bl	90003d24 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
90003e14:	2802      	cmp	r0, #2
90003e16:	f040 8104 	bne.w	90004022 <find_volume+0x282>
90003e1a:	466e      	mov	r6, sp
90003e1c:	f504 71fd 	add.w	r1, r4, #506	; 0x1fa
90003e20:	f204 293a 	addw	r9, r4, #570	; 0x23a
90003e24:	4637      	mov	r7, r6
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
90003e26:	f811 0c04 	ldrb.w	r0, [r1, #-4]
90003e2a:	b110      	cbz	r0, 90003e32 <find_volume+0x92>
90003e2c:	4608      	mov	r0, r1
90003e2e:	f7ff fdfd 	bl	90003a2c <ld_dword>
90003e32:	3110      	adds	r1, #16
90003e34:	f847 0b04 	str.w	r0, [r7], #4
		for (i = 0; i < 4; i++) {		/* Get partition offset */
90003e38:	4589      	cmp	r9, r1
90003e3a:	d1f4      	bne.n	90003e26 <find_volume+0x86>
90003e3c:	2700      	movs	r7, #0
			bsect = br[i];
90003e3e:	f856 ab04 	ldr.w	sl, [r6], #4
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
90003e42:	f1ba 0f00 	cmp.w	sl, #0
90003e46:	f000 80e3 	beq.w	90004010 <find_volume+0x270>
90003e4a:	4651      	mov	r1, sl
90003e4c:	4620      	mov	r0, r4
90003e4e:	f7ff ff69 	bl	90003d24 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
90003e52:	2801      	cmp	r0, #1
90003e54:	f200 80dd 	bhi.w	90004012 <find_volume+0x272>
	rv = rv << 8 | ptr[0];
90003e58:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
90003e5c:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
90003e60:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
90003e64:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90003e68:	f040 80df 	bne.w	9000402a <find_volume+0x28a>
	rv = rv << 8 | ptr[0];
90003e6c:	f894 004b 	ldrb.w	r0, [r4, #75]	; 0x4b
90003e70:	f894 604a 	ldrb.w	r6, [r4, #74]	; 0x4a
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
90003e74:	ea56 2600 	orrs.w	r6, r6, r0, lsl #8
90003e78:	d104      	bne.n	90003e84 <find_volume+0xe4>
90003e7a:	f104 0058 	add.w	r0, r4, #88	; 0x58
90003e7e:	f7ff fdd5 	bl	90003a2c <ld_dword>
90003e82:	4606      	mov	r6, r0
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
90003e84:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
		fs->fsize = fasize;
90003e88:	61e6      	str	r6, [r4, #28]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
90003e8a:	1e7b      	subs	r3, r7, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
90003e8c:	70a7      	strb	r7, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
90003e8e:	2b01      	cmp	r3, #1
90003e90:	f200 80cb 	bhi.w	9000402a <find_volume+0x28a>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
90003e94:	f894 9041 	ldrb.w	r9, [r4, #65]	; 0x41
90003e98:	464b      	mov	r3, r9
90003e9a:	f8a4 900a 	strh.w	r9, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
90003e9e:	2b00      	cmp	r3, #0
90003ea0:	f000 80c3 	beq.w	9000402a <find_volume+0x28a>
90003ea4:	f109 33ff 	add.w	r3, r9, #4294967295
90003ea8:	ea13 0f09 	tst.w	r3, r9
90003eac:	f040 80bd 	bne.w	9000402a <find_volume+0x28a>
	rv = rv << 8 | ptr[0];
90003eb0:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
90003eb4:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
90003eb8:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
90003ebc:	070b      	lsls	r3, r1, #28
	rv = rv << 8 | ptr[0];
90003ebe:	fa0f fb81 	sxth.w	fp, r1
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
90003ec2:	8121      	strh	r1, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
90003ec4:	f040 80b1 	bne.w	9000402a <find_volume+0x28a>
	rv = rv << 8 | ptr[0];
90003ec8:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
90003ecc:	f894 0047 	ldrb.w	r0, [r4, #71]	; 0x47
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
90003ed0:	ea50 2003 	orrs.w	r0, r0, r3, lsl #8
90003ed4:	d103      	bne.n	90003ede <find_volume+0x13e>
90003ed6:	f104 0054 	add.w	r0, r4, #84	; 0x54
90003eda:	f7ff fda7 	bl	90003a2c <ld_dword>
	rv = rv << 8 | ptr[0];
90003ede:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
90003ee2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
90003ee6:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
90003eea:	f000 809e 	beq.w	9000402a <find_volume+0x28a>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
90003eee:	fb06 fc07 	mul.w	ip, r6, r7
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
90003ef2:	eb03 1211 	add.w	r2, r3, r1, lsr #4
90003ef6:	4462      	add	r2, ip
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
90003ef8:	4290      	cmp	r0, r2
90003efa:	f0c0 8096 	bcc.w	9000402a <find_volume+0x28a>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
90003efe:	1a80      	subs	r0, r0, r2
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
90003f00:	4548      	cmp	r0, r9
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
90003f02:	fbb0 f7f9 	udiv	r7, r0, r9
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
90003f06:	f0c0 8090 	bcc.w	9000402a <find_volume+0x28a>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
90003f0a:	f64f 70f5 	movw	r0, #65525	; 0xfff5
90003f0e:	4287      	cmp	r7, r0
90003f10:	f200 8090 	bhi.w	90004034 <find_volume+0x294>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
90003f14:	f640 79f5 	movw	r9, #4085	; 0xff5
90003f18:	454f      	cmp	r7, r9
90003f1a:	bf8c      	ite	hi
90003f1c:	f04f 0902 	movhi.w	r9, #2
90003f20:	f04f 0901 	movls.w	r9, #1
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
90003f24:	3702      	adds	r7, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
90003f26:	4453      	add	r3, sl
		fs->database = bsect + sysect;					/* Data start sector */
90003f28:	4452      	add	r2, sl
		if (fmt == FS_FAT32) {
90003f2a:	f1b9 0f03 	cmp.w	r9, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
90003f2e:	61a7      	str	r7, [r4, #24]
		fs->volbase = bsect;							/* Volume start sector */
90003f30:	f8c4 a020 	str.w	sl, [r4, #32]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
90003f34:	6263      	str	r3, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
90003f36:	62e2      	str	r2, [r4, #44]	; 0x2c
		if (fmt == FS_FAT32) {
90003f38:	d17f      	bne.n	9000403a <find_volume+0x29a>
	rv = rv << 8 | ptr[0];
90003f3a:	f894 205f 	ldrb.w	r2, [r4, #95]	; 0x5f
90003f3e:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
90003f42:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
90003f46:	ea4b 0b03 	orr.w	fp, fp, r3
90003f4a:	fa0f f38b 	sxth.w	r3, fp
90003f4e:	2b00      	cmp	r3, #0
90003f50:	d16b      	bne.n	9000402a <find_volume+0x28a>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
90003f52:	00bf      	lsls	r7, r7, #2
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
90003f54:	f104 0060 	add.w	r0, r4, #96	; 0x60
90003f58:	f7ff fd68 	bl	90003a2c <ld_dword>
90003f5c:	62a0      	str	r0, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
90003f5e:	f207 17ff 	addw	r7, r7, #511	; 0x1ff
90003f62:	ebb6 2f57 	cmp.w	r6, r7, lsr #9
90003f66:	d360      	bcc.n	9000402a <find_volume+0x28a>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
90003f68:	f04f 33ff 	mov.w	r3, #4294967295
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
90003f6c:	f1b9 0f03 	cmp.w	r9, #3
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
90003f70:	e9c4 3304 	strd	r3, r3, [r4, #16]
		fs->fsi_flag = 0x80;
90003f74:	f04f 0380 	mov.w	r3, #128	; 0x80
90003f78:	7123      	strb	r3, [r4, #4]
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
90003f7a:	d130      	bne.n	90003fde <find_volume+0x23e>
	rv = rv << 8 | ptr[0];
90003f7c:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
90003f80:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
90003f84:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			&& ld_word(fs->win + BPB_FSInfo32) == 1
90003f88:	2b01      	cmp	r3, #1
90003f8a:	d128      	bne.n	90003fde <find_volume+0x23e>
			&& move_window(fs, bsect + 1) == FR_OK)
90003f8c:	f10a 0101 	add.w	r1, sl, #1
90003f90:	4620      	mov	r0, r4
90003f92:	f7ff fead 	bl	90003cf0 <move_window>
90003f96:	bb10      	cbnz	r0, 90003fde <find_volume+0x23e>
	rv = rv << 8 | ptr[0];
90003f98:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
90003f9c:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
			fs->fsi_flag = 0;
90003fa0:	7120      	strb	r0, [r4, #4]
	rv = rv << 8 | ptr[0];
90003fa2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
90003fa6:	f64a 2255 	movw	r2, #43605	; 0xaa55
90003faa:	4293      	cmp	r3, r2
90003fac:	d117      	bne.n	90003fde <find_volume+0x23e>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
90003fae:	f104 0034 	add.w	r0, r4, #52	; 0x34
90003fb2:	f7ff fd3b 	bl	90003a2c <ld_dword>
90003fb6:	4b2e      	ldr	r3, [pc, #184]	; (90004070 <find_volume+0x2d0>)
90003fb8:	4298      	cmp	r0, r3
90003fba:	d110      	bne.n	90003fde <find_volume+0x23e>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
90003fbc:	f504 7006 	add.w	r0, r4, #536	; 0x218
90003fc0:	f7ff fd34 	bl	90003a2c <ld_dword>
90003fc4:	4b2b      	ldr	r3, [pc, #172]	; (90004074 <find_volume+0x2d4>)
90003fc6:	4298      	cmp	r0, r3
90003fc8:	d109      	bne.n	90003fde <find_volume+0x23e>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
90003fca:	f504 7007 	add.w	r0, r4, #540	; 0x21c
90003fce:	f7ff fd2d 	bl	90003a2c <ld_dword>
90003fd2:	6160      	str	r0, [r4, #20]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
90003fd4:	f504 7008 	add.w	r0, r4, #544	; 0x220
90003fd8:	f7ff fd28 	bl	90003a2c <ld_dword>
90003fdc:	6120      	str	r0, [r4, #16]
	fs->id = ++Fsid;		/* File system mount ID */
90003fde:	f8b8 3028 	ldrh.w	r3, [r8, #40]	; 0x28
	fs->fs_type = fmt;		/* FAT sub-type */
90003fe2:	f884 9000 	strb.w	r9, [r4]
	fs->id = ++Fsid;		/* File system mount ID */
90003fe6:	3301      	adds	r3, #1
90003fe8:	b29b      	uxth	r3, r3
90003fea:	f8a8 3028 	strh.w	r3, [r8, #40]	; 0x28
90003fee:	80e3      	strh	r3, [r4, #6]
		if (Files[i].fs == fs) Files[i].fs = 0;
90003ff0:	f8d8 3000 	ldr.w	r3, [r8]
90003ff4:	429c      	cmp	r4, r3
90003ff6:	bf04      	itt	eq
90003ff8:	2300      	moveq	r3, #0
90003ffa:	f8c8 3000 	streq.w	r3, [r8]
90003ffe:	f8d8 3010 	ldr.w	r3, [r8, #16]
90004002:	429c      	cmp	r4, r3
90004004:	f47f aef1 	bne.w	90003dea <find_volume+0x4a>
90004008:	2300      	movs	r3, #0
9000400a:	f8c8 3010 	str.w	r3, [r8, #16]
9000400e:	e6ec      	b.n	90003dea <find_volume+0x4a>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
90004010:	2003      	movs	r0, #3
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
90004012:	3701      	adds	r7, #1
90004014:	2f04      	cmp	r7, #4
90004016:	f47f af12 	bne.w	90003e3e <find_volume+0x9e>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
9000401a:	2804      	cmp	r0, #4
9000401c:	d105      	bne.n	9000402a <find_volume+0x28a>
9000401e:	2501      	movs	r5, #1
90004020:	e6e3      	b.n	90003dea <find_volume+0x4a>
90004022:	2804      	cmp	r0, #4
90004024:	d0fb      	beq.n	9000401e <find_volume+0x27e>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
90004026:	2801      	cmp	r0, #1
90004028:	d901      	bls.n	9000402e <find_volume+0x28e>
9000402a:	250d      	movs	r5, #13
9000402c:	e6dd      	b.n	90003dea <find_volume+0x4a>
	bsect = 0;
9000402e:	f04f 0a00 	mov.w	sl, #0
90004032:	e711      	b.n	90003e58 <find_volume+0xb8>
		fmt = FS_FAT32;
90004034:	f04f 0903 	mov.w	r9, #3
90004038:	e774      	b.n	90003f24 <find_volume+0x184>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
9000403a:	2900      	cmp	r1, #0
9000403c:	d0f5      	beq.n	9000402a <find_volume+0x28a>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
9000403e:	4463      	add	r3, ip
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
90004040:	f1b9 0f02 	cmp.w	r9, #2
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
90004044:	62a3      	str	r3, [r4, #40]	; 0x28
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
90004046:	ea4f 0347 	mov.w	r3, r7, lsl #1
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9000404a:	bf1b      	ittet	ne
9000404c:	19db      	addne	r3, r3, r7
9000404e:	f007 0701 	andne.w	r7, r7, #1
90004052:	461f      	moveq	r7, r3
90004054:	eb07 0753 	addne.w	r7, r7, r3, lsr #1
90004058:	e781      	b.n	90003f5e <find_volume+0x1be>
	if (vol < 0) return FR_INVALID_DRIVE;
9000405a:	250b      	movs	r5, #11
9000405c:	e6c5      	b.n	90003dea <find_volume+0x4a>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
9000405e:	250c      	movs	r5, #12
90004060:	e6c3      	b.n	90003dea <find_volume+0x4a>
			return FR_OK;				/* The file system object is valid */
90004062:	463d      	mov	r5, r7
90004064:	e6c1      	b.n	90003dea <find_volume+0x4a>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
90004066:	2503      	movs	r5, #3
90004068:	e6bf      	b.n	90003dea <find_volume+0x4a>
9000406a:	bf00      	nop
9000406c:	20000408 	.word	0x20000408
90004070:	41615252 	.word	0x41615252
90004074:	61417272 	.word	0x61417272

90004078 <put_fat>:
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
90004078:	2901      	cmp	r1, #1
{
9000407a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000407e:	4606      	mov	r6, r0
90004080:	460c      	mov	r4, r1
90004082:	4617      	mov	r7, r2
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
90004084:	d974      	bls.n	90004170 <put_fat+0xf8>
90004086:	6983      	ldr	r3, [r0, #24]
90004088:	428b      	cmp	r3, r1
9000408a:	d971      	bls.n	90004170 <put_fat+0xf8>
		switch (fs->fs_type) {
9000408c:	7803      	ldrb	r3, [r0, #0]
9000408e:	2b02      	cmp	r3, #2
90004090:	d040      	beq.n	90004114 <put_fat+0x9c>
90004092:	2b03      	cmp	r3, #3
90004094:	d051      	beq.n	9000413a <put_fat+0xc2>
90004096:	2b01      	cmp	r3, #1
90004098:	d16a      	bne.n	90004170 <put_fat+0xf8>
			bc = (UINT)clst; bc += bc / 2;
9000409a:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9000409e:	6a41      	ldr	r1, [r0, #36]	; 0x24
900040a0:	eb01 2158 	add.w	r1, r1, r8, lsr #9
900040a4:	f7ff fe24 	bl	90003cf0 <move_window>
900040a8:	4605      	mov	r5, r0
			if (res != FR_OK) break;
900040aa:	bb40      	cbnz	r0, 900040fe <put_fat+0x86>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
900040ac:	f014 0401 	ands.w	r4, r4, #1
			p = fs->win + bc++ % SS(fs);
900040b0:	f106 0934 	add.w	r9, r6, #52	; 0x34
900040b4:	f108 0a01 	add.w	sl, r8, #1
900040b8:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
900040bc:	bf08      	it	eq
900040be:	b2fb      	uxtbeq	r3, r7
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
900040c0:	4630      	mov	r0, r6
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
900040c2:	bf1f      	itttt	ne
900040c4:	f819 3008 	ldrbne.w	r3, [r9, r8]
900040c8:	f003 020f 	andne.w	r2, r3, #15
900040cc:	013b      	lslne	r3, r7, #4
900040ce:	f003 03f0 	andne.w	r3, r3, #240	; 0xf0
900040d2:	bf18      	it	ne
900040d4:	4313      	orrne	r3, r2
900040d6:	f809 3008 	strb.w	r3, [r9, r8]
			fs->wflag = 1;
900040da:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
900040dc:	6a71      	ldr	r1, [r6, #36]	; 0x24
			fs->wflag = 1;
900040de:	70f3      	strb	r3, [r6, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
900040e0:	eb01 215a 	add.w	r1, r1, sl, lsr #9
900040e4:	f7ff fe04 	bl	90003cf0 <move_window>
			if (res != FR_OK) break;
900040e8:	4605      	mov	r5, r0
900040ea:	b940      	cbnz	r0, 900040fe <put_fat+0x86>
			p = fs->win + bc % SS(fs);
900040ec:	f3ca 0a08 	ubfx	sl, sl, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
900040f0:	b144      	cbz	r4, 90004104 <put_fat+0x8c>
900040f2:	f3c7 1707 	ubfx	r7, r7, #4, #8
900040f6:	f809 700a 	strb.w	r7, [r9, sl]
			fs->wflag = 1;
900040fa:	2301      	movs	r3, #1
900040fc:	70f3      	strb	r3, [r6, #3]
}
900040fe:	4628      	mov	r0, r5
90004100:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
90004104:	f819 300a 	ldrb.w	r3, [r9, sl]
90004108:	f3c7 2703 	ubfx	r7, r7, #8, #4
9000410c:	f023 030f 	bic.w	r3, r3, #15
90004110:	431f      	orrs	r7, r3
90004112:	e7f0      	b.n	900040f6 <put_fat+0x7e>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
90004114:	6a41      	ldr	r1, [r0, #36]	; 0x24
90004116:	eb01 2114 	add.w	r1, r1, r4, lsr #8
9000411a:	f7ff fde9 	bl	90003cf0 <move_window>
			if (res != FR_OK) break;
9000411e:	4605      	mov	r5, r0
90004120:	2800      	cmp	r0, #0
90004122:	d1ec      	bne.n	900040fe <put_fat+0x86>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
90004124:	0064      	lsls	r4, r4, #1
90004126:	f106 0334 	add.w	r3, r6, #52	; 0x34
9000412a:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
	*ptr++ = (BYTE)val; val >>= 8;
9000412e:	551f      	strb	r7, [r3, r4]
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
90004130:	1918      	adds	r0, r3, r4
	*ptr++ = (BYTE)val; val >>= 8;
90004132:	f3c7 2707 	ubfx	r7, r7, #8, #8
	*ptr++ = (BYTE)val;
90004136:	7047      	strb	r7, [r0, #1]
			fs->wflag = 1;
90004138:	e7df      	b.n	900040fa <put_fat+0x82>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9000413a:	6a41      	ldr	r1, [r0, #36]	; 0x24
9000413c:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
90004140:	f7ff fdd6 	bl	90003cf0 <move_window>
			if (res != FR_OK) break;
90004144:	4605      	mov	r5, r0
90004146:	2800      	cmp	r0, #0
90004148:	d1d9      	bne.n	900040fe <put_fat+0x86>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
9000414a:	00a4      	lsls	r4, r4, #2
9000414c:	f106 0334 	add.w	r3, r6, #52	; 0x34
90004150:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
90004154:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
90004158:	441c      	add	r4, r3
9000415a:	4620      	mov	r0, r4
9000415c:	f7ff fc66 	bl	90003a2c <ld_dword>
90004160:	f000 4070 	and.w	r0, r0, #4026531840	; 0xf0000000
			st_dword(fs->win + clst * 4 % SS(fs), val);
90004164:	ea47 0100 	orr.w	r1, r7, r0
90004168:	4620      	mov	r0, r4
9000416a:	f7ff fc67 	bl	90003a3c <st_dword>
9000416e:	e7c4      	b.n	900040fa <put_fat+0x82>
		switch (fs->fs_type) {
90004170:	2502      	movs	r5, #2
90004172:	e7c4      	b.n	900040fe <put_fat+0x86>

90004174 <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
90004174:	2901      	cmp	r1, #1
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
90004176:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90004178:	4605      	mov	r5, r0
9000417a:	460c      	mov	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
9000417c:	d952      	bls.n	90004224 <get_fat.isra.0+0xb0>
9000417e:	6983      	ldr	r3, [r0, #24]
90004180:	4299      	cmp	r1, r3
90004182:	d24f      	bcs.n	90004224 <get_fat.isra.0+0xb0>
		switch (fs->fs_type) {
90004184:	7803      	ldrb	r3, [r0, #0]
90004186:	2b02      	cmp	r3, #2
90004188:	d029      	beq.n	900041de <get_fat.isra.0+0x6a>
9000418a:	2b03      	cmp	r3, #3
9000418c:	d038      	beq.n	90004200 <get_fat.isra.0+0x8c>
9000418e:	2b01      	cmp	r3, #1
90004190:	d148      	bne.n	90004224 <get_fat.isra.0+0xb0>
			bc = (UINT)clst; bc += bc / 2;
90004192:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
90004196:	6a41      	ldr	r1, [r0, #36]	; 0x24
90004198:	eb01 2156 	add.w	r1, r1, r6, lsr #9
9000419c:	f7ff fda8 	bl	90003cf0 <move_window>
900041a0:	b110      	cbz	r0, 900041a8 <get_fat.isra.0+0x34>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
900041a2:	f04f 30ff 	mov.w	r0, #4294967295
}
900041a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc = fs->win[bc++ % SS(fs)];
900041a8:	1c77      	adds	r7, r6, #1
900041aa:	f3c6 0608 	ubfx	r6, r6, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
900041ae:	6a69      	ldr	r1, [r5, #36]	; 0x24
900041b0:	4628      	mov	r0, r5
			wc = fs->win[bc++ % SS(fs)];
900041b2:	442e      	add	r6, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
900041b4:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			wc = fs->win[bc++ % SS(fs)];
900041b8:	f896 6034 	ldrb.w	r6, [r6, #52]	; 0x34
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
900041bc:	f7ff fd98 	bl	90003cf0 <move_window>
900041c0:	2800      	cmp	r0, #0
900041c2:	d1ee      	bne.n	900041a2 <get_fat.isra.0+0x2e>
			wc |= fs->win[bc % SS(fs)] << 8;
900041c4:	f3c7 0708 	ubfx	r7, r7, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
900041c8:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
900041ca:	443d      	add	r5, r7
900041cc:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
900041d0:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
900041d4:	bf4c      	ite	mi
900041d6:	0900      	lsrmi	r0, r0, #4
900041d8:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
900041dc:	e7e3      	b.n	900041a6 <get_fat.isra.0+0x32>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
900041de:	6a41      	ldr	r1, [r0, #36]	; 0x24
900041e0:	eb01 2114 	add.w	r1, r1, r4, lsr #8
900041e4:	f7ff fd84 	bl	90003cf0 <move_window>
900041e8:	2800      	cmp	r0, #0
900041ea:	d1da      	bne.n	900041a2 <get_fat.isra.0+0x2e>
			val = ld_word(fs->win + clst * 2 % SS(fs));
900041ec:	0064      	lsls	r4, r4, #1
900041ee:	3534      	adds	r5, #52	; 0x34
900041f0:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
900041f4:	192b      	adds	r3, r5, r4
	rv = rv << 8 | ptr[0];
900041f6:	5d28      	ldrb	r0, [r5, r4]
900041f8:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
900041fa:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			break;
900041fe:	e7d2      	b.n	900041a6 <get_fat.isra.0+0x32>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
90004200:	6a41      	ldr	r1, [r0, #36]	; 0x24
90004202:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
90004206:	f7ff fd73 	bl	90003cf0 <move_window>
9000420a:	2800      	cmp	r0, #0
9000420c:	d1c9      	bne.n	900041a2 <get_fat.isra.0+0x2e>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
9000420e:	00a4      	lsls	r4, r4, #2
90004210:	f105 0034 	add.w	r0, r5, #52	; 0x34
90004214:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
90004218:	4420      	add	r0, r4
9000421a:	f7ff fc07 	bl	90003a2c <ld_dword>
9000421e:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
90004222:	e7c0      	b.n	900041a6 <get_fat.isra.0+0x32>
		switch (fs->fs_type) {
90004224:	2001      	movs	r0, #1
	return val;
90004226:	e7be      	b.n	900041a6 <get_fat.isra.0+0x32>

90004228 <dir_sdi>:
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
90004228:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
{
9000422c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000422e:	4606      	mov	r6, r0
90004230:	460c      	mov	r4, r1
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
90004232:	d301      	bcc.n	90004238 <dir_sdi+0x10>
		return FR_INT_ERR;
90004234:	2002      	movs	r0, #2
}
90004236:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
90004238:	06ca      	lsls	r2, r1, #27
9000423a:	d1fb      	bne.n	90004234 <dir_sdi+0xc>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
9000423c:	6882      	ldr	r2, [r0, #8]
	FATFS *fs = dp->obj.fs;
9000423e:	6805      	ldr	r5, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
90004240:	6141      	str	r1, [r0, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
90004242:	b9ca      	cbnz	r2, 90004278 <dir_sdi+0x50>
90004244:	782b      	ldrb	r3, [r5, #0]
90004246:	2b02      	cmp	r3, #2
90004248:	d901      	bls.n	9000424e <dir_sdi+0x26>
		clst = fs->dirbase;
9000424a:	6aab      	ldr	r3, [r5, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
9000424c:	b99b      	cbnz	r3, 90004276 <dir_sdi+0x4e>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
9000424e:	892b      	ldrh	r3, [r5, #8]
90004250:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
90004254:	d9ee      	bls.n	90004234 <dir_sdi+0xc>
		dp->sect = fs->dirbase;
90004256:	6aab      	ldr	r3, [r5, #40]	; 0x28
90004258:	61f3      	str	r3, [r6, #28]
	if (!dp->sect) return FR_INT_ERR;
9000425a:	69f3      	ldr	r3, [r6, #28]
	dp->clust = clst;					/* Current cluster# */
9000425c:	61b2      	str	r2, [r6, #24]
	if (!dp->sect) return FR_INT_ERR;
9000425e:	2b00      	cmp	r3, #0
90004260:	d0e8      	beq.n	90004234 <dir_sdi+0xc>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
90004262:	eb03 2354 	add.w	r3, r3, r4, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
90004266:	3534      	adds	r5, #52	; 0x34
90004268:	f3c4 0408 	ubfx	r4, r4, #0, #9
	return FR_OK;
9000426c:	2000      	movs	r0, #0
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
9000426e:	61f3      	str	r3, [r6, #28]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
90004270:	442c      	add	r4, r5
90004272:	6234      	str	r4, [r6, #32]
	return FR_OK;
90004274:	e7df      	b.n	90004236 <dir_sdi+0xe>
90004276:	461a      	mov	r2, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
90004278:	896f      	ldrh	r7, [r5, #10]
9000427a:	027f      	lsls	r7, r7, #9
		while (ofs >= csz) {				/* Follow cluster chain */
9000427c:	42bc      	cmp	r4, r7
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
9000427e:	4611      	mov	r1, r2
		while (ofs >= csz) {				/* Follow cluster chain */
90004280:	d204      	bcs.n	9000428c <dir_sdi+0x64>
		dp->sect = clust2sect(fs, clst);
90004282:	4628      	mov	r0, r5
90004284:	f7ff fc82 	bl	90003b8c <clust2sect>
90004288:	61f0      	str	r0, [r6, #28]
9000428a:	e7e6      	b.n	9000425a <dir_sdi+0x32>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
9000428c:	6830      	ldr	r0, [r6, #0]
9000428e:	f7ff ff71 	bl	90004174 <get_fat.isra.0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
90004292:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
90004294:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
90004296:	d006      	beq.n	900042a6 <dir_sdi+0x7e>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
90004298:	2801      	cmp	r0, #1
9000429a:	d9cb      	bls.n	90004234 <dir_sdi+0xc>
9000429c:	69ab      	ldr	r3, [r5, #24]
9000429e:	4283      	cmp	r3, r0
900042a0:	d9c8      	bls.n	90004234 <dir_sdi+0xc>
			ofs -= csz;
900042a2:	1be4      	subs	r4, r4, r7
900042a4:	e7ea      	b.n	9000427c <dir_sdi+0x54>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
900042a6:	2001      	movs	r0, #1
900042a8:	e7c5      	b.n	90004236 <dir_sdi+0xe>

900042aa <create_chain>:
{
900042aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900042ae:	4680      	mov	r8, r0
	FATFS *fs = obj->fs;
900042b0:	6805      	ldr	r5, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
900042b2:	460f      	mov	r7, r1
900042b4:	b971      	cbnz	r1, 900042d4 <create_chain+0x2a>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
900042b6:	692e      	ldr	r6, [r5, #16]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
900042b8:	b1ee      	cbz	r6, 900042f6 <create_chain+0x4c>
900042ba:	69ab      	ldr	r3, [r5, #24]
900042bc:	42b3      	cmp	r3, r6
900042be:	bf98      	it	ls
900042c0:	2601      	movls	r6, #1
		ncl = scl;	/* Start cluster */
900042c2:	4634      	mov	r4, r6
			ncl++;							/* Next cluster */
900042c4:	3401      	adds	r4, #1
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
900042c6:	69ab      	ldr	r3, [r5, #24]
900042c8:	42a3      	cmp	r3, r4
900042ca:	d817      	bhi.n	900042fc <create_chain+0x52>
				if (ncl > scl) return 0;	/* No free cluster */
900042cc:	2e01      	cmp	r6, #1
900042ce:	d814      	bhi.n	900042fa <create_chain+0x50>
900042d0:	2400      	movs	r4, #0
900042d2:	e006      	b.n	900042e2 <create_chain+0x38>
		cs = get_fat(obj, clst);			/* Check the cluster status */
900042d4:	4628      	mov	r0, r5
900042d6:	f7ff ff4d 	bl	90004174 <get_fat.isra.0>
		if (cs < 2) return 1;				/* Invalid FAT value */
900042da:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
900042dc:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Invalid FAT value */
900042de:	d803      	bhi.n	900042e8 <create_chain+0x3e>
900042e0:	2401      	movs	r4, #1
}
900042e2:	4620      	mov	r0, r4
900042e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
900042e8:	1c43      	adds	r3, r0, #1
900042ea:	d030      	beq.n	9000434e <create_chain+0xa4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
900042ec:	69ab      	ldr	r3, [r5, #24]
900042ee:	4283      	cmp	r3, r0
900042f0:	d8f7      	bhi.n	900042e2 <create_chain+0x38>
900042f2:	463e      	mov	r6, r7
900042f4:	e7e5      	b.n	900042c2 <create_chain+0x18>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
900042f6:	2601      	movs	r6, #1
900042f8:	e7e3      	b.n	900042c2 <create_chain+0x18>
				ncl = 2;
900042fa:	2402      	movs	r4, #2
			cs = get_fat(obj, ncl);			/* Get the cluster status */
900042fc:	4621      	mov	r1, r4
900042fe:	f8d8 0000 	ldr.w	r0, [r8]
90004302:	f7ff ff37 	bl	90004174 <get_fat.isra.0>
			if (cs == 0) break;				/* Found a free cluster */
90004306:	b130      	cbz	r0, 90004316 <create_chain+0x6c>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
90004308:	2801      	cmp	r0, #1
9000430a:	d0e9      	beq.n	900042e0 <create_chain+0x36>
9000430c:	3001      	adds	r0, #1
9000430e:	d01e      	beq.n	9000434e <create_chain+0xa4>
			if (ncl == scl) return 0;		/* No free cluster */
90004310:	42b4      	cmp	r4, r6
90004312:	d1d7      	bne.n	900042c4 <create_chain+0x1a>
90004314:	e7dc      	b.n	900042d0 <create_chain+0x26>
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
90004316:	f04f 32ff 	mov.w	r2, #4294967295
9000431a:	4621      	mov	r1, r4
9000431c:	4628      	mov	r0, r5
9000431e:	f7ff feab 	bl	90004078 <put_fat>
		if (res == FR_OK && clst != 0) {
90004322:	b990      	cbnz	r0, 9000434a <create_chain+0xa0>
90004324:	b957      	cbnz	r7, 9000433c <create_chain+0x92>
		fs->last_clst = ncl;
90004326:	612c      	str	r4, [r5, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
90004328:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
9000432c:	3a02      	subs	r2, #2
9000432e:	4293      	cmp	r3, r2
90004330:	d910      	bls.n	90004354 <create_chain+0xaa>
		fs->fsi_flag |= 1;
90004332:	792b      	ldrb	r3, [r5, #4]
90004334:	f043 0301 	orr.w	r3, r3, #1
90004338:	712b      	strb	r3, [r5, #4]
9000433a:	e7d2      	b.n	900042e2 <create_chain+0x38>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
9000433c:	4622      	mov	r2, r4
9000433e:	4639      	mov	r1, r7
90004340:	4628      	mov	r0, r5
90004342:	f7ff fe99 	bl	90004078 <put_fat>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
90004346:	2800      	cmp	r0, #0
90004348:	d0ed      	beq.n	90004326 <create_chain+0x7c>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
9000434a:	2801      	cmp	r0, #1
9000434c:	d1c8      	bne.n	900042e0 <create_chain+0x36>
9000434e:	f04f 34ff 	mov.w	r4, #4294967295
90004352:	e7c6      	b.n	900042e2 <create_chain+0x38>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
90004354:	3b01      	subs	r3, #1
90004356:	616b      	str	r3, [r5, #20]
90004358:	e7eb      	b.n	90004332 <create_chain+0x88>

9000435a <remove_chain>:
{
9000435a:	b573      	push	{r0, r1, r4, r5, r6, lr}
9000435c:	460c      	mov	r4, r1
9000435e:	4606      	mov	r6, r0
90004360:	4611      	mov	r1, r2
	FATFS *fs = obj->fs;
90004362:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
90004364:	2c01      	cmp	r4, #1
90004366:	d92c      	bls.n	900043c2 <remove_chain+0x68>
90004368:	69ab      	ldr	r3, [r5, #24]
9000436a:	42a3      	cmp	r3, r4
9000436c:	d929      	bls.n	900043c2 <remove_chain+0x68>
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
9000436e:	b12a      	cbz	r2, 9000437c <remove_chain+0x22>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
90004370:	f04f 32ff 	mov.w	r2, #4294967295
90004374:	4628      	mov	r0, r5
90004376:	f7ff fe7f 	bl	90004078 <put_fat>
		if (res != FR_OK) return res;
9000437a:	b940      	cbnz	r0, 9000438e <remove_chain+0x34>
		nxt = get_fat(obj, clst);			/* Get cluster status */
9000437c:	4621      	mov	r1, r4
9000437e:	6830      	ldr	r0, [r6, #0]
90004380:	9401      	str	r4, [sp, #4]
90004382:	f7ff fef7 	bl	90004174 <get_fat.isra.0>
		if (nxt == 0) break;				/* Empty cluster? */
90004386:	9901      	ldr	r1, [sp, #4]
90004388:	4604      	mov	r4, r0
9000438a:	b910      	cbnz	r0, 90004392 <remove_chain+0x38>
	return FR_OK;
9000438c:	2000      	movs	r0, #0
}
9000438e:	b002      	add	sp, #8
90004390:	bd70      	pop	{r4, r5, r6, pc}
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
90004392:	2801      	cmp	r0, #1
90004394:	d015      	beq.n	900043c2 <remove_chain+0x68>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
90004396:	1c43      	adds	r3, r0, #1
90004398:	d015      	beq.n	900043c6 <remove_chain+0x6c>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
9000439a:	2200      	movs	r2, #0
9000439c:	4628      	mov	r0, r5
9000439e:	f7ff fe6b 	bl	90004078 <put_fat>
			if (res != FR_OK) return res;
900043a2:	2800      	cmp	r0, #0
900043a4:	d1f3      	bne.n	9000438e <remove_chain+0x34>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
900043a6:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
900043aa:	1e91      	subs	r1, r2, #2
900043ac:	428b      	cmp	r3, r1
900043ae:	d205      	bcs.n	900043bc <remove_chain+0x62>
			fs->free_clst++;
900043b0:	3301      	adds	r3, #1
900043b2:	616b      	str	r3, [r5, #20]
			fs->fsi_flag |= 1;
900043b4:	792b      	ldrb	r3, [r5, #4]
900043b6:	f043 0301 	orr.w	r3, r3, #1
900043ba:	712b      	strb	r3, [r5, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
900043bc:	42a2      	cmp	r2, r4
900043be:	d8dd      	bhi.n	9000437c <remove_chain+0x22>
900043c0:	e7e4      	b.n	9000438c <remove_chain+0x32>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
900043c2:	2002      	movs	r0, #2
900043c4:	e7e3      	b.n	9000438e <remove_chain+0x34>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
900043c6:	2001      	movs	r0, #1
900043c8:	e7e1      	b.n	9000438e <remove_chain+0x34>

900043ca <sync_fs>:
{
900043ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900043cc:	4604      	mov	r4, r0
	res = sync_window(fs);
900043ce:	f7ff fc89 	bl	90003ce4 <sync_window>
900043d2:	4605      	mov	r5, r0
	if (res == FR_OK) {
900043d4:	2800      	cmp	r0, #0
900043d6:	d142      	bne.n	9000445e <sync_fs+0x94>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
900043d8:	7823      	ldrb	r3, [r4, #0]
900043da:	2b03      	cmp	r3, #3
900043dc:	d137      	bne.n	9000444e <sync_fs+0x84>
900043de:	7927      	ldrb	r7, [r4, #4]
900043e0:	2f01      	cmp	r7, #1
900043e2:	d134      	bne.n	9000444e <sync_fs+0x84>
			mem_set(fs->win, 0, SS(fs));
900043e4:	f104 0634 	add.w	r6, r4, #52	; 0x34
900043e8:	4601      	mov	r1, r0
900043ea:	f44f 7200 	mov.w	r2, #512	; 0x200
900043ee:	4630      	mov	r0, r6
900043f0:	f7ff fb2c 	bl	90003a4c <mem_set>
	*ptr++ = (BYTE)val; val >>= 8;
900043f4:	2355      	movs	r3, #85	; 0x55
	*ptr++ = (BYTE)val;
900043f6:	2241      	movs	r2, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
900043f8:	2172      	movs	r1, #114	; 0x72
	*ptr++ = (BYTE)val; val >>= 8;
900043fa:	f884 3232 	strb.w	r3, [r4, #562]	; 0x232
	*ptr++ = (BYTE)val;
900043fe:	23aa      	movs	r3, #170	; 0xaa
	*ptr++ = (BYTE)val;
90004400:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
90004404:	f504 7007 	add.w	r0, r4, #540	; 0x21c
	*ptr++ = (BYTE)val;
90004408:	f884 3233 	strb.w	r3, [r4, #563]	; 0x233
	*ptr++ = (BYTE)val; val >>= 8;
9000440c:	2352      	movs	r3, #82	; 0x52
	*ptr++ = (BYTE)val; val >>= 8;
9000440e:	f884 221a 	strb.w	r2, [r4, #538]	; 0x21a
	*ptr++ = (BYTE)val; val >>= 8;
90004412:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
90004416:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
	*ptr++ = (BYTE)val; val >>= 8;
9000441a:	2361      	movs	r3, #97	; 0x61
	*ptr++ = (BYTE)val; val >>= 8;
9000441c:	f884 1218 	strb.w	r1, [r4, #536]	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
90004420:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
	*ptr++ = (BYTE)val;
90004424:	f884 321b 	strb.w	r3, [r4, #539]	; 0x21b
	*ptr++ = (BYTE)val; val >>= 8;
90004428:	f884 1219 	strb.w	r1, [r4, #537]	; 0x219
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
9000442c:	6961      	ldr	r1, [r4, #20]
9000442e:	f7ff fb05 	bl	90003a3c <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
90004432:	6921      	ldr	r1, [r4, #16]
90004434:	f504 7008 	add.w	r0, r4, #544	; 0x220
90004438:	f7ff fb00 	bl	90003a3c <st_dword>
			fs->winsect = fs->volbase + 1;
9000443c:	6a22      	ldr	r2, [r4, #32]
			disk_write(fs->drv, fs->win, fs->winsect, 1);
9000443e:	463b      	mov	r3, r7
90004440:	4631      	mov	r1, r6
			fs->winsect = fs->volbase + 1;
90004442:	3201      	adds	r2, #1
			disk_write(fs->drv, fs->win, fs->winsect, 1);
90004444:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
90004446:	6322      	str	r2, [r4, #48]	; 0x30
			disk_write(fs->drv, fs->win, fs->winsect, 1);
90004448:	f7ff fad2 	bl	900039f0 <disk_write>
			fs->fsi_flag = 0;
9000444c:	7125      	strb	r5, [r4, #4]
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
9000444e:	2200      	movs	r2, #0
90004450:	7860      	ldrb	r0, [r4, #1]
90004452:	4611      	mov	r1, r2
90004454:	f7ff fada 	bl	90003a0c <disk_ioctl>
	res = sync_window(fs);
90004458:	3800      	subs	r0, #0
9000445a:	bf18      	it	ne
9000445c:	2001      	movne	r0, #1
}
9000445e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

90004460 <dir_next>:
	ofs = dp->dptr + SZDIRE;	/* Next entry */
90004460:	6943      	ldr	r3, [r0, #20]
{
90004462:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
90004466:	f103 0820 	add.w	r8, r3, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
9000446a:	69c3      	ldr	r3, [r0, #28]
{
9000446c:	4605      	mov	r5, r0
9000446e:	468a      	mov	sl, r1
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
90004470:	b193      	cbz	r3, 90004498 <dir_next+0x38>
90004472:	f5b8 1f00 	cmp.w	r8, #2097152	; 0x200000
90004476:	d20f      	bcs.n	90004498 <dir_next+0x38>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
90004478:	f3c8 0908 	ubfx	r9, r8, #0, #9
	FATFS *fs = dp->obj.fs;
9000447c:	6804      	ldr	r4, [r0, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
9000447e:	f1b9 0f00 	cmp.w	r9, #0
90004482:	d14d      	bne.n	90004520 <dir_next+0xc0>
		dp->sect++;				/* Next sector */
90004484:	3301      	adds	r3, #1
		if (!dp->clust) {		/* Static table */
90004486:	6981      	ldr	r1, [r0, #24]
		dp->sect++;				/* Next sector */
90004488:	61c3      	str	r3, [r0, #28]
		if (!dp->clust) {		/* Static table */
9000448a:	b939      	cbnz	r1, 9000449c <dir_next+0x3c>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
9000448c:	8923      	ldrh	r3, [r4, #8]
9000448e:	ebb3 1f58 	cmp.w	r3, r8, lsr #5
90004492:	d845      	bhi.n	90004520 <dir_next+0xc0>
				dp->sect = 0; return FR_NO_FILE;
90004494:	2300      	movs	r3, #0
90004496:	61eb      	str	r3, [r5, #28]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
90004498:	2004      	movs	r0, #4
9000449a:	e00b      	b.n	900044b4 <dir_next+0x54>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
9000449c:	8967      	ldrh	r7, [r4, #10]
9000449e:	3f01      	subs	r7, #1
900044a0:	ea17 2758 	ands.w	r7, r7, r8, lsr #9
900044a4:	d13c      	bne.n	90004520 <dir_next+0xc0>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
900044a6:	4620      	mov	r0, r4
900044a8:	f7ff fe64 	bl	90004174 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
900044ac:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
900044ae:	4606      	mov	r6, r0
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
900044b0:	d802      	bhi.n	900044b8 <dir_next+0x58>
900044b2:	2002      	movs	r0, #2
}
900044b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
900044b8:	1c42      	adds	r2, r0, #1
900044ba:	d101      	bne.n	900044c0 <dir_next+0x60>
900044bc:	2001      	movs	r0, #1
900044be:	e7f9      	b.n	900044b4 <dir_next+0x54>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
900044c0:	69a3      	ldr	r3, [r4, #24]
900044c2:	4283      	cmp	r3, r0
900044c4:	d826      	bhi.n	90004514 <dir_next+0xb4>
					if (!stretch) {								/* If no stretch, report EOT */
900044c6:	f1ba 0f00 	cmp.w	sl, #0
900044ca:	d0e3      	beq.n	90004494 <dir_next+0x34>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
900044cc:	69a9      	ldr	r1, [r5, #24]
900044ce:	4628      	mov	r0, r5
900044d0:	f7ff feeb 	bl	900042aa <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
900044d4:	4606      	mov	r6, r0
900044d6:	2800      	cmp	r0, #0
900044d8:	d035      	beq.n	90004546 <dir_next+0xe6>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
900044da:	2801      	cmp	r0, #1
900044dc:	d0e9      	beq.n	900044b2 <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
900044de:	1c43      	adds	r3, r0, #1
900044e0:	d0ec      	beq.n	900044bc <dir_next+0x5c>
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
900044e2:	4620      	mov	r0, r4
900044e4:	f7ff fbfe 	bl	90003ce4 <sync_window>
900044e8:	4601      	mov	r1, r0
900044ea:	2800      	cmp	r0, #0
900044ec:	d1e6      	bne.n	900044bc <dir_next+0x5c>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
900044ee:	f44f 7200 	mov.w	r2, #512	; 0x200
900044f2:	f104 0034 	add.w	r0, r4, #52	; 0x34
						fs->wflag = 1;
900044f6:	f04f 0a01 	mov.w	sl, #1
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
900044fa:	f7ff faa7 	bl	90003a4c <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
900044fe:	4631      	mov	r1, r6
90004500:	4620      	mov	r0, r4
90004502:	f7ff fb43 	bl	90003b8c <clust2sect>
90004506:	6320      	str	r0, [r4, #48]	; 0x30
90004508:	8963      	ldrh	r3, [r4, #10]
9000450a:	429f      	cmp	r7, r3
9000450c:	d30f      	bcc.n	9000452e <dir_next+0xce>
					fs->winsect -= n;							/* Restore window offset */
9000450e:	6b23      	ldr	r3, [r4, #48]	; 0x30
90004510:	1bdf      	subs	r7, r3, r7
90004512:	6327      	str	r7, [r4, #48]	; 0x30
				dp->sect = clust2sect(fs, clst);
90004514:	4631      	mov	r1, r6
90004516:	4620      	mov	r0, r4
				dp->clust = clst;		/* Initialize data for new cluster */
90004518:	61ae      	str	r6, [r5, #24]
				dp->sect = clust2sect(fs, clst);
9000451a:	f7ff fb37 	bl	90003b8c <clust2sect>
9000451e:	61e8      	str	r0, [r5, #28]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
90004520:	3434      	adds	r4, #52	; 0x34
	return FR_OK;
90004522:	2000      	movs	r0, #0
	dp->dptr = ofs;						/* Current entry */
90004524:	f8c5 8014 	str.w	r8, [r5, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
90004528:	444c      	add	r4, r9
9000452a:	622c      	str	r4, [r5, #32]
	return FR_OK;
9000452c:	e7c2      	b.n	900044b4 <dir_next+0x54>
						fs->wflag = 1;
9000452e:	4620      	mov	r0, r4
90004530:	f884 a003 	strb.w	sl, [r4, #3]
	if (fs->wflag) {	/* Write back the sector if it is dirty */
90004534:	f7ff fbb0 	bl	90003c98 <sync_window.part.0>
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
90004538:	2800      	cmp	r0, #0
9000453a:	d1bf      	bne.n	900044bc <dir_next+0x5c>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
9000453c:	6b23      	ldr	r3, [r4, #48]	; 0x30
9000453e:	3701      	adds	r7, #1
90004540:	3301      	adds	r3, #1
90004542:	6323      	str	r3, [r4, #48]	; 0x30
90004544:	e7e0      	b.n	90004508 <dir_next+0xa8>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
90004546:	2007      	movs	r0, #7
90004548:	e7b4      	b.n	900044b4 <dir_next+0x54>
	...

9000454c <dir_find>:
{
9000454c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
90004550:	2100      	movs	r1, #0
{
90004552:	b085      	sub	sp, #20
90004554:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
90004556:	f8d0 a000 	ldr.w	sl, [r0]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
9000455a:	f7ff fe65 	bl	90004228 <dir_sdi>
	if (res != FR_OK) return res;
9000455e:	4607      	mov	r7, r0
90004560:	2800      	cmp	r0, #0
90004562:	f040 809b 	bne.w	9000469c <dir_find+0x150>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
90004566:	f04f 09ff 	mov.w	r9, #255	; 0xff
9000456a:	f04f 33ff 	mov.w	r3, #4294967295
9000456e:	46c8      	mov	r8, r9
90004570:	6323      	str	r3, [r4, #48]	; 0x30
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
90004572:	9300      	str	r3, [sp, #0]
		res = move_window(fs, dp->sect);
90004574:	69e1      	ldr	r1, [r4, #28]
90004576:	4650      	mov	r0, sl
90004578:	f7ff fbba 	bl	90003cf0 <move_window>
		if (res != FR_OK) break;
9000457c:	4607      	mov	r7, r0
9000457e:	2800      	cmp	r0, #0
90004580:	f040 808c 	bne.w	9000469c <dir_find+0x150>
		c = dp->dir[DIR_Name];
90004584:	6a25      	ldr	r5, [r4, #32]
90004586:	782e      	ldrb	r6, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
90004588:	2e00      	cmp	r6, #0
9000458a:	f000 808b 	beq.w	900046a4 <dir_find+0x158>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
9000458e:	7aea      	ldrb	r2, [r5, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
90004590:	2ee5      	cmp	r6, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
90004592:	f002 033f 	and.w	r3, r2, #63	; 0x3f
90004596:	71a3      	strb	r3, [r4, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
90004598:	d003      	beq.n	900045a2 <dir_find+0x56>
9000459a:	0710      	lsls	r0, r2, #28
9000459c:	d504      	bpl.n	900045a8 <dir_find+0x5c>
9000459e:	2b0f      	cmp	r3, #15
900045a0:	d004      	beq.n	900045ac <dir_find+0x60>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
900045a2:	9b00      	ldr	r3, [sp, #0]
900045a4:	6323      	str	r3, [r4, #48]	; 0x30
900045a6:	e053      	b.n	90004650 <dir_find+0x104>
			if (a == AM_LFN) {			/* An LFN entry is found */
900045a8:	2b0f      	cmp	r3, #15
900045aa:	d159      	bne.n	90004660 <dir_find+0x114>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
900045ac:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
900045b0:	0659      	lsls	r1, r3, #25
900045b2:	d443      	bmi.n	9000463c <dir_find+0xf0>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
900045b4:	0672      	lsls	r2, r6, #25
900045b6:	d549      	bpl.n	9000464c <dir_find+0x100>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
900045b8:	6963      	ldr	r3, [r4, #20]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
900045ba:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
						sum = dp->dir[LDIR_Chksum];
900045be:	f895 900d 	ldrb.w	r9, [r5, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
900045c2:	6323      	str	r3, [r4, #48]	; 0x30
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
900045c4:	7b6b      	ldrb	r3, [r5, #13]
900045c6:	454b      	cmp	r3, r9
900045c8:	d142      	bne.n	90004650 <dir_find+0x104>
	rv = rv << 8 | ptr[0];
900045ca:	7eea      	ldrb	r2, [r5, #27]
900045cc:	7eab      	ldrb	r3, [r5, #26]
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
900045ce:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
900045d2:	d13d      	bne.n	90004650 <dir_find+0x104>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
900045d4:	782f      	ldrb	r7, [r5, #0]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
900045d6:	2201      	movs	r2, #1
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
900045d8:	f8da b00c 	ldr.w	fp, [sl, #12]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
900045dc:	f007 073f 	and.w	r7, r7, #63	; 0x3f
900045e0:	1e7b      	subs	r3, r7, #1
900045e2:	270d      	movs	r7, #13
900045e4:	435f      	muls	r7, r3
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
900045e6:	4b30      	ldr	r3, [pc, #192]	; (900046a8 <dir_find+0x15c>)
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
900045e8:	f813 1b01 	ldrb.w	r1, [r3], #1
900045ec:	1868      	adds	r0, r5, r1
	rv = rv << 8 | ptr[0];
900045ee:	f815 8001 	ldrb.w	r8, [r5, r1]
900045f2:	7840      	ldrb	r0, [r0, #1]
900045f4:	ea48 2800 	orr.w	r8, r8, r0, lsl #8
		if (wc) {
900045f8:	b36a      	cbz	r2, 90004656 <dir_find+0x10a>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
900045fa:	2ffe      	cmp	r7, #254	; 0xfe
900045fc:	9303      	str	r3, [sp, #12]
900045fe:	d827      	bhi.n	90004650 <dir_find+0x104>
90004600:	4640      	mov	r0, r8
90004602:	f000 fead 	bl	90005360 <ff_wtoupper>
90004606:	1c79      	adds	r1, r7, #1
90004608:	9002      	str	r0, [sp, #8]
9000460a:	f83b 0017 	ldrh.w	r0, [fp, r7, lsl #1]
9000460e:	9101      	str	r1, [sp, #4]
90004610:	f000 fea6 	bl	90005360 <ff_wtoupper>
90004614:	9a02      	ldr	r2, [sp, #8]
90004616:	4282      	cmp	r2, r0
90004618:	d11a      	bne.n	90004650 <dir_find+0x104>
9000461a:	9901      	ldr	r1, [sp, #4]
	rv = rv << 8 | ptr[0];
9000461c:	4642      	mov	r2, r8
9000461e:	9b03      	ldr	r3, [sp, #12]
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
90004620:	460f      	mov	r7, r1
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
90004622:	4922      	ldr	r1, [pc, #136]	; (900046ac <dir_find+0x160>)
90004624:	4299      	cmp	r1, r3
90004626:	d1df      	bne.n	900045e8 <dir_find+0x9c>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
90004628:	782b      	ldrb	r3, [r5, #0]
9000462a:	065b      	lsls	r3, r3, #25
9000462c:	d503      	bpl.n	90004636 <dir_find+0xea>
9000462e:	b112      	cbz	r2, 90004636 <dir_find+0xea>
90004630:	f83b 3017 	ldrh.w	r3, [fp, r7, lsl #1]
90004634:	b963      	cbnz	r3, 90004650 <dir_find+0x104>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
90004636:	3e01      	subs	r6, #1
90004638:	fa5f f886 	uxtb.w	r8, r6
		res = dir_next(dp, 0);	/* Next entry */
9000463c:	2100      	movs	r1, #0
9000463e:	4620      	mov	r0, r4
90004640:	f7ff ff0e 	bl	90004460 <dir_next>
	} while (res == FR_OK);
90004644:	4607      	mov	r7, r0
90004646:	2800      	cmp	r0, #0
90004648:	d094      	beq.n	90004574 <dir_find+0x28>
9000464a:	e027      	b.n	9000469c <dir_find+0x150>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
9000464c:	45b0      	cmp	r8, r6
9000464e:	d0b9      	beq.n	900045c4 <dir_find+0x78>
90004650:	f04f 08ff 	mov.w	r8, #255	; 0xff
90004654:	e7f2      	b.n	9000463c <dir_find+0xf0>
			if (uc != 0xFFFF) return 0;		/* Check filler */
90004656:	f64f 71ff 	movw	r1, #65535	; 0xffff
9000465a:	4588      	cmp	r8, r1
9000465c:	d0e1      	beq.n	90004622 <dir_find+0xd6>
9000465e:	e7f7      	b.n	90004650 <dir_find+0x104>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
90004660:	f1b8 0f00 	cmp.w	r8, #0
90004664:	d104      	bne.n	90004670 <dir_find+0x124>
90004666:	4628      	mov	r0, r5
90004668:	f7ff faac 	bl	90003bc4 <sum_sfn>
9000466c:	4548      	cmp	r0, r9
9000466e:	d015      	beq.n	9000469c <dir_find+0x150>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
90004670:	f894 702f 	ldrb.w	r7, [r4, #47]	; 0x2f
90004674:	f017 0701 	ands.w	r7, r7, #1
90004678:	d193      	bne.n	900045a2 <dir_find+0x56>
9000467a:	f104 0224 	add.w	r2, r4, #36	; 0x24
int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
9000467e:	f105 010b 	add.w	r1, r5, #11
		r = *d++ - *s++;
90004682:	f815 3b01 	ldrb.w	r3, [r5], #1
90004686:	f812 0b01 	ldrb.w	r0, [r2], #1
	} while (--cnt && r == 0);
9000468a:	428d      	cmp	r5, r1
		r = *d++ - *s++;
9000468c:	eba3 0300 	sub.w	r3, r3, r0
	} while (--cnt && r == 0);
90004690:	d002      	beq.n	90004698 <dir_find+0x14c>
90004692:	2b00      	cmp	r3, #0
90004694:	d0f5      	beq.n	90004682 <dir_find+0x136>
90004696:	e784      	b.n	900045a2 <dir_find+0x56>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
90004698:	2b00      	cmp	r3, #0
9000469a:	d182      	bne.n	900045a2 <dir_find+0x56>
}
9000469c:	4638      	mov	r0, r7
9000469e:	b005      	add	sp, #20
900046a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
900046a4:	2704      	movs	r7, #4
900046a6:	e7f9      	b.n	9000469c <dir_find+0x150>
900046a8:	9000930c 	.word	0x9000930c
900046ac:	90009319 	.word	0x90009319

900046b0 <dir_register>:
{
900046b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
900046b4:	f890 502f 	ldrb.w	r5, [r0, #47]	; 0x2f
{
900046b8:	b089      	sub	sp, #36	; 0x24
900046ba:	4604      	mov	r4, r0
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
900046bc:	f015 05a0 	ands.w	r5, r5, #160	; 0xa0
900046c0:	f040 808d 	bne.w	900047de <dir_register+0x12e>
	FATFS *fs = dp->obj.fs;
900046c4:	6806      	ldr	r6, [r0, #0]
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
900046c6:	68f2      	ldr	r2, [r6, #12]
900046c8:	f832 3015 	ldrh.w	r3, [r2, r5, lsl #1]
900046cc:	2b00      	cmp	r3, #0
900046ce:	d165      	bne.n	9000479c <dir_register+0xec>
	mem_cpy(sn, dp->fn, 12);
900046d0:	f104 0724 	add.w	r7, r4, #36	; 0x24
	if (cnt) {
900046d4:	220c      	movs	r2, #12
900046d6:	a805      	add	r0, sp, #20
900046d8:	4639      	mov	r1, r7
900046da:	f7ff fab9 	bl	90003c50 <mem_cpy.part.0>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
900046de:	f89d 301f 	ldrb.w	r3, [sp, #31]
900046e2:	07db      	lsls	r3, r3, #31
900046e4:	f140 8084 	bpl.w	900047f0 <dir_register+0x140>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
900046e8:	2340      	movs	r3, #64	; 0x40
		for (n = 1; n < 100; n++) {
900046ea:	f04f 0a01 	mov.w	sl, #1
				if (sr & 0x10000) sr ^= 0x11021;
900046ee:	f8df 8234 	ldr.w	r8, [pc, #564]	; 90004924 <dir_register+0x274>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
900046f2:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
900046f6:	220b      	movs	r2, #11
900046f8:	a905      	add	r1, sp, #20
900046fa:	4638      	mov	r0, r7
900046fc:	f8d6 900c 	ldr.w	r9, [r6, #12]
	if (cnt) {
90004700:	f7ff faa6 	bl	90003c50 <mem_cpy.part.0>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
90004704:	f1ba 0f05 	cmp.w	sl, #5
90004708:	d958      	bls.n	900047bc <dir_register+0x10c>
9000470a:	f1a9 0102 	sub.w	r1, r9, #2
9000470e:	4653      	mov	r3, sl
		while (*lfn) {	/* Create a CRC */
90004710:	f831 2f02 	ldrh.w	r2, [r1, #2]!
90004714:	2a00      	cmp	r2, #0
90004716:	d143      	bne.n	900047a0 <dir_register+0xf0>
90004718:	f10d 0013 	add.w	r0, sp, #19
9000471c:	2207      	movs	r2, #7
		c = (BYTE)((seq % 16) + '0');
9000471e:	f003 0c0f 	and.w	ip, r3, #15
		ns[i--] = c;
90004722:	3a01      	subs	r2, #1
		c = (BYTE)((seq % 16) + '0');
90004724:	f10c 0130 	add.w	r1, ip, #48	; 0x30
		if (c > '9') c += 7;
90004728:	2939      	cmp	r1, #57	; 0x39
9000472a:	bf88      	it	hi
9000472c:	f10c 0137 	addhi.w	r1, ip, #55	; 0x37
	} while (seq);
90004730:	2b0f      	cmp	r3, #15
		ns[i--] = c;
90004732:	f800 1901 	strb.w	r1, [r0], #-1
		seq /= 16;
90004736:	ea4f 1113 	mov.w	r1, r3, lsr #4
	} while (seq);
9000473a:	d841      	bhi.n	900047c0 <dir_register+0x110>
	ns[i] = '~';
9000473c:	ab08      	add	r3, sp, #32
9000473e:	217e      	movs	r1, #126	; 0x7e
90004740:	4413      	add	r3, r2
90004742:	f803 1c14 	strb.w	r1, [r3, #-20]
	for (j = 0; j < i && dst[j] != ' '; j++) {
90004746:	f104 0123 	add.w	r1, r4, #35	; 0x23
9000474a:	2300      	movs	r3, #0
9000474c:	4608      	mov	r0, r1
9000474e:	429a      	cmp	r2, r3
90004750:	d006      	beq.n	90004760 <dir_register+0xb0>
90004752:	f810 cf01 	ldrb.w	ip, [r0, #1]!
90004756:	f103 0e01 	add.w	lr, r3, #1
9000475a:	f1bc 0f20 	cmp.w	ip, #32
9000475e:	d131      	bne.n	900047c4 <dir_register+0x114>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
90004760:	2a07      	cmp	r2, #7
90004762:	f103 0301 	add.w	r3, r3, #1
90004766:	bf97      	itett	ls
90004768:	a808      	addls	r0, sp, #32
9000476a:	2020      	movhi	r0, #32
9000476c:	1880      	addls	r0, r0, r2
9000476e:	3201      	addls	r2, #1
90004770:	bf98      	it	ls
90004772:	f810 0c14 	ldrbls.w	r0, [r0, #-20]
	} while (j < 8);
90004776:	2b07      	cmp	r3, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
90004778:	54c8      	strb	r0, [r1, r3]
	} while (j < 8);
9000477a:	d9f1      	bls.n	90004760 <dir_register+0xb0>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
9000477c:	4620      	mov	r0, r4
9000477e:	f7ff fee5 	bl	9000454c <dir_find>
90004782:	4681      	mov	r9, r0
			if (res != FR_OK) break;
90004784:	bb70      	cbnz	r0, 900047e4 <dir_register+0x134>
		for (n = 1; n < 100; n++) {
90004786:	f10a 0a01 	add.w	sl, sl, #1
9000478a:	f1ba 0f64 	cmp.w	sl, #100	; 0x64
9000478e:	d1b2      	bne.n	900046f6 <dir_register+0x46>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
90004790:	f04f 0907 	mov.w	r9, #7
}
90004794:	4648      	mov	r0, r9
90004796:	b009      	add	sp, #36	; 0x24
90004798:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
9000479c:	3501      	adds	r5, #1
9000479e:	e793      	b.n	900046c8 <dir_register+0x18>
900047a0:	2010      	movs	r0, #16
				sr = (sr << 1) + (wc & 1);
900047a2:	f002 0c01 	and.w	ip, r2, #1
				wc >>= 1;
900047a6:	0852      	lsrs	r2, r2, #1
				sr = (sr << 1) + (wc & 1);
900047a8:	eb0c 0343 	add.w	r3, ip, r3, lsl #1
				if (sr & 0x10000) sr ^= 0x11021;
900047ac:	f413 3f80 	tst.w	r3, #65536	; 0x10000
900047b0:	bf18      	it	ne
900047b2:	ea83 0308 	eorne.w	r3, r3, r8
			for (i = 0; i < 16; i++) {
900047b6:	3801      	subs	r0, #1
900047b8:	d1f3      	bne.n	900047a2 <dir_register+0xf2>
900047ba:	e7a9      	b.n	90004710 <dir_register+0x60>
900047bc:	4653      	mov	r3, sl
900047be:	e7ab      	b.n	90004718 <dir_register+0x68>
		seq /= 16;
900047c0:	460b      	mov	r3, r1
900047c2:	e7ac      	b.n	9000471e <dir_register+0x6e>
900047c4:	4673      	mov	r3, lr
900047c6:	e7c2      	b.n	9000474e <dir_register+0x9e>
				n = 0;					/* Not a blank entry. Restart to search */
900047c8:	4680      	mov	r8, r0
			res = dir_next(dp, 1);
900047ca:	2101      	movs	r1, #1
900047cc:	4620      	mov	r0, r4
900047ce:	f7ff fe47 	bl	90004460 <dir_next>
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
900047d2:	4681      	mov	r9, r0
900047d4:	b308      	cbz	r0, 9000481a <dir_register+0x16a>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
900047d6:	f1b9 0f04 	cmp.w	r9, #4
900047da:	d0d9      	beq.n	90004790 <dir_register+0xe0>
900047dc:	e7da      	b.n	90004794 <dir_register+0xe4>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
900047de:	f04f 0906 	mov.w	r9, #6
900047e2:	e7d7      	b.n	90004794 <dir_register+0xe4>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
900047e4:	2804      	cmp	r0, #4
900047e6:	d1d5      	bne.n	90004794 <dir_register+0xe4>
		dp->fn[NSFLAG] = sn[NSFLAG];
900047e8:	f89d 301f 	ldrb.w	r3, [sp, #31]
900047ec:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
900047f0:	f89d 301f 	ldrb.w	r3, [sp, #31]
	res = dir_sdi(dp, 0);
900047f4:	2100      	movs	r1, #0
900047f6:	4620      	mov	r0, r4
	FATFS *fs = dp->obj.fs;
900047f8:	f8d4 a000 	ldr.w	sl, [r4]
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
900047fc:	079b      	lsls	r3, r3, #30
900047fe:	bf45      	ittet	mi
90004800:	350c      	addmi	r5, #12
90004802:	230d      	movmi	r3, #13
90004804:	2501      	movpl	r5, #1
90004806:	fbb5 f5f3 	udivmi	r5, r5, r3
9000480a:	bf48      	it	mi
9000480c:	3501      	addmi	r5, #1
	res = dir_sdi(dp, 0);
9000480e:	f7ff fd0b 	bl	90004228 <dir_sdi>
	if (res == FR_OK) {
90004812:	4681      	mov	r9, r0
90004814:	2800      	cmp	r0, #0
90004816:	d1de      	bne.n	900047d6 <dir_register+0x126>
		n = 0;
90004818:	4680      	mov	r8, r0
			res = move_window(fs, dp->sect);
9000481a:	69e1      	ldr	r1, [r4, #28]
9000481c:	4650      	mov	r0, sl
9000481e:	f7ff fa67 	bl	90003cf0 <move_window>
			if (res != FR_OK) break;
90004822:	4681      	mov	r9, r0
90004824:	2800      	cmp	r0, #0
90004826:	d1d6      	bne.n	900047d6 <dir_register+0x126>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
90004828:	6a23      	ldr	r3, [r4, #32]
9000482a:	781b      	ldrb	r3, [r3, #0]
9000482c:	2be5      	cmp	r3, #229	; 0xe5
9000482e:	d001      	beq.n	90004834 <dir_register+0x184>
90004830:	2b00      	cmp	r3, #0
90004832:	d1c9      	bne.n	900047c8 <dir_register+0x118>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
90004834:	f108 0801 	add.w	r8, r8, #1
90004838:	4545      	cmp	r5, r8
9000483a:	d1c6      	bne.n	900047ca <dir_register+0x11a>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
9000483c:	3d01      	subs	r5, #1
9000483e:	d055      	beq.n	900048ec <dir_register+0x23c>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
90004840:	6961      	ldr	r1, [r4, #20]
90004842:	4620      	mov	r0, r4
90004844:	eba1 1145 	sub.w	r1, r1, r5, lsl #5
90004848:	f7ff fcee 	bl	90004228 <dir_sdi>
		if (res == FR_OK) {
9000484c:	4681      	mov	r9, r0
9000484e:	2800      	cmp	r0, #0
90004850:	d1a0      	bne.n	90004794 <dir_register+0xe4>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
90004852:	f64f 78ff 	movw	r8, #65535	; 0xffff
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
90004856:	4638      	mov	r0, r7
90004858:	f7ff f9b4 	bl	90003bc4 <sum_sfn>
9000485c:	9001      	str	r0, [sp, #4]
				res = move_window(fs, dp->sect);
9000485e:	69e1      	ldr	r1, [r4, #28]
90004860:	4630      	mov	r0, r6
90004862:	f7ff fa45 	bl	90003cf0 <move_window>
90004866:	4681      	mov	r9, r0
				if (res != FR_OK) break;
90004868:	2800      	cmp	r0, #0
9000486a:	d193      	bne.n	90004794 <dir_register+0xe4>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
9000486c:	6a23      	ldr	r3, [r4, #32]
9000486e:	b2e9      	uxtb	r1, r5
	dir[LDIR_Chksum] = sum;			/* Set checksum */
90004870:	9a01      	ldr	r2, [sp, #4]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
90004872:	f04f 0c0d 	mov.w	ip, #13
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
90004876:	f8d6 e00c 	ldr.w	lr, [r6, #12]
	dir[LDIR_Chksum] = sum;			/* Set checksum */
9000487a:	735a      	strb	r2, [r3, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
9000487c:	f04f 020f 	mov.w	r2, #15
90004880:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 90004928 <dir_register+0x278>
90004884:	72da      	strb	r2, [r3, #11]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
90004886:	1e4a      	subs	r2, r1, #1
	dir[LDIR_Type] = 0;
90004888:	7318      	strb	r0, [r3, #12]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
9000488a:	fb0c f202 	mul.w	r2, ip, r2
	s = wc = 0;
9000488e:	4684      	mov	ip, r0
	*ptr++ = (BYTE)val; val >>= 8;
90004890:	7698      	strb	r0, [r3, #26]
	*ptr++ = (BYTE)val;
90004892:	76d8      	strb	r0, [r3, #27]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
90004894:	4540      	cmp	r0, r8
		st_word(dir + LfnOfs[s], wc);		/* Put it */
90004896:	f81a 9b01 	ldrb.w	r9, [sl], #1
	} while (++s < 13);
9000489a:	f10c 0c01 	add.w	ip, ip, #1
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
9000489e:	bf18      	it	ne
900048a0:	f83e 0012 	ldrhne.w	r0, [lr, r2, lsl #1]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
900048a4:	eb03 0b09 	add.w	fp, r3, r9
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
900048a8:	bf18      	it	ne
900048aa:	3201      	addne	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
900048ac:	f803 0009 	strb.w	r0, [r3, r9]
900048b0:	ea4f 2910 	mov.w	r9, r0, lsr #8
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
900048b4:	2800      	cmp	r0, #0
900048b6:	bf08      	it	eq
900048b8:	4640      	moveq	r0, r8
	} while (++s < 13);
900048ba:	f1bc 0f0d 	cmp.w	ip, #13
	*ptr++ = (BYTE)val;
900048be:	f88b 9001 	strb.w	r9, [fp, #1]
	} while (++s < 13);
900048c2:	d1e7      	bne.n	90004894 <dir_register+0x1e4>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
900048c4:	4540      	cmp	r0, r8
900048c6:	d002      	beq.n	900048ce <dir_register+0x21e>
900048c8:	f83e 2012 	ldrh.w	r2, [lr, r2, lsl #1]
900048cc:	b90a      	cbnz	r2, 900048d2 <dir_register+0x222>
900048ce:	f041 0140 	orr.w	r1, r1, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
900048d2:	7019      	strb	r1, [r3, #0]
				fs->wflag = 1;
900048d4:	2301      	movs	r3, #1
				res = dir_next(dp, 0);	/* Next entry */
900048d6:	2100      	movs	r1, #0
900048d8:	4620      	mov	r0, r4
				fs->wflag = 1;
900048da:	70f3      	strb	r3, [r6, #3]
				res = dir_next(dp, 0);	/* Next entry */
900048dc:	f7ff fdc0 	bl	90004460 <dir_next>
			} while (res == FR_OK && --nent);
900048e0:	4681      	mov	r9, r0
900048e2:	2800      	cmp	r0, #0
900048e4:	f47f af56 	bne.w	90004794 <dir_register+0xe4>
900048e8:	3d01      	subs	r5, #1
900048ea:	d1b8      	bne.n	9000485e <dir_register+0x1ae>
		res = move_window(fs, dp->sect);
900048ec:	69e1      	ldr	r1, [r4, #28]
900048ee:	4630      	mov	r0, r6
900048f0:	f7ff f9fe 	bl	90003cf0 <move_window>
		if (res == FR_OK) {
900048f4:	4681      	mov	r9, r0
900048f6:	2800      	cmp	r0, #0
900048f8:	f47f af4c 	bne.w	90004794 <dir_register+0xe4>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
900048fc:	4601      	mov	r1, r0
900048fe:	2220      	movs	r2, #32
90004900:	6a20      	ldr	r0, [r4, #32]
90004902:	f7ff f8a3 	bl	90003a4c <mem_set>
	if (cnt) {
90004906:	220b      	movs	r2, #11
90004908:	4639      	mov	r1, r7
9000490a:	6a20      	ldr	r0, [r4, #32]
9000490c:	f7ff f9a0 	bl	90003c50 <mem_cpy.part.0>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
90004910:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
90004914:	6a22      	ldr	r2, [r4, #32]
90004916:	f003 0318 	and.w	r3, r3, #24
9000491a:	7313      	strb	r3, [r2, #12]
			fs->wflag = 1;
9000491c:	2301      	movs	r3, #1
9000491e:	70f3      	strb	r3, [r6, #3]
90004920:	e738      	b.n	90004794 <dir_register+0xe4>
90004922:	bf00      	nop
90004924:	00011021 	.word	0x00011021
90004928:	9000930c 	.word	0x9000930c

9000492c <follow_path>:
{
9000492c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90004930:	4606      	mov	r6, r0
	FATFS *fs = obj->fs;
90004932:	f8d0 b000 	ldr.w	fp, [r0]
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
90004936:	4689      	mov	r9, r1
90004938:	f811 3b01 	ldrb.w	r3, [r1], #1
9000493c:	2b2f      	cmp	r3, #47	; 0x2f
9000493e:	d0fa      	beq.n	90004936 <follow_path+0xa>
90004940:	2b5c      	cmp	r3, #92	; 0x5c
90004942:	d0f8      	beq.n	90004936 <follow_path+0xa>
		obj->sclust = 0;					/* Start from root directory */
90004944:	2100      	movs	r1, #0
90004946:	60b1      	str	r1, [r6, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
90004948:	f899 3000 	ldrb.w	r3, [r9]
9000494c:	2b1f      	cmp	r3, #31
9000494e:	f200 80bc 	bhi.w	90004aca <follow_path+0x19e>
		dp->fn[NSFLAG] = NS_NONAME;
90004952:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
90004954:	4630      	mov	r0, r6
		dp->fn[NSFLAG] = NS_NONAME;
90004956:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
}
9000495a:	b003      	add	sp, #12
9000495c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
90004960:	f7ff bc62 	b.w	90004228 <dir_sdi>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
90004964:	3401      	adds	r4, #1
90004966:	e0c3      	b.n	90004af0 <follow_path+0x1c4>
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
90004968:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
9000496c:	9300      	str	r3, [sp, #0]
9000496e:	d00c      	beq.n	9000498a <follow_path+0x5e>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
90004970:	2101      	movs	r1, #1
90004972:	f000 fcd7 	bl	90005324 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
90004976:	b140      	cbz	r0, 9000498a <follow_path+0x5e>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
90004978:	287f      	cmp	r0, #127	; 0x7f
9000497a:	9b00      	ldr	r3, [sp, #0]
9000497c:	d807      	bhi.n	9000498e <follow_path+0x62>
9000497e:	497f      	ldr	r1, [pc, #508]	; (90004b7c <follow_path+0x250>)
	while (*str && *str != chr) str++;
90004980:	f811 2b01 	ldrb.w	r2, [r1], #1
90004984:	b11a      	cbz	r2, 9000498e <follow_path+0x62>
90004986:	4290      	cmp	r0, r2
90004988:	d1fa      	bne.n	90004980 <follow_path+0x54>
				cf |= NS_LOSS | NS_LFN; break;
9000498a:	2006      	movs	r0, #6
9000498c:	e04e      	b.n	90004a2c <follow_path+0x100>
		w = p[si++];					/* Get a character */
9000498e:	4627      	mov	r7, r4
		lfn[di++] = w;					/* Store the Unicode character */
90004990:	f828 0f02 	strh.w	r0, [r8, #2]!
		w = p[si++];					/* Get a character */
90004994:	e0a2      	b.n	90004adc <follow_path+0x1b0>
		w = lfn[di - 1];
90004996:	f835 3017 	ldrh.w	r3, [r5, r7, lsl #1]
		if (w != ' ' && w != '.') break;
9000499a:	2b20      	cmp	r3, #32
9000499c:	d002      	beq.n	900049a4 <follow_path+0x78>
9000499e:	2b2e      	cmp	r3, #46	; 0x2e
900049a0:	f040 80b6 	bne.w	90004b10 <follow_path+0x1e4>
		di--;
900049a4:	3f01      	subs	r7, #1
900049a6:	e0b0      	b.n	90004b0a <follow_path+0x1de>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
900049a8:	3101      	adds	r1, #1
900049aa:	e0be      	b.n	90004b2a <follow_path+0x1fe>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
900049ac:	4543      	cmp	r3, r8
900049ae:	d205      	bcs.n	900049bc <follow_path+0x90>
900049b0:	42ba      	cmp	r2, r7
900049b2:	d14a      	bne.n	90004a4a <follow_path+0x11e>
			if (ni == 11) {				/* Long extension */
900049b4:	f1b8 0f0b 	cmp.w	r8, #11
900049b8:	d140      	bne.n	90004a3c <follow_path+0x110>
900049ba:	e002      	b.n	900049c2 <follow_path+0x96>
900049bc:	f1b8 0f0b 	cmp.w	r8, #11
900049c0:	d137      	bne.n	90004a32 <follow_path+0x106>
				cf |= NS_LOSS | NS_LFN; break;
900049c2:	f044 0403 	orr.w	r4, r4, #3
900049c6:	f04f 080b 	mov.w	r8, #11
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
900049ca:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
900049ce:	2be5      	cmp	r3, #229	; 0xe5
900049d0:	bf04      	itt	eq
900049d2:	2305      	moveq	r3, #5
900049d4:	f886 3024 	strbeq.w	r3, [r6, #36]	; 0x24
	if (ni == 8) b <<= 2;
900049d8:	f1b8 0f08 	cmp.w	r8, #8
900049dc:	bf04      	itt	eq
900049de:	00ad      	lsleq	r5, r5, #2
900049e0:	b2ed      	uxtbeq	r5, r5
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
900049e2:	f005 030c 	and.w	r3, r5, #12
900049e6:	2b0c      	cmp	r3, #12
900049e8:	d003      	beq.n	900049f2 <follow_path+0xc6>
900049ea:	f005 0203 	and.w	r2, r5, #3
900049ee:	2a03      	cmp	r2, #3
900049f0:	d101      	bne.n	900049f6 <follow_path+0xca>
900049f2:	f044 0402 	orr.w	r4, r4, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
900049f6:	07a1      	lsls	r1, r4, #30
900049f8:	d409      	bmi.n	90004a0e <follow_path+0xe2>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
900049fa:	f005 0503 	and.w	r5, r5, #3
900049fe:	2d01      	cmp	r5, #1
90004a00:	bf08      	it	eq
90004a02:	f044 0410 	orreq.w	r4, r4, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
90004a06:	2b04      	cmp	r3, #4
90004a08:	bf08      	it	eq
90004a0a:	f044 0408 	orreq.w	r4, r4, #8
			res = dir_find(dp);				/* Find an object with the segment name */
90004a0e:	4630      	mov	r0, r6
	dp->fn[NSFLAG] = cf;	/* SFN is created */
90004a10:	f886 402f 	strb.w	r4, [r6, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
90004a14:	f7ff fd9a 	bl	9000454c <dir_find>
			ns = dp->fn[NSFLAG];
90004a18:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
90004a1c:	2800      	cmp	r0, #0
90004a1e:	d044      	beq.n	90004aaa <follow_path+0x17e>
				if (res == FR_NO_FILE) {	/* Object is not found */
90004a20:	2804      	cmp	r0, #4
90004a22:	d103      	bne.n	90004a2c <follow_path+0x100>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
90004a24:	f013 0f04 	tst.w	r3, #4
90004a28:	bf08      	it	eq
90004a2a:	2005      	moveq	r0, #5
}
90004a2c:	b003      	add	sp, #12
90004a2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
90004a32:	42ba      	cmp	r2, r7
90004a34:	d002      	beq.n	90004a3c <follow_path+0x110>
90004a36:	f044 0403 	orr.w	r4, r4, #3
			if (si > di) break;			/* No extension */
90004a3a:	d8c6      	bhi.n	900049ca <follow_path+0x9e>
			b <<= 2; continue;
90004a3c:	00ad      	lsls	r5, r5, #2
90004a3e:	463a      	mov	r2, r7
			si = di; i = 8; ni = 11;	/* Enter extension section */
90004a40:	f04f 080b 	mov.w	r8, #11
90004a44:	2308      	movs	r3, #8
			b <<= 2; continue;
90004a46:	b2ed      	uxtb	r5, r5
90004a48:	e094      	b.n	90004b74 <follow_path+0x248>
		if (w >= 0x80) {				/* Non ASCII character */
90004a4a:	287f      	cmp	r0, #127	; 0x7f
90004a4c:	d90e      	bls.n	90004a6c <follow_path+0x140>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
90004a4e:	2100      	movs	r1, #0
90004a50:	f044 0402 	orr.w	r4, r4, #2
90004a54:	e9cd 2300 	strd	r2, r3, [sp]
90004a58:	f000 fc64 	bl	90005324 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
90004a5c:	e9dd 2300 	ldrd	r2, r3, [sp]
90004a60:	b158      	cbz	r0, 90004a7a <follow_path+0x14e>
90004a62:	4947      	ldr	r1, [pc, #284]	; (90004b80 <follow_path+0x254>)
90004a64:	4408      	add	r0, r1
90004a66:	f810 0c73 	ldrb.w	r0, [r0, #-115]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
90004a6a:	b130      	cbz	r0, 90004a7a <follow_path+0x14e>
	while (*str && *str != chr) str++;
90004a6c:	f8df c114 	ldr.w	ip, [pc, #276]	; 90004b84 <follow_path+0x258>
90004a70:	f81c 1b01 	ldrb.w	r1, [ip], #1
90004a74:	b149      	cbz	r1, 90004a8a <follow_path+0x15e>
90004a76:	4281      	cmp	r1, r0
90004a78:	d1fa      	bne.n	90004a70 <follow_path+0x144>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
90004a7a:	f044 0403 	orr.w	r4, r4, #3
90004a7e:	205f      	movs	r0, #95	; 0x5f
		dp->fn[i++] = (BYTE)w;
90004a80:	18f1      	adds	r1, r6, r3
90004a82:	3301      	adds	r3, #1
90004a84:	f881 0024 	strb.w	r0, [r1, #36]	; 0x24
90004a88:	e074      	b.n	90004b74 <follow_path+0x248>
				if (IsUpper(w)) {		/* ASCII large capital */
90004a8a:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
90004a8e:	2919      	cmp	r1, #25
90004a90:	d802      	bhi.n	90004a98 <follow_path+0x16c>
					b |= 2;
90004a92:	f045 0502 	orr.w	r5, r5, #2
90004a96:	e7f3      	b.n	90004a80 <follow_path+0x154>
					if (IsLower(w)) {	/* ASCII small capital */
90004a98:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
90004a9c:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
90004a9e:	bf9e      	ittt	ls
90004aa0:	3820      	subls	r0, #32
90004aa2:	f045 0501 	orrls.w	r5, r5, #1
90004aa6:	b280      	uxthls	r0, r0
90004aa8:	e7ea      	b.n	90004a80 <follow_path+0x154>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
90004aaa:	075a      	lsls	r2, r3, #29
90004aac:	d4be      	bmi.n	90004a2c <follow_path+0x100>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
90004aae:	79b3      	ldrb	r3, [r6, #6]
90004ab0:	06db      	lsls	r3, r3, #27
90004ab2:	d561      	bpl.n	90004b78 <follow_path+0x24c>
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
90004ab4:	6973      	ldr	r3, [r6, #20]
90004ab6:	f10b 0134 	add.w	r1, fp, #52	; 0x34
90004aba:	f89b 0000 	ldrb.w	r0, [fp]
90004abe:	f3c3 0308 	ubfx	r3, r3, #0, #9
90004ac2:	4419      	add	r1, r3
90004ac4:	f7ff f8cd 	bl	90003c62 <ld_clust.isra.0>
90004ac8:	60b0      	str	r0, [r6, #8]
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
90004aca:	6833      	ldr	r3, [r6, #0]
90004acc:	2700      	movs	r7, #0
90004ace:	f8d3 a00c 	ldr.w	sl, [r3, #12]
90004ad2:	f109 33ff 	add.w	r3, r9, #4294967295
90004ad6:	f1aa 0502 	sub.w	r5, sl, #2
90004ada:	46a8      	mov	r8, r5
		w = p[si++];					/* Get a character */
90004adc:	f813 0f01 	ldrb.w	r0, [r3, #1]!
90004ae0:	1c7c      	adds	r4, r7, #1
		if (w < ' ') break;				/* Break if end of the path name */
90004ae2:	281f      	cmp	r0, #31
90004ae4:	d90c      	bls.n	90004b00 <follow_path+0x1d4>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
90004ae6:	282f      	cmp	r0, #47	; 0x2f
90004ae8:	d002      	beq.n	90004af0 <follow_path+0x1c4>
90004aea:	285c      	cmp	r0, #92	; 0x5c
90004aec:	f47f af3c 	bne.w	90004968 <follow_path+0x3c>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
90004af0:	f819 3004 	ldrb.w	r3, [r9, r4]
90004af4:	2b2f      	cmp	r3, #47	; 0x2f
90004af6:	f43f af35 	beq.w	90004964 <follow_path+0x38>
90004afa:	2b5c      	cmp	r3, #92	; 0x5c
90004afc:	f43f af32 	beq.w	90004964 <follow_path+0x38>
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
90004b00:	2820      	cmp	r0, #32
	*path = &p[si];						/* Return pointer to the next segment */
90004b02:	44a1      	add	r9, r4
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
90004b04:	bf34      	ite	cc
90004b06:	2404      	movcc	r4, #4
90004b08:	2400      	movcs	r4, #0
	while (di) {						/* Snip off trailing spaces and dots if exist */
90004b0a:	2f00      	cmp	r7, #0
90004b0c:	f47f af43 	bne.w	90004996 <follow_path+0x6a>
	lfn[di] = 0;						/* LFN is created */
90004b10:	2300      	movs	r3, #0
90004b12:	f82a 3017 	strh.w	r3, [sl, r7, lsl #1]
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
90004b16:	2f00      	cmp	r7, #0
90004b18:	f43f af37 	beq.w	9000498a <follow_path+0x5e>
	mem_set(dp->fn, ' ', 11);
90004b1c:	2120      	movs	r1, #32
90004b1e:	220b      	movs	r2, #11
90004b20:	f106 0024 	add.w	r0, r6, #36	; 0x24
90004b24:	f7fe ff92 	bl	90003a4c <mem_set>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
90004b28:	4619      	mov	r1, r3
90004b2a:	f83a 3011 	ldrh.w	r3, [sl, r1, lsl #1]
90004b2e:	2b20      	cmp	r3, #32
90004b30:	f43f af3a 	beq.w	900049a8 <follow_path+0x7c>
90004b34:	2b2e      	cmp	r3, #46	; 0x2e
90004b36:	f43f af37 	beq.w	900049a8 <follow_path+0x7c>
	if (si) cf |= NS_LOSS | NS_LFN;
90004b3a:	b109      	cbz	r1, 90004b40 <follow_path+0x214>
90004b3c:	f044 0403 	orr.w	r4, r4, #3
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
90004b40:	f835 3017 	ldrh.w	r3, [r5, r7, lsl #1]
90004b44:	2b2e      	cmp	r3, #46	; 0x2e
90004b46:	d001      	beq.n	90004b4c <follow_path+0x220>
90004b48:	3f01      	subs	r7, #1
90004b4a:	d1f9      	bne.n	90004b40 <follow_path+0x214>
		dp->fn[i++] = (BYTE)w;
90004b4c:	2300      	movs	r3, #0
90004b4e:	f04f 0808 	mov.w	r8, #8
90004b52:	461d      	mov	r5, r3
		w = lfn[si++];					/* Get an LFN character */
90004b54:	f83a 0011 	ldrh.w	r0, [sl, r1, lsl #1]
90004b58:	1c4a      	adds	r2, r1, #1
		if (!w) break;					/* Break on end of the LFN */
90004b5a:	2800      	cmp	r0, #0
90004b5c:	f43f af35 	beq.w	900049ca <follow_path+0x9e>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
90004b60:	2820      	cmp	r0, #32
90004b62:	d005      	beq.n	90004b70 <follow_path+0x244>
90004b64:	282e      	cmp	r0, #46	; 0x2e
90004b66:	f47f af21 	bne.w	900049ac <follow_path+0x80>
90004b6a:	42ba      	cmp	r2, r7
90004b6c:	f43f af22 	beq.w	900049b4 <follow_path+0x88>
			cf |= NS_LOSS | NS_LFN; continue;
90004b70:	f044 0403 	orr.w	r4, r4, #3
		dp->fn[i++] = (BYTE)w;
90004b74:	4611      	mov	r1, r2
90004b76:	e7ed      	b.n	90004b54 <follow_path+0x228>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
90004b78:	2005      	movs	r0, #5
	return res;
90004b7a:	e757      	b.n	90004a2c <follow_path+0x100>
90004b7c:	90009832 	.word	0x90009832
90004b80:	9000930c 	.word	0x9000930c
90004b84:	9000983b 	.word	0x9000983b

90004b88 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
90004b88:	b530      	push	{r4, r5, lr}
90004b8a:	b085      	sub	sp, #20
90004b8c:	4614      	mov	r4, r2
90004b8e:	e9cd 1000 	strd	r1, r0, [sp]
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
90004b92:	a803      	add	r0, sp, #12
	const TCHAR *rp = path;
90004b94:	9103      	str	r1, [sp, #12]
	vol = get_ldnumber(&rp);
90004b96:	f7ff f824 	bl	90003be2 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
90004b9a:	2800      	cmp	r0, #0
90004b9c:	db21      	blt.n	90004be2 <f_mount+0x5a>
	cfs = FatFs[vol];					/* Pointer to fs object */
90004b9e:	4b13      	ldr	r3, [pc, #76]	; (90004bec <f_mount+0x64>)
90004ba0:	0085      	lsls	r5, r0, #2
90004ba2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
90004ba6:	6a01      	ldr	r1, [r0, #32]

	if (cfs) {
90004ba8:	b159      	cbz	r1, 90004bc2 <f_mount+0x3a>
		if (Files[i].fs == fs) Files[i].fs = 0;
90004baa:	681a      	ldr	r2, [r3, #0]
90004bac:	4291      	cmp	r1, r2
90004bae:	bf04      	itt	eq
90004bb0:	2200      	moveq	r2, #0
90004bb2:	601a      	streq	r2, [r3, #0]
90004bb4:	691a      	ldr	r2, [r3, #16]
90004bb6:	4291      	cmp	r1, r2
90004bb8:	f04f 0200 	mov.w	r2, #0
90004bbc:	bf08      	it	eq
90004bbe:	611a      	streq	r2, [r3, #16]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
90004bc0:	700a      	strb	r2, [r1, #0]
	}

	if (fs) {
90004bc2:	9801      	ldr	r0, [sp, #4]
90004bc4:	b108      	cbz	r0, 90004bca <f_mount+0x42>
		fs->fs_type = 0;				/* Clear new fs object */
90004bc6:	2200      	movs	r2, #0
90004bc8:	7002      	strb	r2, [r0, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
90004bca:	442b      	add	r3, r5
90004bcc:	6218      	str	r0, [r3, #32]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
90004bce:	b130      	cbz	r0, 90004bde <f_mount+0x56>
90004bd0:	2c01      	cmp	r4, #1
90004bd2:	d108      	bne.n	90004be6 <f_mount+0x5e>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
90004bd4:	2200      	movs	r2, #0
90004bd6:	a901      	add	r1, sp, #4
90004bd8:	4668      	mov	r0, sp
90004bda:	f7ff f8e1 	bl	90003da0 <find_volume>
	LEAVE_FF(fs, res);
}
90004bde:	b005      	add	sp, #20
90004be0:	bd30      	pop	{r4, r5, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
90004be2:	200b      	movs	r0, #11
90004be4:	e7fb      	b.n	90004bde <f_mount+0x56>
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
90004be6:	2000      	movs	r0, #0
90004be8:	e7f9      	b.n	90004bde <f_mount+0x56>
90004bea:	bf00      	nop
90004bec:	20000408 	.word	0x20000408

90004bf0 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
90004bf0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
90004bf4:	b091      	sub	sp, #68	; 0x44
90004bf6:	4690      	mov	r8, r2
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
90004bf8:	4605      	mov	r5, r0
{
90004bfa:	9101      	str	r1, [sp, #4]
	if (!fp) return FR_INVALID_OBJECT;
90004bfc:	2800      	cmp	r0, #0
90004bfe:	f000 8108 	beq.w	90004e12 <f_open+0x222>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
90004c02:	f002 063f 	and.w	r6, r2, #63	; 0x3f
	res = find_volume(&path, &fs, mode);
90004c06:	a902      	add	r1, sp, #8
90004c08:	a801      	add	r0, sp, #4
90004c0a:	4632      	mov	r2, r6
90004c0c:	f7ff f8c8 	bl	90003da0 <find_volume>
	if (res == FR_OK) {
90004c10:	2800      	cmp	r0, #0
90004c12:	f040 80fc 	bne.w	90004e0e <f_open+0x21e>
		dj.obj.fs = fs;
90004c16:	9b02      	ldr	r3, [sp, #8]
		INIT_NAMBUF(fs);
90004c18:	f44f 7000 	mov.w	r0, #512	; 0x200
		dj.obj.fs = fs;
90004c1c:	9303      	str	r3, [sp, #12]
		INIT_NAMBUF(fs);
90004c1e:	f000 fb7d 	bl	9000531c <ff_memalloc>
90004c22:	4607      	mov	r7, r0
90004c24:	2800      	cmp	r0, #0
90004c26:	f000 80f6 	beq.w	90004e16 <f_open+0x226>
90004c2a:	9b02      	ldr	r3, [sp, #8]
		res = follow_path(&dj, path);	/* Follow the file path */
90004c2c:	9901      	ldr	r1, [sp, #4]
		INIT_NAMBUF(fs);
90004c2e:	60d8      	str	r0, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
90004c30:	a803      	add	r0, sp, #12
90004c32:	f7ff fe7b 	bl	9000492c <follow_path>
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
90004c36:	4604      	mov	r4, r0
90004c38:	b960      	cbnz	r0, 90004c54 <f_open+0x64>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
90004c3a:	f99d 303b 	ldrsb.w	r3, [sp, #59]	; 0x3b
90004c3e:	2b00      	cmp	r3, #0
90004c40:	db60      	blt.n	90004d04 <f_open+0x114>
				res = FR_INVALID_NAME;
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
90004c42:	f016 0f3e 	tst.w	r6, #62	; 0x3e
90004c46:	a803      	add	r0, sp, #12
90004c48:	bf14      	ite	ne
90004c4a:	2101      	movne	r1, #1
90004c4c:	2100      	moveq	r1, #0
90004c4e:	f7fe ff03 	bl	90003a58 <chk_lock>
90004c52:	4604      	mov	r4, r0
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
90004c54:	f018 0f1c 	tst.w	r8, #28
90004c58:	d076      	beq.n	90004d48 <f_open+0x158>
			if (res != FR_OK) {					/* No file, create new */
90004c5a:	2c00      	cmp	r4, #0
90004c5c:	d054      	beq.n	90004d08 <f_open+0x118>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
90004c5e:	2c04      	cmp	r4, #4
90004c60:	d146      	bne.n	90004cf0 <f_open+0x100>
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
90004c62:	4b6e      	ldr	r3, [pc, #440]	; (90004e1c <f_open+0x22c>)
90004c64:	681a      	ldr	r2, [r3, #0]
90004c66:	b11a      	cbz	r2, 90004c70 <f_open+0x80>
90004c68:	691b      	ldr	r3, [r3, #16]
90004c6a:	2b00      	cmp	r3, #0
90004c6c:	f040 80c9 	bne.w	90004e02 <f_open+0x212>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
90004c70:	a803      	add	r0, sp, #12
90004c72:	f7ff fd1d 	bl	900046b0 <dir_register>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
90004c76:	4604      	mov	r4, r0
90004c78:	2800      	cmp	r0, #0
90004c7a:	d139      	bne.n	90004cf0 <f_open+0x100>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
90004c7c:	f046 0608 	orr.w	r6, r6, #8
				dw = GET_FATTIME();
90004c80:	f7fe fed2 	bl	90003a28 <get_fattime>
90004c84:	4601      	mov	r1, r0
					}
				} else
#endif
				{
					/* Clean directory info */
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
90004c86:	9000      	str	r0, [sp, #0]
90004c88:	980b      	ldr	r0, [sp, #44]	; 0x2c
90004c8a:	300e      	adds	r0, #14
90004c8c:	f7fe fed6 	bl	90003a3c <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
90004c90:	980b      	ldr	r0, [sp, #44]	; 0x2c
90004c92:	9900      	ldr	r1, [sp, #0]
90004c94:	3016      	adds	r0, #22
90004c96:	f7fe fed1 	bl	90003a3c <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
90004c9a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
90004c9c:	2220      	movs	r2, #32
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
90004c9e:	9c02      	ldr	r4, [sp, #8]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
90004ca0:	72da      	strb	r2, [r3, #11]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
90004ca2:	990b      	ldr	r1, [sp, #44]	; 0x2c
90004ca4:	7820      	ldrb	r0, [r4, #0]
90004ca6:	f7fe ffdc 	bl	90003c62 <ld_clust.isra.0>
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
90004caa:	2200      	movs	r2, #0
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
90004cac:	4680      	mov	r8, r0
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
90004cae:	4620      	mov	r0, r4
90004cb0:	f7fe ffe6 	bl	90003c80 <st_clust.isra.0>
					st_dword(dj.dir + DIR_FileSize, 0);
90004cb4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
90004cb6:	2200      	movs	r2, #0
					fs->wflag = 1;
90004cb8:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
90004cba:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
90004cbc:	775a      	strb	r2, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
90004cbe:	779a      	strb	r2, [r3, #30]
	*ptr++ = (BYTE)val;
90004cc0:	77da      	strb	r2, [r3, #31]
					fs->wflag = 1;
90004cc2:	9b02      	ldr	r3, [sp, #8]
90004cc4:	70d9      	strb	r1, [r3, #3]

					if (cl) {							/* Remove the cluster chain if exist */
90004cc6:	f1b8 0f00 	cmp.w	r8, #0
90004cca:	d028      	beq.n	90004d1e <f_open+0x12e>
						dw = fs->winsect;
						res = remove_chain(&dj.obj, cl, 0);
90004ccc:	4641      	mov	r1, r8
90004cce:	a803      	add	r0, sp, #12
						dw = fs->winsect;
90004cd0:	f8d3 9030 	ldr.w	r9, [r3, #48]	; 0x30
						res = remove_chain(&dj.obj, cl, 0);
90004cd4:	f7ff fb41 	bl	9000435a <remove_chain>
						if (res == FR_OK) {
90004cd8:	4604      	mov	r4, r0
90004cda:	b948      	cbnz	r0, 90004cf0 <f_open+0x100>
							res = move_window(fs, dw);
90004cdc:	4649      	mov	r1, r9
90004cde:	9802      	ldr	r0, [sp, #8]
90004ce0:	f7ff f806 	bl	90003cf0 <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
90004ce4:	f108 33ff 	add.w	r3, r8, #4294967295
90004ce8:	9a02      	ldr	r2, [sp, #8]
						res = FR_DENIED;
					}
				}
			}
		}
		if (res == FR_OK) {
90004cea:	4604      	mov	r4, r0
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
90004cec:	6113      	str	r3, [r2, #16]
		if (res == FR_OK) {
90004cee:	b1b0      	cbz	r0, 90004d1e <f_open+0x12e>
				}
			}
#endif
		}

		FREE_NAMBUF();
90004cf0:	4638      	mov	r0, r7
90004cf2:	f000 fb15 	bl	90005320 <ff_memfree>
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
90004cf6:	b10c      	cbz	r4, 90004cfc <f_open+0x10c>
90004cf8:	2300      	movs	r3, #0
90004cfa:	602b      	str	r3, [r5, #0]

	LEAVE_FF(fs, res);
}
90004cfc:	4620      	mov	r0, r4
90004cfe:	b011      	add	sp, #68	; 0x44
90004d00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				res = FR_INVALID_NAME;
90004d04:	2406      	movs	r4, #6
90004d06:	e7a5      	b.n	90004c54 <f_open+0x64>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
90004d08:	f89d 3012 	ldrb.w	r3, [sp, #18]
90004d0c:	f013 0f11 	tst.w	r3, #17
90004d10:	d125      	bne.n	90004d5e <f_open+0x16e>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
90004d12:	f018 0f04 	tst.w	r8, #4
90004d16:	d176      	bne.n	90004e06 <f_open+0x216>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
90004d18:	f018 0f08 	tst.w	r8, #8
90004d1c:	d1b0      	bne.n	90004c80 <f_open+0x90>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
90004d1e:	0730      	lsls	r0, r6, #28
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
90004d20:	9b02      	ldr	r3, [sp, #8]
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
90004d22:	a803      	add	r0, sp, #12
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
90004d24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
				mode |= FA_MODIFIED;
90004d26:	bf48      	it	mi
90004d28:	f046 0640 	orrmi.w	r6, r6, #64	; 0x40
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
90004d2c:	626b      	str	r3, [r5, #36]	; 0x24
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
90004d2e:	f016 0ffe 	tst.w	r6, #254	; 0xfe
			fp->dir_ptr = dj.dir;
90004d32:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
90004d34:	bf14      	ite	ne
90004d36:	2101      	movne	r1, #1
90004d38:	2100      	moveq	r1, #0
			fp->dir_ptr = dj.dir;
90004d3a:	62ab      	str	r3, [r5, #40]	; 0x28
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
90004d3c:	f7fe fec6 	bl	90003acc <inc_lock>
90004d40:	6128      	str	r0, [r5, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
90004d42:	b970      	cbnz	r0, 90004d62 <f_open+0x172>
90004d44:	2402      	movs	r4, #2
90004d46:	e7d3      	b.n	90004cf0 <f_open+0x100>
			if (res == FR_OK) {					/* Following succeeded */
90004d48:	2c00      	cmp	r4, #0
90004d4a:	d1d1      	bne.n	90004cf0 <f_open+0x100>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
90004d4c:	f89d 3012 	ldrb.w	r3, [sp, #18]
90004d50:	06da      	lsls	r2, r3, #27
90004d52:	d45a      	bmi.n	90004e0a <f_open+0x21a>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
90004d54:	f018 0f02 	tst.w	r8, #2
90004d58:	d0e1      	beq.n	90004d1e <f_open+0x12e>
90004d5a:	07dc      	lsls	r4, r3, #31
90004d5c:	d5df      	bpl.n	90004d1e <f_open+0x12e>
					res = FR_DENIED;
90004d5e:	2407      	movs	r4, #7
90004d60:	e7c6      	b.n	90004cf0 <f_open+0x100>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
90004d62:	9c02      	ldr	r4, [sp, #8]
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
90004d64:	f105 0830 	add.w	r8, r5, #48	; 0x30
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
90004d68:	990b      	ldr	r1, [sp, #44]	; 0x2c
90004d6a:	7820      	ldrb	r0, [r4, #0]
90004d6c:	f7fe ff79 	bl	90003c62 <ld_clust.isra.0>
90004d70:	60a8      	str	r0, [r5, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
90004d72:	f101 001c 	add.w	r0, r1, #28
90004d76:	f7fe fe59 	bl	90003a2c <ld_dword>
			fp->obj.id = fs->id;
90004d7a:	88e3      	ldrh	r3, [r4, #6]
			fp->cltbl = 0;			/* Disable fast seek mode */
90004d7c:	2100      	movs	r1, #0
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
90004d7e:	f44f 7200 	mov.w	r2, #512	; 0x200
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
90004d82:	60e8      	str	r0, [r5, #12]
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
90004d84:	4640      	mov	r0, r8
			fp->cltbl = 0;			/* Disable fast seek mode */
90004d86:	62e9      	str	r1, [r5, #44]	; 0x2c
			fp->obj.fs = fs;	 	/* Validate the file object */
90004d88:	602c      	str	r4, [r5, #0]
			fp->obj.id = fs->id;
90004d8a:	80ab      	strh	r3, [r5, #4]
			fp->flag = mode;		/* Set file access mode */
90004d8c:	752e      	strb	r6, [r5, #20]
			fp->err = 0;			/* Clear error flag */
90004d8e:	7569      	strb	r1, [r5, #21]
			fp->sect = 0;			/* Invalidate current data sector */
90004d90:	6229      	str	r1, [r5, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
90004d92:	61a9      	str	r1, [r5, #24]
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
90004d94:	f7fe fe5a 	bl	90003a4c <mem_set>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
90004d98:	06b2      	lsls	r2, r6, #26
90004d9a:	d401      	bmi.n	90004da0 <f_open+0x1b0>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
90004d9c:	2400      	movs	r4, #0
90004d9e:	e7a7      	b.n	90004cf0 <f_open+0x100>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
90004da0:	68ee      	ldr	r6, [r5, #12]
90004da2:	2e00      	cmp	r6, #0
90004da4:	d0fa      	beq.n	90004d9c <f_open+0x1ac>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
90004da6:	9b02      	ldr	r3, [sp, #8]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
90004da8:	68a9      	ldr	r1, [r5, #8]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
90004daa:	895c      	ldrh	r4, [r3, #10]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
90004dac:	61ae      	str	r6, [r5, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
90004dae:	0264      	lsls	r4, r4, #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
90004db0:	42b4      	cmp	r4, r6
90004db2:	d319      	bcc.n	90004de8 <f_open+0x1f8>
90004db4:	2400      	movs	r4, #0
				fp->clust = clst;
90004db6:	61e9      	str	r1, [r5, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
90004db8:	2c00      	cmp	r4, #0
90004dba:	d199      	bne.n	90004cf0 <f_open+0x100>
90004dbc:	f3c6 0308 	ubfx	r3, r6, #0, #9
90004dc0:	2b00      	cmp	r3, #0
90004dc2:	d0eb      	beq.n	90004d9c <f_open+0x1ac>
					if ((sc = clust2sect(fs, clst)) == 0) {
90004dc4:	9c02      	ldr	r4, [sp, #8]
90004dc6:	4620      	mov	r0, r4
90004dc8:	f7fe fee0 	bl	90003b8c <clust2sect>
90004dcc:	2800      	cmp	r0, #0
90004dce:	d0b9      	beq.n	90004d44 <f_open+0x154>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
90004dd0:	eb00 2256 	add.w	r2, r0, r6, lsr #9
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
90004dd4:	2301      	movs	r3, #1
90004dd6:	4641      	mov	r1, r8
						fp->sect = sc + (DWORD)(ofs / SS(fs));
90004dd8:	622a      	str	r2, [r5, #32]
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
90004dda:	7860      	ldrb	r0, [r4, #1]
90004ddc:	f7fe fdfa 	bl	900039d4 <disk_read>
						res = FR_DENIED;
90004de0:	1e04      	subs	r4, r0, #0
90004de2:	bf18      	it	ne
90004de4:	2401      	movne	r4, #1
90004de6:	e783      	b.n	90004cf0 <f_open+0x100>
					clst = get_fat(&fp->obj, clst);
90004de8:	6828      	ldr	r0, [r5, #0]
90004dea:	1b36      	subs	r6, r6, r4
90004dec:	f7ff f9c2 	bl	90004174 <get_fat.isra.0>
					if (clst <= 1) res = FR_INT_ERR;
90004df0:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
90004df2:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
90004df4:	d903      	bls.n	90004dfe <f_open+0x20e>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
90004df6:	1c43      	adds	r3, r0, #1
90004df8:	d1da      	bne.n	90004db0 <f_open+0x1c0>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
90004dfa:	2401      	movs	r4, #1
90004dfc:	e7db      	b.n	90004db6 <f_open+0x1c6>
					if (clst <= 1) res = FR_INT_ERR;
90004dfe:	2402      	movs	r4, #2
90004e00:	e7d9      	b.n	90004db6 <f_open+0x1c6>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
90004e02:	2412      	movs	r4, #18
90004e04:	e774      	b.n	90004cf0 <f_open+0x100>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
90004e06:	2408      	movs	r4, #8
90004e08:	e772      	b.n	90004cf0 <f_open+0x100>
					res = FR_NO_FILE;
90004e0a:	2404      	movs	r4, #4
90004e0c:	e770      	b.n	90004cf0 <f_open+0x100>
90004e0e:	4604      	mov	r4, r0
90004e10:	e772      	b.n	90004cf8 <f_open+0x108>
	if (!fp) return FR_INVALID_OBJECT;
90004e12:	2409      	movs	r4, #9
90004e14:	e772      	b.n	90004cfc <f_open+0x10c>
		INIT_NAMBUF(fs);
90004e16:	2411      	movs	r4, #17
90004e18:	e770      	b.n	90004cfc <f_open+0x10c>
90004e1a:	bf00      	nop
90004e1c:	20000408 	.word	0x20000408

90004e20 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
90004e20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90004e24:	b087      	sub	sp, #28
90004e26:	4616      	mov	r6, r2
90004e28:	4689      	mov	r9, r1
90004e2a:	4604      	mov	r4, r0
90004e2c:	9301      	str	r3, [sp, #4]
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
90004e2e:	2300      	movs	r3, #0
90004e30:	9a01      	ldr	r2, [sp, #4]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
90004e32:	a905      	add	r1, sp, #20
	*br = 0;	/* Clear read byte counter */
90004e34:	6013      	str	r3, [r2, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
90004e36:	f7fe fef1 	bl	90003c1c <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
90004e3a:	4605      	mov	r5, r0
90004e3c:	bb18      	cbnz	r0, 90004e86 <f_read+0x66>
90004e3e:	7d65      	ldrb	r5, [r4, #21]
90004e40:	bb0d      	cbnz	r5, 90004e86 <f_read+0x66>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
90004e42:	7d23      	ldrb	r3, [r4, #20]
90004e44:	f013 0301 	ands.w	r3, r3, #1
90004e48:	9302      	str	r3, [sp, #8]
90004e4a:	f000 8099 	beq.w	90004f80 <f_read+0x160>
	remain = fp->obj.objsize - fp->fptr;
90004e4e:	68e2      	ldr	r2, [r4, #12]
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
90004e50:	f104 0a30 	add.w	sl, r4, #48	; 0x30
	remain = fp->obj.objsize - fp->fptr;
90004e54:	69a3      	ldr	r3, [r4, #24]
90004e56:	1ad2      	subs	r2, r2, r3
90004e58:	4296      	cmp	r6, r2
90004e5a:	bf28      	it	cs
90004e5c:	4616      	movcs	r6, r2
	for ( ;  btr;								/* Repeat until all data read */
90004e5e:	b196      	cbz	r6, 90004e86 <f_read+0x66>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
90004e60:	69a1      	ldr	r1, [r4, #24]
90004e62:	f3c1 0308 	ubfx	r3, r1, #0, #9
90004e66:	2b00      	cmp	r3, #0
90004e68:	d17c      	bne.n	90004f64 <f_read+0x144>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
90004e6a:	9b05      	ldr	r3, [sp, #20]
90004e6c:	f8b3 800a 	ldrh.w	r8, [r3, #10]
90004e70:	f108 38ff 	add.w	r8, r8, #4294967295
			if (csect == 0) {					/* On the cluster boundary? */
90004e74:	ea18 2851 	ands.w	r8, r8, r1, lsr #9
90004e78:	d11b      	bne.n	90004eb2 <f_read+0x92>
				if (fp->fptr == 0) {			/* On the top of the file? */
90004e7a:	b941      	cbnz	r1, 90004e8e <f_read+0x6e>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
90004e7c:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
90004e7e:	2801      	cmp	r0, #1
90004e80:	d810      	bhi.n	90004ea4 <f_read+0x84>
90004e82:	2502      	movs	r5, #2
90004e84:	7565      	strb	r5, [r4, #21]
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
90004e86:	4628      	mov	r0, r5
90004e88:	b007      	add	sp, #28
90004e8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (fp->cltbl) {
90004e8e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90004e90:	b11b      	cbz	r3, 90004e9a <f_read+0x7a>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
90004e92:	4620      	mov	r0, r4
90004e94:	f7fe fe85 	bl	90003ba2 <clmt_clust>
90004e98:	e7f1      	b.n	90004e7e <f_read+0x5e>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
90004e9a:	69e1      	ldr	r1, [r4, #28]
90004e9c:	6820      	ldr	r0, [r4, #0]
90004e9e:	f7ff f969 	bl	90004174 <get_fat.isra.0>
90004ea2:	e7ec      	b.n	90004e7e <f_read+0x5e>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
90004ea4:	1c43      	adds	r3, r0, #1
90004ea6:	d103      	bne.n	90004eb0 <f_read+0x90>
90004ea8:	2301      	movs	r3, #1
90004eaa:	9d02      	ldr	r5, [sp, #8]
90004eac:	7563      	strb	r3, [r4, #21]
90004eae:	e7ea      	b.n	90004e86 <f_read+0x66>
				fp->clust = clst;				/* Update current cluster */
90004eb0:	61e0      	str	r0, [r4, #28]
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
90004eb2:	f8dd b014 	ldr.w	fp, [sp, #20]
90004eb6:	69e1      	ldr	r1, [r4, #28]
90004eb8:	4658      	mov	r0, fp
90004eba:	f7fe fe67 	bl	90003b8c <clust2sect>
			if (!sect) ABORT(fs, FR_INT_ERR);
90004ebe:	2800      	cmp	r0, #0
90004ec0:	d0df      	beq.n	90004e82 <f_read+0x62>
			if (cc) {							/* Read maximum contiguous sectors directly */
90004ec2:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
			sect += csect;
90004ec6:	eb08 0700 	add.w	r7, r8, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
90004eca:	d32e      	bcc.n	90004f2a <f_read+0x10a>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
90004ecc:	f8bb 200a 	ldrh.w	r2, [fp, #10]
90004ed0:	eb08 2156 	add.w	r1, r8, r6, lsr #9
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
90004ed4:	0a73      	lsrs	r3, r6, #9
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
90004ed6:	f89b 0001 	ldrb.w	r0, [fp, #1]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
90004eda:	4291      	cmp	r1, r2
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
90004edc:	4649      	mov	r1, r9
					cc = fs->csize - csect;
90004ede:	bf88      	it	hi
90004ee0:	eba2 0308 	subhi.w	r3, r2, r8
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
90004ee4:	463a      	mov	r2, r7
90004ee6:	9303      	str	r3, [sp, #12]
90004ee8:	f7fe fd74 	bl	900039d4 <disk_read>
90004eec:	2800      	cmp	r0, #0
90004eee:	d1db      	bne.n	90004ea8 <f_read+0x88>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
90004ef0:	f994 2014 	ldrsb.w	r2, [r4, #20]
90004ef4:	9b03      	ldr	r3, [sp, #12]
90004ef6:	2a00      	cmp	r2, #0
90004ef8:	da0b      	bge.n	90004f12 <f_read+0xf2>
90004efa:	6a20      	ldr	r0, [r4, #32]
90004efc:	1bc0      	subs	r0, r0, r7
90004efe:	4298      	cmp	r0, r3
90004f00:	d207      	bcs.n	90004f12 <f_read+0xf2>
	if (cnt) {
90004f02:	f44f 7200 	mov.w	r2, #512	; 0x200
90004f06:	4651      	mov	r1, sl
90004f08:	eb09 2040 	add.w	r0, r9, r0, lsl #9
90004f0c:	f7fe fea0 	bl	90003c50 <mem_cpy.part.0>
90004f10:	9b03      	ldr	r3, [sp, #12]
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
90004f12:	025f      	lsls	r7, r3, #9
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
90004f14:	69a3      	ldr	r3, [r4, #24]
90004f16:	44b9      	add	r9, r7
90004f18:	9a01      	ldr	r2, [sp, #4]
90004f1a:	1bf6      	subs	r6, r6, r7
90004f1c:	443b      	add	r3, r7
90004f1e:	61a3      	str	r3, [r4, #24]
90004f20:	9b01      	ldr	r3, [sp, #4]
90004f22:	681b      	ldr	r3, [r3, #0]
90004f24:	443b      	add	r3, r7
90004f26:	6013      	str	r3, [r2, #0]
90004f28:	e799      	b.n	90004e5e <f_read+0x3e>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
90004f2a:	6a22      	ldr	r2, [r4, #32]
90004f2c:	42ba      	cmp	r2, r7
90004f2e:	d018      	beq.n	90004f62 <f_read+0x142>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
90004f30:	f994 3014 	ldrsb.w	r3, [r4, #20]
90004f34:	2b00      	cmp	r3, #0
90004f36:	da0b      	bge.n	90004f50 <f_read+0x130>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
90004f38:	2301      	movs	r3, #1
90004f3a:	4651      	mov	r1, sl
90004f3c:	f89b 0001 	ldrb.w	r0, [fp, #1]
90004f40:	f7fe fd56 	bl	900039f0 <disk_write>
90004f44:	2800      	cmp	r0, #0
90004f46:	d1af      	bne.n	90004ea8 <f_read+0x88>
					fp->flag &= (BYTE)~FA_DIRTY;
90004f48:	7d23      	ldrb	r3, [r4, #20]
90004f4a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90004f4e:	7523      	strb	r3, [r4, #20]
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
90004f50:	9805      	ldr	r0, [sp, #20]
90004f52:	2301      	movs	r3, #1
90004f54:	463a      	mov	r2, r7
90004f56:	4651      	mov	r1, sl
90004f58:	7840      	ldrb	r0, [r0, #1]
90004f5a:	f7fe fd3b 	bl	900039d4 <disk_read>
90004f5e:	2800      	cmp	r0, #0
90004f60:	d1a2      	bne.n	90004ea8 <f_read+0x88>
			fp->sect = sect;
90004f62:	6227      	str	r7, [r4, #32]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
90004f64:	69a1      	ldr	r1, [r4, #24]
90004f66:	4648      	mov	r0, r9
90004f68:	f3c1 0108 	ubfx	r1, r1, #0, #9
90004f6c:	f5c1 7700 	rsb	r7, r1, #512	; 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
90004f70:	4451      	add	r1, sl
90004f72:	42b7      	cmp	r7, r6
90004f74:	bf28      	it	cs
90004f76:	4637      	movcs	r7, r6
	if (cnt) {
90004f78:	463a      	mov	r2, r7
90004f7a:	f7fe fe69 	bl	90003c50 <mem_cpy.part.0>
}
90004f7e:	e7c9      	b.n	90004f14 <f_read+0xf4>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
90004f80:	2507      	movs	r5, #7
90004f82:	e780      	b.n	90004e86 <f_read+0x66>

90004f84 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
90004f84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90004f88:	4699      	mov	r9, r3
90004f8a:	b085      	sub	sp, #20
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
90004f8c:	2300      	movs	r3, #0
{
90004f8e:	4688      	mov	r8, r1
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
90004f90:	a903      	add	r1, sp, #12
{
90004f92:	4604      	mov	r4, r0
	*bw = 0;	/* Clear write byte counter */
90004f94:	f8c9 3000 	str.w	r3, [r9]
{
90004f98:	4616      	mov	r6, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
90004f9a:	f7fe fe3f 	bl	90003c1c <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
90004f9e:	4605      	mov	r5, r0
90004fa0:	bb50      	cbnz	r0, 90004ff8 <f_write+0x74>
90004fa2:	7d65      	ldrb	r5, [r4, #21]
90004fa4:	bb45      	cbnz	r5, 90004ff8 <f_write+0x74>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
90004fa6:	7d23      	ldrb	r3, [r4, #20]
90004fa8:	079a      	lsls	r2, r3, #30
90004faa:	f140 80af 	bpl.w	9000510c <f_write+0x188>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
90004fae:	69a3      	ldr	r3, [r4, #24]
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
90004fb0:	f104 0a30 	add.w	sl, r4, #48	; 0x30
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
90004fb4:	42f3      	cmn	r3, r6
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
90004fb6:	bf28      	it	cs
90004fb8:	43de      	mvncs	r6, r3
	for ( ;  btw;							/* Repeat until all data written */
90004fba:	b1ce      	cbz	r6, 90004ff0 <f_write+0x6c>
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
90004fbc:	69a1      	ldr	r1, [r4, #24]
90004fbe:	f3c1 0308 	ubfx	r3, r1, #0, #9
90004fc2:	2b00      	cmp	r3, #0
90004fc4:	f040 8090 	bne.w	900050e8 <f_write+0x164>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
90004fc8:	9b03      	ldr	r3, [sp, #12]
90004fca:	895f      	ldrh	r7, [r3, #10]
90004fcc:	3f01      	subs	r7, #1
			if (csect == 0) {				/* On the cluster boundary? */
90004fce:	ea17 2751 	ands.w	r7, r7, r1, lsr #9
90004fd2:	d124      	bne.n	9000501e <f_write+0x9a>
				if (fp->fptr == 0) {		/* On the top of the file? */
90004fd4:	b931      	cbnz	r1, 90004fe4 <f_write+0x60>
					clst = fp->obj.sclust;	/* Follow from the origin */
90004fd6:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
90004fd8:	b9a0      	cbnz	r0, 90005004 <f_write+0x80>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
90004fda:	4601      	mov	r1, r0
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
90004fdc:	4620      	mov	r0, r4
90004fde:	f7ff f964 	bl	900042aa <create_chain>
90004fe2:	e004      	b.n	90004fee <f_write+0x6a>
					if (fp->cltbl) {
90004fe4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
90004fe6:	b15b      	cbz	r3, 90005000 <f_write+0x7c>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
90004fe8:	4620      	mov	r0, r4
90004fea:	f7fe fdda 	bl	90003ba2 <clmt_clust>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
90004fee:	b948      	cbnz	r0, 90005004 <f_write+0x80>
		fp->flag |= FA_DIRTY;
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
90004ff0:	7d23      	ldrb	r3, [r4, #20]
90004ff2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
90004ff6:	7523      	strb	r3, [r4, #20]

	LEAVE_FF(fs, FR_OK);
}
90004ff8:	4628      	mov	r0, r5
90004ffa:	b005      	add	sp, #20
90004ffc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
90005000:	69e1      	ldr	r1, [r4, #28]
90005002:	e7eb      	b.n	90004fdc <f_write+0x58>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
90005004:	2801      	cmp	r0, #1
90005006:	d102      	bne.n	9000500e <f_write+0x8a>
90005008:	2502      	movs	r5, #2
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
9000500a:	7565      	strb	r5, [r4, #21]
9000500c:	e7f4      	b.n	90004ff8 <f_write+0x74>
9000500e:	1c43      	adds	r3, r0, #1
90005010:	d101      	bne.n	90005016 <f_write+0x92>
90005012:	2501      	movs	r5, #1
90005014:	e7f9      	b.n	9000500a <f_write+0x86>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
90005016:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
90005018:	61e0      	str	r0, [r4, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
9000501a:	b903      	cbnz	r3, 9000501e <f_write+0x9a>
9000501c:	60a0      	str	r0, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
9000501e:	f994 3014 	ldrsb.w	r3, [r4, #20]
90005022:	2b00      	cmp	r3, #0
90005024:	da0c      	bge.n	90005040 <f_write+0xbc>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
90005026:	9803      	ldr	r0, [sp, #12]
90005028:	2301      	movs	r3, #1
9000502a:	6a22      	ldr	r2, [r4, #32]
9000502c:	4651      	mov	r1, sl
9000502e:	7840      	ldrb	r0, [r0, #1]
90005030:	f7fe fcde 	bl	900039f0 <disk_write>
90005034:	2800      	cmp	r0, #0
90005036:	d1ec      	bne.n	90005012 <f_write+0x8e>
				fp->flag &= (BYTE)~FA_DIRTY;
90005038:	7d23      	ldrb	r3, [r4, #20]
9000503a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9000503e:	7523      	strb	r3, [r4, #20]
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
90005040:	f8dd b00c 	ldr.w	fp, [sp, #12]
90005044:	69e1      	ldr	r1, [r4, #28]
90005046:	4658      	mov	r0, fp
90005048:	f7fe fda0 	bl	90003b8c <clust2sect>
			if (!sect) ABORT(fs, FR_INT_ERR);
9000504c:	2800      	cmp	r0, #0
9000504e:	d0db      	beq.n	90005008 <f_write+0x84>
			if (cc) {						/* Write maximum contiguous sectors directly */
90005050:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
			sect += csect;
90005054:	eb07 0200 	add.w	r2, r7, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
90005058:	d334      	bcc.n	900050c4 <f_write+0x140>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
9000505a:	f8bb 100a 	ldrh.w	r1, [fp, #10]
9000505e:	eb07 2056 	add.w	r0, r7, r6, lsr #9
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
90005062:	0a73      	lsrs	r3, r6, #9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
90005064:	4288      	cmp	r0, r1
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
90005066:	f89b 0001 	ldrb.w	r0, [fp, #1]
					cc = fs->csize - csect;
9000506a:	bf88      	it	hi
9000506c:	1bcb      	subhi	r3, r1, r7
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
9000506e:	4641      	mov	r1, r8
90005070:	e9cd 2300 	strd	r2, r3, [sp]
90005074:	f7fe fcbc 	bl	900039f0 <disk_write>
90005078:	2800      	cmp	r0, #0
9000507a:	d1ca      	bne.n	90005012 <f_write+0x8e>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9000507c:	6a21      	ldr	r1, [r4, #32]
9000507e:	9a00      	ldr	r2, [sp, #0]
90005080:	9b01      	ldr	r3, [sp, #4]
90005082:	1a89      	subs	r1, r1, r2
90005084:	4299      	cmp	r1, r3
90005086:	d20c      	bcs.n	900050a2 <f_write+0x11e>
90005088:	f44f 7200 	mov.w	r2, #512	; 0x200
9000508c:	eb08 2141 	add.w	r1, r8, r1, lsl #9
90005090:	4650      	mov	r0, sl
90005092:	9300      	str	r3, [sp, #0]
	if (cnt) {
90005094:	f7fe fddc 	bl	90003c50 <mem_cpy.part.0>
					fp->flag &= (BYTE)~FA_DIRTY;
90005098:	7d22      	ldrb	r2, [r4, #20]
9000509a:	9b00      	ldr	r3, [sp, #0]
9000509c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
900050a0:	7522      	strb	r2, [r4, #20]
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
900050a2:	025f      	lsls	r7, r3, #9
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
900050a4:	69a3      	ldr	r3, [r4, #24]
900050a6:	44b8      	add	r8, r7
900050a8:	68e2      	ldr	r2, [r4, #12]
900050aa:	1bf6      	subs	r6, r6, r7
900050ac:	443b      	add	r3, r7
900050ae:	61a3      	str	r3, [r4, #24]
900050b0:	429a      	cmp	r2, r3
900050b2:	bf2c      	ite	cs
900050b4:	60e2      	strcs	r2, [r4, #12]
900050b6:	60e3      	strcc	r3, [r4, #12]
900050b8:	f8d9 3000 	ldr.w	r3, [r9]
900050bc:	443b      	add	r3, r7
900050be:	f8c9 3000 	str.w	r3, [r9]
900050c2:	e77a      	b.n	90004fba <f_write+0x36>
			if (fp->sect != sect && 		/* Fill sector cache with file data */
900050c4:	6a23      	ldr	r3, [r4, #32]
900050c6:	4293      	cmp	r3, r2
900050c8:	d00d      	beq.n	900050e6 <f_write+0x162>
900050ca:	68e1      	ldr	r1, [r4, #12]
900050cc:	69a3      	ldr	r3, [r4, #24]
900050ce:	4299      	cmp	r1, r3
900050d0:	d909      	bls.n	900050e6 <f_write+0x162>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
900050d2:	2301      	movs	r3, #1
900050d4:	4651      	mov	r1, sl
900050d6:	f89b 0001 	ldrb.w	r0, [fp, #1]
900050da:	9200      	str	r2, [sp, #0]
900050dc:	f7fe fc7a 	bl	900039d4 <disk_read>
				fp->fptr < fp->obj.objsize &&
900050e0:	9a00      	ldr	r2, [sp, #0]
900050e2:	2800      	cmp	r0, #0
900050e4:	d195      	bne.n	90005012 <f_write+0x8e>
			fp->sect = sect;
900050e6:	6222      	str	r2, [r4, #32]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
900050e8:	69a0      	ldr	r0, [r4, #24]
900050ea:	4641      	mov	r1, r8
900050ec:	f3c0 0008 	ubfx	r0, r0, #0, #9
900050f0:	f5c0 7700 	rsb	r7, r0, #512	; 0x200
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
900050f4:	4450      	add	r0, sl
900050f6:	42b7      	cmp	r7, r6
900050f8:	bf28      	it	cs
900050fa:	4637      	movcs	r7, r6
	if (cnt) {
900050fc:	463a      	mov	r2, r7
900050fe:	f7fe fda7 	bl	90003c50 <mem_cpy.part.0>
		fp->flag |= FA_DIRTY;
90005102:	7d23      	ldrb	r3, [r4, #20]
90005104:	f063 037f 	orn	r3, r3, #127	; 0x7f
90005108:	7523      	strb	r3, [r4, #20]
9000510a:	e7cb      	b.n	900050a4 <f_write+0x120>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
9000510c:	2507      	movs	r5, #7
9000510e:	e773      	b.n	90004ff8 <f_write+0x74>

90005110 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
90005110:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
90005112:	a901      	add	r1, sp, #4
{
90005114:	4605      	mov	r5, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
90005116:	f7fe fd81 	bl	90003c1c <validate>
	if (res == FR_OK) {
9000511a:	4604      	mov	r4, r0
9000511c:	2800      	cmp	r0, #0
9000511e:	d13b      	bne.n	90005198 <f_sync+0x88>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
90005120:	7d2b      	ldrb	r3, [r5, #20]
90005122:	f013 0440 	ands.w	r4, r3, #64	; 0x40
90005126:	d037      	beq.n	90005198 <f_sync+0x88>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
90005128:	061b      	lsls	r3, r3, #24
9000512a:	d50c      	bpl.n	90005146 <f_sync+0x36>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
9000512c:	9801      	ldr	r0, [sp, #4]
9000512e:	2301      	movs	r3, #1
90005130:	6a2a      	ldr	r2, [r5, #32]
90005132:	f105 0130 	add.w	r1, r5, #48	; 0x30
90005136:	7840      	ldrb	r0, [r0, #1]
90005138:	f7fe fc5a 	bl	900039f0 <disk_write>
9000513c:	bb78      	cbnz	r0, 9000519e <f_sync+0x8e>
				fp->flag &= (BYTE)~FA_DIRTY;
9000513e:	7d2b      	ldrb	r3, [r5, #20]
90005140:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90005144:	752b      	strb	r3, [r5, #20]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
90005146:	f7fe fc6f 	bl	90003a28 <get_fattime>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
9000514a:	6a69      	ldr	r1, [r5, #36]	; 0x24
			tm = GET_FATTIME();				/* Modified time */
9000514c:	4607      	mov	r7, r0
				res = move_window(fs, fp->dir_sect);
9000514e:	9801      	ldr	r0, [sp, #4]
90005150:	f7fe fdce 	bl	90003cf0 <move_window>
				if (res == FR_OK) {
90005154:	4604      	mov	r4, r0
90005156:	b9f8      	cbnz	r0, 90005198 <f_sync+0x88>
					dir = fp->dir_ptr;
90005158:	6aae      	ldr	r6, [r5, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
9000515a:	7af3      	ldrb	r3, [r6, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
9000515c:	4631      	mov	r1, r6
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
9000515e:	f043 0320 	orr.w	r3, r3, #32
90005162:	72f3      	strb	r3, [r6, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
90005164:	68aa      	ldr	r2, [r5, #8]
90005166:	6828      	ldr	r0, [r5, #0]
90005168:	f7fe fd8a 	bl	90003c80 <st_clust.isra.0>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
9000516c:	68e9      	ldr	r1, [r5, #12]
9000516e:	f106 001c 	add.w	r0, r6, #28
90005172:	f7fe fc63 	bl	90003a3c <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
90005176:	4639      	mov	r1, r7
90005178:	f106 0016 	add.w	r0, r6, #22
9000517c:	f7fe fc5e 	bl	90003a3c <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
90005180:	2301      	movs	r3, #1
90005182:	9801      	ldr	r0, [sp, #4]
	*ptr++ = (BYTE)val; val >>= 8;
90005184:	74b4      	strb	r4, [r6, #18]
	*ptr++ = (BYTE)val;
90005186:	74f4      	strb	r4, [r6, #19]
					fs->wflag = 1;
90005188:	70c3      	strb	r3, [r0, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
9000518a:	f7ff f91e 	bl	900043ca <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
9000518e:	7d2b      	ldrb	r3, [r5, #20]
					res = sync_fs(fs);					/* Restore it to the directory */
90005190:	4604      	mov	r4, r0
					fp->flag &= (BYTE)~FA_MODIFIED;
90005192:	f023 0340 	bic.w	r3, r3, #64	; 0x40
90005196:	752b      	strb	r3, [r5, #20]
			}
		}
	}

	LEAVE_FF(fs, res);
}
90005198:	4620      	mov	r0, r4
9000519a:	b003      	add	sp, #12
9000519c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
9000519e:	2401      	movs	r4, #1
900051a0:	e7fa      	b.n	90005198 <f_sync+0x88>

900051a2 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
900051a2:	b513      	push	{r0, r1, r4, lr}
900051a4:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
900051a6:	f7ff ffb3 	bl	90005110 <f_sync>
	if (res == FR_OK)
900051aa:	b948      	cbnz	r0, 900051c0 <f_close+0x1e>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
900051ac:	a901      	add	r1, sp, #4
900051ae:	4620      	mov	r0, r4
900051b0:	f7fe fd34 	bl	90003c1c <validate>
		if (res == FR_OK) {
900051b4:	b920      	cbnz	r0, 900051c0 <f_close+0x1e>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
900051b6:	6920      	ldr	r0, [r4, #16]
900051b8:	f7fe fcca 	bl	90003b50 <dec_lock>
			if (res == FR_OK)
900051bc:	b900      	cbnz	r0, 900051c0 <f_close+0x1e>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
900051be:	6020      	str	r0, [r4, #0]
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
900051c0:	b002      	add	sp, #8
900051c2:	bd10      	pop	{r4, pc}

900051c4 <FATFS_LinkDriverEx>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
900051c4:	4b0f      	ldr	r3, [pc, #60]	; (90005204 <FATFS_LinkDriverEx+0x40>)
{
900051c6:	b530      	push	{r4, r5, lr}
  if(disk.nbr < _VOLUMES)
900051c8:	7b9c      	ldrb	r4, [r3, #14]
900051ca:	2c01      	cmp	r4, #1
900051cc:	d817      	bhi.n	900051fe <FATFS_LinkDriverEx+0x3a>
  {
    disk.is_initialized[disk.nbr] = 0;
900051ce:	7b9d      	ldrb	r5, [r3, #14]
900051d0:	2400      	movs	r4, #0
900051d2:	b2ed      	uxtb	r5, r5
900051d4:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;
900051d6:	7b9d      	ldrb	r5, [r3, #14]
900051d8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
900051dc:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;
900051de:	7b98      	ldrb	r0, [r3, #14]
900051e0:	4418      	add	r0, r3
900051e2:	7302      	strb	r2, [r0, #12]
    DiskNum = disk.nbr++;
900051e4:	7b9a      	ldrb	r2, [r3, #14]
900051e6:	1c50      	adds	r0, r2, #1
    path[0] = DiskNum + '0';
900051e8:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
900051ea:	b2c0      	uxtb	r0, r0
900051ec:	7398      	strb	r0, [r3, #14]
    path[1] = ':';
900051ee:	233a      	movs	r3, #58	; 0x3a
    path[2] = '/';
    path[3] = 0;
900051f0:	4620      	mov	r0, r4
    path[0] = DiskNum + '0';
900051f2:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
900051f4:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
900051f6:	232f      	movs	r3, #47	; 0x2f
    path[3] = 0;
900051f8:	70cc      	strb	r4, [r1, #3]
    path[2] = '/';
900051fa:	708b      	strb	r3, [r1, #2]
    ret = 0;
  }

  return ret;
}
900051fc:	bd30      	pop	{r4, r5, pc}
  uint8_t ret = 1;
900051fe:	2001      	movs	r0, #1
90005200:	e7fc      	b.n	900051fc <FATFS_LinkDriverEx+0x38>
90005202:	bf00      	nop
90005204:	20000434 	.word	0x20000434

90005208 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
90005208:	2200      	movs	r2, #0
9000520a:	f7ff bfdb 	b.w	900051c4 <FATFS_LinkDriverEx>
	...

90005210 <FATFS_UnLinkDriverEx>:
uint8_t FATFS_UnLinkDriverEx(char *path, uint8_t lun)
{
  uint8_t DiskNum = 0;
  uint8_t ret = 1;

  if(disk.nbr >= 1)
90005210:	4a0a      	ldr	r2, [pc, #40]	; (9000523c <FATFS_UnLinkDriverEx+0x2c>)
90005212:	7b93      	ldrb	r3, [r2, #14]
90005214:	b17b      	cbz	r3, 90005236 <FATFS_UnLinkDriverEx+0x26>
  {
    DiskNum = path[0] - '0';
90005216:	7803      	ldrb	r3, [r0, #0]
90005218:	3b30      	subs	r3, #48	; 0x30
    if(disk.drv[DiskNum] != 0)
9000521a:	b2db      	uxtb	r3, r3
9000521c:	eb02 0183 	add.w	r1, r2, r3, lsl #2
90005220:	6848      	ldr	r0, [r1, #4]
90005222:	b140      	cbz	r0, 90005236 <FATFS_UnLinkDriverEx+0x26>
    {
      disk.drv[DiskNum] = 0;
90005224:	2000      	movs	r0, #0
      disk.lun[DiskNum] = 0;
90005226:	4413      	add	r3, r2
90005228:	7318      	strb	r0, [r3, #12]
      disk.nbr--;
9000522a:	7b93      	ldrb	r3, [r2, #14]
      disk.drv[DiskNum] = 0;
9000522c:	6048      	str	r0, [r1, #4]
      disk.nbr--;
9000522e:	3b01      	subs	r3, #1
90005230:	b2db      	uxtb	r3, r3
90005232:	7393      	strb	r3, [r2, #14]
      ret = 0;
90005234:	4770      	bx	lr
  uint8_t ret = 1;
90005236:	2001      	movs	r0, #1
    }
  }

  return ret;
}
90005238:	4770      	bx	lr
9000523a:	bf00      	nop
9000523c:	20000434 	.word	0x20000434

90005240 <FATFS_UnLinkDriver>:
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriver(char *path)
{
  return FATFS_UnLinkDriverEx(path, 0);
90005240:	2100      	movs	r1, #0
90005242:	f7ff bfe5 	b.w	90005210 <FATFS_UnLinkDriverEx>
	...

90005248 <SD_CheckStatus.isra.0>:
};

/* Private functions ---------------------------------------------------------*/
static DSTATUS SD_CheckStatus(BYTE lun)
{
  Stat = STA_NOINIT;
90005248:	2301      	movs	r3, #1
static DSTATUS SD_CheckStatus(BYTE lun)
9000524a:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
9000524c:	4c05      	ldr	r4, [pc, #20]	; (90005264 <SD_CheckStatus.isra.0+0x1c>)
9000524e:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetCardState() == MSD_OK)
90005250:	f7fb fed4 	bl	90000ffc <BSP_SD_GetCardState>
90005254:	4623      	mov	r3, r4
90005256:	b918      	cbnz	r0, 90005260 <SD_CheckStatus.isra.0+0x18>
  {
    Stat &= ~STA_NOINIT;
90005258:	7822      	ldrb	r2, [r4, #0]
9000525a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
9000525e:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
90005260:	7818      	ldrb	r0, [r3, #0]
}
90005262:	bd10      	pop	{r4, pc}
90005264:	20000038 	.word	0x20000038

90005268 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
90005268:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
9000526a:	2301      	movs	r3, #1
9000526c:	4c04      	ldr	r4, [pc, #16]	; (90005280 <SD_initialize+0x18>)
9000526e:	7023      	strb	r3, [r4, #0]
#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
90005270:	f7fb fe98 	bl	90000fa4 <BSP_SD_Init>
90005274:	b910      	cbnz	r0, 9000527c <SD_initialize+0x14>
  {
    Stat = SD_CheckStatus(lun);
90005276:	f7ff ffe7 	bl	90005248 <SD_CheckStatus.isra.0>
9000527a:	7020      	strb	r0, [r4, #0]
  }

#else
  Stat = SD_CheckStatus(lun);
#endif
  return Stat;
9000527c:	7820      	ldrb	r0, [r4, #0]
}
9000527e:	bd10      	pop	{r4, pc}
90005280:	20000038 	.word	0x20000038

90005284 <SD_status>:
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
  return SD_CheckStatus(lun);
90005284:	f7ff bfe0 	b.w	90005248 <SD_CheckStatus.isra.0>

90005288 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
90005288:	b508      	push	{r3, lr}
9000528a:	4608      	mov	r0, r1
9000528c:	4611      	mov	r1, r2
9000528e:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
90005290:	f04f 33ff 	mov.w	r3, #4294967295
90005294:	f7fb fd92 	bl	90000dbc <BSP_SD_ReadBlocks>
90005298:	b920      	cbnz	r0, 900052a4 <SD_read+0x1c>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
9000529a:	f7fb feaf 	bl	90000ffc <BSP_SD_GetCardState>
9000529e:	2800      	cmp	r0, #0
900052a0:	d1fb      	bne.n	9000529a <SD_read+0x12>
    }
    res = RES_OK;
  }

  return res;
}
900052a2:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
900052a4:	2001      	movs	r0, #1
900052a6:	e7fc      	b.n	900052a2 <SD_read+0x1a>

900052a8 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
900052a8:	4b13      	ldr	r3, [pc, #76]	; (900052f8 <SD_ioctl+0x50>)
{
900052aa:	b530      	push	{r4, r5, lr}
  if (Stat & STA_NOINIT) return RES_NOTRDY;
900052ac:	781c      	ldrb	r4, [r3, #0]
{
900052ae:	b089      	sub	sp, #36	; 0x24
900052b0:	4615      	mov	r5, r2
  if (Stat & STA_NOINIT) return RES_NOTRDY;
900052b2:	f014 0401 	ands.w	r4, r4, #1
900052b6:	d11b      	bne.n	900052f0 <SD_ioctl+0x48>

  switch (cmd)
900052b8:	2903      	cmp	r1, #3
900052ba:	d803      	bhi.n	900052c4 <SD_ioctl+0x1c>
900052bc:	e8df f001 	tbb	[pc, r1]
900052c0:	120c061a 	.word	0x120c061a
  if (Stat & STA_NOINIT) return RES_NOTRDY;
900052c4:	2404      	movs	r4, #4
  default:
    res = RES_PARERR;
  }

  return res;
}
900052c6:	4620      	mov	r0, r4
900052c8:	b009      	add	sp, #36	; 0x24
900052ca:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
900052cc:	4668      	mov	r0, sp
900052ce:	f7fb fe9f 	bl	90001010 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
900052d2:	9b06      	ldr	r3, [sp, #24]
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
900052d4:	602b      	str	r3, [r5, #0]
    break;
900052d6:	e7f6      	b.n	900052c6 <SD_ioctl+0x1e>
    BSP_SD_GetCardInfo(&CardInfo);
900052d8:	4668      	mov	r0, sp
900052da:	f7fb fe99 	bl	90001010 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
900052de:	9b07      	ldr	r3, [sp, #28]
900052e0:	802b      	strh	r3, [r5, #0]
    break;
900052e2:	e7f0      	b.n	900052c6 <SD_ioctl+0x1e>
    BSP_SD_GetCardInfo(&CardInfo);
900052e4:	4668      	mov	r0, sp
900052e6:	f7fb fe93 	bl	90001010 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
900052ea:	9b07      	ldr	r3, [sp, #28]
900052ec:	0a5b      	lsrs	r3, r3, #9
900052ee:	e7f1      	b.n	900052d4 <SD_ioctl+0x2c>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
900052f0:	2403      	movs	r4, #3
900052f2:	e7e8      	b.n	900052c6 <SD_ioctl+0x1e>
    res = RES_OK;
900052f4:	460c      	mov	r4, r1
900052f6:	e7e6      	b.n	900052c6 <SD_ioctl+0x1e>
900052f8:	20000038 	.word	0x20000038

900052fc <SD_write>:
{
900052fc:	b508      	push	{r3, lr}
900052fe:	4608      	mov	r0, r1
90005300:	4611      	mov	r1, r2
90005302:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
90005304:	f04f 33ff 	mov.w	r3, #4294967295
90005308:	f7fb fd68 	bl	90000ddc <BSP_SD_WriteBlocks>
9000530c:	b920      	cbnz	r0, 90005318 <SD_write+0x1c>
    while(BSP_SD_GetCardState()!= MSD_OK)
9000530e:	f7fb fe75 	bl	90000ffc <BSP_SD_GetCardState>
90005312:	2800      	cmp	r0, #0
90005314:	d1fb      	bne.n	9000530e <SD_write+0x12>
}
90005316:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
90005318:	2001      	movs	r0, #1
9000531a:	e7fc      	b.n	90005316 <SD_write+0x1a>

9000531c <ff_memalloc>:

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
	return ff_malloc(msize);	/* Allocate a new memory block with POSIX API */
9000531c:	f000 b886 	b.w	9000542c <malloc>

90005320 <ff_memfree>:

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
	ff_free(mblock);	/* Discard the memory block with POSIX API */
90005320:	f000 b88c 	b.w	9000543c <free>

90005324 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
90005324:	287f      	cmp	r0, #127	; 0x7f
{
90005326:	b510      	push	{r4, lr}
	if (chr < 0x80) {	/* ASCII */
90005328:	d906      	bls.n	90005338 <ff_convert+0x14>
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
9000532a:	b131      	cbz	r1, 9000533a <ff_convert+0x16>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
9000532c:	28ff      	cmp	r0, #255	; 0xff
9000532e:	d812      	bhi.n	90005356 <ff_convert+0x32>
90005330:	3880      	subs	r0, #128	; 0x80
90005332:	4b0a      	ldr	r3, [pc, #40]	; (9000535c <ff_convert+0x38>)
90005334:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
90005338:	bd10      	pop	{r4, pc}
9000533a:	4a08      	ldr	r2, [pc, #32]	; (9000535c <ff_convert+0x38>)
				if (chr == Tbl[c]) break;
9000533c:	f832 4b02 	ldrh.w	r4, [r2], #2
90005340:	b28b      	uxth	r3, r1
90005342:	4284      	cmp	r4, r0
90005344:	d003      	beq.n	9000534e <ff_convert+0x2a>
			for (c = 0; c < 0x80; c++) {
90005346:	3101      	adds	r1, #1
90005348:	2980      	cmp	r1, #128	; 0x80
9000534a:	d1f7      	bne.n	9000533c <ff_convert+0x18>
9000534c:	460b      	mov	r3, r1
			c = (c + 0x80) & 0xFF;
9000534e:	f103 0080 	add.w	r0, r3, #128	; 0x80
90005352:	b2c0      	uxtb	r0, r0
90005354:	e7f0      	b.n	90005338 <ff_convert+0x14>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
90005356:	2000      	movs	r0, #0
90005358:	e7ee      	b.n	90005338 <ff_convert+0x14>
9000535a:	bf00      	nop
9000535c:	900093cc 	.word	0x900093cc

90005360 <ff_wtoupper>:
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
90005360:	4b1f      	ldr	r3, [pc, #124]	; (900053e0 <ff_wtoupper+0x80>)
90005362:	f503 72f9 	add.w	r2, r3, #498	; 0x1f2
90005366:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
9000536a:	bf28      	it	cs
9000536c:	4613      	movcs	r3, r2
{
9000536e:	b570      	push	{r4, r5, r6, lr}
90005370:	1d19      	adds	r1, r3, #4
	for (;;) {
		bc = *p++;								/* Get block base */
90005372:	f831 3c04 	ldrh.w	r3, [r1, #-4]
		if (!bc || chr < bc) break;
90005376:	460a      	mov	r2, r1
90005378:	b1ab      	cbz	r3, 900053a6 <ff_wtoupper+0x46>
9000537a:	4298      	cmp	r0, r3
9000537c:	d313      	bcc.n	900053a6 <ff_wtoupper+0x46>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
9000537e:	f831 4c02 	ldrh.w	r4, [r1, #-2]
90005382:	0a25      	lsrs	r5, r4, #8
90005384:	b2e6      	uxtb	r6, r4
		if (chr < bc + nc) {	/* In the block? */
90005386:	fa53 f484 	uxtab	r4, r3, r4
9000538a:	42a0      	cmp	r0, r4
9000538c:	da21      	bge.n	900053d2 <ff_wtoupper+0x72>
			switch (cmd) {
9000538e:	2d08      	cmp	r5, #8
90005390:	d809      	bhi.n	900053a6 <ff_wtoupper+0x46>
90005392:	e8df f005 	tbb	[pc, r5]
90005396:	0905      	.short	0x0905
90005398:	1513110f 	.word	0x1513110f
9000539c:	1917      	.short	0x1917
9000539e:	1b          	.byte	0x1b
9000539f:	00          	.byte	0x00
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
900053a0:	1ac0      	subs	r0, r0, r3
900053a2:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
		}
		if (!cmd) p += nc;
	}

	return chr;
}
900053a6:	bd70      	pop	{r4, r5, r6, pc}
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
900053a8:	1ac3      	subs	r3, r0, r3
900053aa:	f003 0301 	and.w	r3, r3, #1
900053ae:	1ac0      	subs	r0, r0, r3
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
900053b0:	b280      	uxth	r0, r0
900053b2:	e7f8      	b.n	900053a6 <ff_wtoupper+0x46>
			case 2: chr -= 16; break;				/* Shift -16 */
900053b4:	3810      	subs	r0, #16
900053b6:	e7fb      	b.n	900053b0 <ff_wtoupper+0x50>
			case 3:	chr -= 32; break;				/* Shift -32 */
900053b8:	3820      	subs	r0, #32
900053ba:	e7f9      	b.n	900053b0 <ff_wtoupper+0x50>
			case 4:	chr -= 48; break;				/* Shift -48 */
900053bc:	3830      	subs	r0, #48	; 0x30
900053be:	e7f7      	b.n	900053b0 <ff_wtoupper+0x50>
			case 5:	chr -= 26; break;				/* Shift -26 */
900053c0:	381a      	subs	r0, #26
900053c2:	e7f5      	b.n	900053b0 <ff_wtoupper+0x50>
			case 6:	chr += 8; break;				/* Shift +8 */
900053c4:	3008      	adds	r0, #8
900053c6:	e7f3      	b.n	900053b0 <ff_wtoupper+0x50>
			case 7: chr -= 80; break;				/* Shift -80 */
900053c8:	3850      	subs	r0, #80	; 0x50
900053ca:	e7f1      	b.n	900053b0 <ff_wtoupper+0x50>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
900053cc:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
900053d0:	e7ee      	b.n	900053b0 <ff_wtoupper+0x50>
		if (!cmd) p += nc;
900053d2:	3104      	adds	r1, #4
900053d4:	2d00      	cmp	r5, #0
900053d6:	d1cc      	bne.n	90005372 <ff_wtoupper+0x12>
900053d8:	eb02 0346 	add.w	r3, r2, r6, lsl #1
900053dc:	e7c8      	b.n	90005370 <ff_wtoupper+0x10>
900053de:	bf00      	nop
900053e0:	900094cc 	.word	0x900094cc

900053e4 <__libc_init_array>:
900053e4:	b570      	push	{r4, r5, r6, lr}
900053e6:	4d0d      	ldr	r5, [pc, #52]	; (9000541c <__libc_init_array+0x38>)
900053e8:	4c0d      	ldr	r4, [pc, #52]	; (90005420 <__libc_init_array+0x3c>)
900053ea:	1b64      	subs	r4, r4, r5
900053ec:	10a4      	asrs	r4, r4, #2
900053ee:	2600      	movs	r6, #0
900053f0:	42a6      	cmp	r6, r4
900053f2:	d109      	bne.n	90005408 <__libc_init_array+0x24>
900053f4:	4d0b      	ldr	r5, [pc, #44]	; (90005424 <__libc_init_array+0x40>)
900053f6:	4c0c      	ldr	r4, [pc, #48]	; (90005428 <__libc_init_array+0x44>)
900053f8:	f000 f8fe 	bl	900055f8 <_init>
900053fc:	1b64      	subs	r4, r4, r5
900053fe:	10a4      	asrs	r4, r4, #2
90005400:	2600      	movs	r6, #0
90005402:	42a6      	cmp	r6, r4
90005404:	d105      	bne.n	90005412 <__libc_init_array+0x2e>
90005406:	bd70      	pop	{r4, r5, r6, pc}
90005408:	f855 3b04 	ldr.w	r3, [r5], #4
9000540c:	4798      	blx	r3
9000540e:	3601      	adds	r6, #1
90005410:	e7ee      	b.n	900053f0 <__libc_init_array+0xc>
90005412:	f855 3b04 	ldr.w	r3, [r5], #4
90005416:	4798      	blx	r3
90005418:	3601      	adds	r6, #1
9000541a:	e7f2      	b.n	90005402 <__libc_init_array+0x1e>
9000541c:	90009880 	.word	0x90009880
90005420:	90009880 	.word	0x90009880
90005424:	90009880 	.word	0x90009880
90005428:	90009884 	.word	0x90009884

9000542c <malloc>:
9000542c:	4b02      	ldr	r3, [pc, #8]	; (90005438 <malloc+0xc>)
9000542e:	4601      	mov	r1, r0
90005430:	6818      	ldr	r0, [r3, #0]
90005432:	f000 b85b 	b.w	900054ec <_malloc_r>
90005436:	bf00      	nop
90005438:	2000003c 	.word	0x2000003c

9000543c <free>:
9000543c:	4b02      	ldr	r3, [pc, #8]	; (90005448 <free+0xc>)
9000543e:	4601      	mov	r1, r0
90005440:	6818      	ldr	r0, [r3, #0]
90005442:	f000 b803 	b.w	9000544c <_free_r>
90005446:	bf00      	nop
90005448:	2000003c 	.word	0x2000003c

9000544c <_free_r>:
9000544c:	b537      	push	{r0, r1, r2, r4, r5, lr}
9000544e:	2900      	cmp	r1, #0
90005450:	d048      	beq.n	900054e4 <_free_r+0x98>
90005452:	f851 3c04 	ldr.w	r3, [r1, #-4]
90005456:	9001      	str	r0, [sp, #4]
90005458:	2b00      	cmp	r3, #0
9000545a:	f1a1 0404 	sub.w	r4, r1, #4
9000545e:	bfb8      	it	lt
90005460:	18e4      	addlt	r4, r4, r3
90005462:	f000 f8ad 	bl	900055c0 <__malloc_lock>
90005466:	4a20      	ldr	r2, [pc, #128]	; (900054e8 <_free_r+0x9c>)
90005468:	9801      	ldr	r0, [sp, #4]
9000546a:	6813      	ldr	r3, [r2, #0]
9000546c:	4615      	mov	r5, r2
9000546e:	b933      	cbnz	r3, 9000547e <_free_r+0x32>
90005470:	6063      	str	r3, [r4, #4]
90005472:	6014      	str	r4, [r2, #0]
90005474:	b003      	add	sp, #12
90005476:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
9000547a:	f000 b8a7 	b.w	900055cc <__malloc_unlock>
9000547e:	42a3      	cmp	r3, r4
90005480:	d90b      	bls.n	9000549a <_free_r+0x4e>
90005482:	6821      	ldr	r1, [r4, #0]
90005484:	1862      	adds	r2, r4, r1
90005486:	4293      	cmp	r3, r2
90005488:	bf04      	itt	eq
9000548a:	681a      	ldreq	r2, [r3, #0]
9000548c:	685b      	ldreq	r3, [r3, #4]
9000548e:	6063      	str	r3, [r4, #4]
90005490:	bf04      	itt	eq
90005492:	1852      	addeq	r2, r2, r1
90005494:	6022      	streq	r2, [r4, #0]
90005496:	602c      	str	r4, [r5, #0]
90005498:	e7ec      	b.n	90005474 <_free_r+0x28>
9000549a:	461a      	mov	r2, r3
9000549c:	685b      	ldr	r3, [r3, #4]
9000549e:	b10b      	cbz	r3, 900054a4 <_free_r+0x58>
900054a0:	42a3      	cmp	r3, r4
900054a2:	d9fa      	bls.n	9000549a <_free_r+0x4e>
900054a4:	6811      	ldr	r1, [r2, #0]
900054a6:	1855      	adds	r5, r2, r1
900054a8:	42a5      	cmp	r5, r4
900054aa:	d10b      	bne.n	900054c4 <_free_r+0x78>
900054ac:	6824      	ldr	r4, [r4, #0]
900054ae:	4421      	add	r1, r4
900054b0:	1854      	adds	r4, r2, r1
900054b2:	42a3      	cmp	r3, r4
900054b4:	6011      	str	r1, [r2, #0]
900054b6:	d1dd      	bne.n	90005474 <_free_r+0x28>
900054b8:	681c      	ldr	r4, [r3, #0]
900054ba:	685b      	ldr	r3, [r3, #4]
900054bc:	6053      	str	r3, [r2, #4]
900054be:	4421      	add	r1, r4
900054c0:	6011      	str	r1, [r2, #0]
900054c2:	e7d7      	b.n	90005474 <_free_r+0x28>
900054c4:	d902      	bls.n	900054cc <_free_r+0x80>
900054c6:	230c      	movs	r3, #12
900054c8:	6003      	str	r3, [r0, #0]
900054ca:	e7d3      	b.n	90005474 <_free_r+0x28>
900054cc:	6825      	ldr	r5, [r4, #0]
900054ce:	1961      	adds	r1, r4, r5
900054d0:	428b      	cmp	r3, r1
900054d2:	bf04      	itt	eq
900054d4:	6819      	ldreq	r1, [r3, #0]
900054d6:	685b      	ldreq	r3, [r3, #4]
900054d8:	6063      	str	r3, [r4, #4]
900054da:	bf04      	itt	eq
900054dc:	1949      	addeq	r1, r1, r5
900054de:	6021      	streq	r1, [r4, #0]
900054e0:	6054      	str	r4, [r2, #4]
900054e2:	e7c7      	b.n	90005474 <_free_r+0x28>
900054e4:	b003      	add	sp, #12
900054e6:	bd30      	pop	{r4, r5, pc}
900054e8:	20000444 	.word	0x20000444

900054ec <_malloc_r>:
900054ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900054ee:	1ccd      	adds	r5, r1, #3
900054f0:	f025 0503 	bic.w	r5, r5, #3
900054f4:	3508      	adds	r5, #8
900054f6:	2d0c      	cmp	r5, #12
900054f8:	bf38      	it	cc
900054fa:	250c      	movcc	r5, #12
900054fc:	2d00      	cmp	r5, #0
900054fe:	4606      	mov	r6, r0
90005500:	db01      	blt.n	90005506 <_malloc_r+0x1a>
90005502:	42a9      	cmp	r1, r5
90005504:	d903      	bls.n	9000550e <_malloc_r+0x22>
90005506:	230c      	movs	r3, #12
90005508:	6033      	str	r3, [r6, #0]
9000550a:	2000      	movs	r0, #0
9000550c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
9000550e:	f000 f857 	bl	900055c0 <__malloc_lock>
90005512:	4921      	ldr	r1, [pc, #132]	; (90005598 <_malloc_r+0xac>)
90005514:	680a      	ldr	r2, [r1, #0]
90005516:	4614      	mov	r4, r2
90005518:	b99c      	cbnz	r4, 90005542 <_malloc_r+0x56>
9000551a:	4f20      	ldr	r7, [pc, #128]	; (9000559c <_malloc_r+0xb0>)
9000551c:	683b      	ldr	r3, [r7, #0]
9000551e:	b923      	cbnz	r3, 9000552a <_malloc_r+0x3e>
90005520:	4621      	mov	r1, r4
90005522:	4630      	mov	r0, r6
90005524:	f000 f83c 	bl	900055a0 <_sbrk_r>
90005528:	6038      	str	r0, [r7, #0]
9000552a:	4629      	mov	r1, r5
9000552c:	4630      	mov	r0, r6
9000552e:	f000 f837 	bl	900055a0 <_sbrk_r>
90005532:	1c43      	adds	r3, r0, #1
90005534:	d123      	bne.n	9000557e <_malloc_r+0x92>
90005536:	230c      	movs	r3, #12
90005538:	6033      	str	r3, [r6, #0]
9000553a:	4630      	mov	r0, r6
9000553c:	f000 f846 	bl	900055cc <__malloc_unlock>
90005540:	e7e3      	b.n	9000550a <_malloc_r+0x1e>
90005542:	6823      	ldr	r3, [r4, #0]
90005544:	1b5b      	subs	r3, r3, r5
90005546:	d417      	bmi.n	90005578 <_malloc_r+0x8c>
90005548:	2b0b      	cmp	r3, #11
9000554a:	d903      	bls.n	90005554 <_malloc_r+0x68>
9000554c:	6023      	str	r3, [r4, #0]
9000554e:	441c      	add	r4, r3
90005550:	6025      	str	r5, [r4, #0]
90005552:	e004      	b.n	9000555e <_malloc_r+0x72>
90005554:	6863      	ldr	r3, [r4, #4]
90005556:	42a2      	cmp	r2, r4
90005558:	bf0c      	ite	eq
9000555a:	600b      	streq	r3, [r1, #0]
9000555c:	6053      	strne	r3, [r2, #4]
9000555e:	4630      	mov	r0, r6
90005560:	f000 f834 	bl	900055cc <__malloc_unlock>
90005564:	f104 000b 	add.w	r0, r4, #11
90005568:	1d23      	adds	r3, r4, #4
9000556a:	f020 0007 	bic.w	r0, r0, #7
9000556e:	1ac2      	subs	r2, r0, r3
90005570:	d0cc      	beq.n	9000550c <_malloc_r+0x20>
90005572:	1a1b      	subs	r3, r3, r0
90005574:	50a3      	str	r3, [r4, r2]
90005576:	e7c9      	b.n	9000550c <_malloc_r+0x20>
90005578:	4622      	mov	r2, r4
9000557a:	6864      	ldr	r4, [r4, #4]
9000557c:	e7cc      	b.n	90005518 <_malloc_r+0x2c>
9000557e:	1cc4      	adds	r4, r0, #3
90005580:	f024 0403 	bic.w	r4, r4, #3
90005584:	42a0      	cmp	r0, r4
90005586:	d0e3      	beq.n	90005550 <_malloc_r+0x64>
90005588:	1a21      	subs	r1, r4, r0
9000558a:	4630      	mov	r0, r6
9000558c:	f000 f808 	bl	900055a0 <_sbrk_r>
90005590:	3001      	adds	r0, #1
90005592:	d1dd      	bne.n	90005550 <_malloc_r+0x64>
90005594:	e7cf      	b.n	90005536 <_malloc_r+0x4a>
90005596:	bf00      	nop
90005598:	20000444 	.word	0x20000444
9000559c:	20000448 	.word	0x20000448

900055a0 <_sbrk_r>:
900055a0:	b538      	push	{r3, r4, r5, lr}
900055a2:	4d06      	ldr	r5, [pc, #24]	; (900055bc <_sbrk_r+0x1c>)
900055a4:	2300      	movs	r3, #0
900055a6:	4604      	mov	r4, r0
900055a8:	4608      	mov	r0, r1
900055aa:	602b      	str	r3, [r5, #0]
900055ac:	f000 f816 	bl	900055dc <_sbrk>
900055b0:	1c43      	adds	r3, r0, #1
900055b2:	d102      	bne.n	900055ba <_sbrk_r+0x1a>
900055b4:	682b      	ldr	r3, [r5, #0]
900055b6:	b103      	cbz	r3, 900055ba <_sbrk_r+0x1a>
900055b8:	6023      	str	r3, [r4, #0]
900055ba:	bd38      	pop	{r3, r4, r5, pc}
900055bc:	200005b4 	.word	0x200005b4

900055c0 <__malloc_lock>:
900055c0:	4801      	ldr	r0, [pc, #4]	; (900055c8 <__malloc_lock+0x8>)
900055c2:	f000 b809 	b.w	900055d8 <__retarget_lock_acquire_recursive>
900055c6:	bf00      	nop
900055c8:	200005bc 	.word	0x200005bc

900055cc <__malloc_unlock>:
900055cc:	4801      	ldr	r0, [pc, #4]	; (900055d4 <__malloc_unlock+0x8>)
900055ce:	f000 b804 	b.w	900055da <__retarget_lock_release_recursive>
900055d2:	bf00      	nop
900055d4:	200005bc 	.word	0x200005bc

900055d8 <__retarget_lock_acquire_recursive>:
900055d8:	4770      	bx	lr

900055da <__retarget_lock_release_recursive>:
900055da:	4770      	bx	lr

900055dc <_sbrk>:
900055dc:	4b04      	ldr	r3, [pc, #16]	; (900055f0 <_sbrk+0x14>)
900055de:	6819      	ldr	r1, [r3, #0]
900055e0:	4602      	mov	r2, r0
900055e2:	b909      	cbnz	r1, 900055e8 <_sbrk+0xc>
900055e4:	4903      	ldr	r1, [pc, #12]	; (900055f4 <_sbrk+0x18>)
900055e6:	6019      	str	r1, [r3, #0]
900055e8:	6818      	ldr	r0, [r3, #0]
900055ea:	4402      	add	r2, r0
900055ec:	601a      	str	r2, [r3, #0]
900055ee:	4770      	bx	lr
900055f0:	2000044c 	.word	0x2000044c
900055f4:	200005c8 	.word	0x200005c8

900055f8 <_init>:
900055f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900055fa:	bf00      	nop
900055fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
900055fe:	bc08      	pop	{r3}
90005600:	469e      	mov	lr, r3
90005602:	4770      	bx	lr

90005604 <_fini>:
90005604:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90005606:	bf00      	nop
90005608:	bcf8      	pop	{r3, r4, r5, r6, r7}
9000560a:	bc08      	pop	{r3}
9000560c:	469e      	mov	lr, r3
9000560e:	4770      	bx	lr
