
stm32f7508_AudioDemo_Cpp.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  90000000  90000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006d6c  900001c8  900001c8  000101c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000018  90006f34  90006f34  00016f34  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  90006f4c  90006f4c  00016f4c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  90006f54  90006f54  00016f54  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  90006f58  90006f58  00016f58  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000040  20000000  90006f5c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000350  20000040  90006f9c  00020040  2**2
                  ALLOC
  8 ._user_heap_stack 00000c00  20000390  90006f9c  00020390  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020040  2**0
                  CONTENTS, READONLY
 10 .debug_info   0001346b  00000000  00000000  00020070  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00002f12  00000000  00000000  000334db  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00000fd0  00000000  00000000  000363f0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_ranges 00000e80  00000000  00000000  000373c0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  0002d1c2  00000000  00000000  00038240  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   00014794  00000000  00000000  00065402  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    0010b89b  00000000  00000000  00079b96  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000053  00000000  00000000  00185431  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00003fc4  00000000  00000000  00185484  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

900001c8 <__do_global_dtors_aux>:
900001c8:	b510      	push	{r4, lr}
900001ca:	4c05      	ldr	r4, [pc, #20]	; (900001e0 <__do_global_dtors_aux+0x18>)
900001cc:	7823      	ldrb	r3, [r4, #0]
900001ce:	b933      	cbnz	r3, 900001de <__do_global_dtors_aux+0x16>
900001d0:	4b04      	ldr	r3, [pc, #16]	; (900001e4 <__do_global_dtors_aux+0x1c>)
900001d2:	b113      	cbz	r3, 900001da <__do_global_dtors_aux+0x12>
900001d4:	4804      	ldr	r0, [pc, #16]	; (900001e8 <__do_global_dtors_aux+0x20>)
900001d6:	f3af 8000 	nop.w
900001da:	2301      	movs	r3, #1
900001dc:	7023      	strb	r3, [r4, #0]
900001de:	bd10      	pop	{r4, pc}
900001e0:	20000040 	.word	0x20000040
900001e4:	00000000 	.word	0x00000000
900001e8:	90006f1c 	.word	0x90006f1c

900001ec <frame_dummy>:
900001ec:	b508      	push	{r3, lr}
900001ee:	4b03      	ldr	r3, [pc, #12]	; (900001fc <frame_dummy+0x10>)
900001f0:	b11b      	cbz	r3, 900001fa <frame_dummy+0xe>
900001f2:	4903      	ldr	r1, [pc, #12]	; (90000200 <frame_dummy+0x14>)
900001f4:	4803      	ldr	r0, [pc, #12]	; (90000204 <frame_dummy+0x18>)
900001f6:	f3af 8000 	nop.w
900001fa:	bd08      	pop	{r3, pc}
900001fc:	00000000 	.word	0x00000000
90000200:	20000044 	.word	0x20000044
90000204:	90006f1c 	.word	0x90006f1c

90000208 <__aeabi_uldivmod>:
90000208:	b953      	cbnz	r3, 90000220 <__aeabi_uldivmod+0x18>
9000020a:	b94a      	cbnz	r2, 90000220 <__aeabi_uldivmod+0x18>
9000020c:	2900      	cmp	r1, #0
9000020e:	bf08      	it	eq
90000210:	2800      	cmpeq	r0, #0
90000212:	bf1c      	itt	ne
90000214:	f04f 31ff 	movne.w	r1, #4294967295
90000218:	f04f 30ff 	movne.w	r0, #4294967295
9000021c:	f000 b96e 	b.w	900004fc <__aeabi_idiv0>
90000220:	f1ad 0c08 	sub.w	ip, sp, #8
90000224:	e96d ce04 	strd	ip, lr, [sp, #-16]!
90000228:	f000 f806 	bl	90000238 <__udivmoddi4>
9000022c:	f8dd e004 	ldr.w	lr, [sp, #4]
90000230:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
90000234:	b004      	add	sp, #16
90000236:	4770      	bx	lr

90000238 <__udivmoddi4>:
90000238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000023c:	9d08      	ldr	r5, [sp, #32]
9000023e:	4604      	mov	r4, r0
90000240:	468c      	mov	ip, r1
90000242:	2b00      	cmp	r3, #0
90000244:	f040 8083 	bne.w	9000034e <__udivmoddi4+0x116>
90000248:	428a      	cmp	r2, r1
9000024a:	4617      	mov	r7, r2
9000024c:	d947      	bls.n	900002de <__udivmoddi4+0xa6>
9000024e:	fab2 f282 	clz	r2, r2
90000252:	b142      	cbz	r2, 90000266 <__udivmoddi4+0x2e>
90000254:	f1c2 0020 	rsb	r0, r2, #32
90000258:	fa24 f000 	lsr.w	r0, r4, r0
9000025c:	4091      	lsls	r1, r2
9000025e:	4097      	lsls	r7, r2
90000260:	ea40 0c01 	orr.w	ip, r0, r1
90000264:	4094      	lsls	r4, r2
90000266:	ea4f 4817 	mov.w	r8, r7, lsr #16
9000026a:	0c23      	lsrs	r3, r4, #16
9000026c:	fbbc f6f8 	udiv	r6, ip, r8
90000270:	fa1f fe87 	uxth.w	lr, r7
90000274:	fb08 c116 	mls	r1, r8, r6, ip
90000278:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
9000027c:	fb06 f10e 	mul.w	r1, r6, lr
90000280:	4299      	cmp	r1, r3
90000282:	d909      	bls.n	90000298 <__udivmoddi4+0x60>
90000284:	18fb      	adds	r3, r7, r3
90000286:	f106 30ff 	add.w	r0, r6, #4294967295
9000028a:	f080 8119 	bcs.w	900004c0 <__udivmoddi4+0x288>
9000028e:	4299      	cmp	r1, r3
90000290:	f240 8116 	bls.w	900004c0 <__udivmoddi4+0x288>
90000294:	3e02      	subs	r6, #2
90000296:	443b      	add	r3, r7
90000298:	1a5b      	subs	r3, r3, r1
9000029a:	b2a4      	uxth	r4, r4
9000029c:	fbb3 f0f8 	udiv	r0, r3, r8
900002a0:	fb08 3310 	mls	r3, r8, r0, r3
900002a4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
900002a8:	fb00 fe0e 	mul.w	lr, r0, lr
900002ac:	45a6      	cmp	lr, r4
900002ae:	d909      	bls.n	900002c4 <__udivmoddi4+0x8c>
900002b0:	193c      	adds	r4, r7, r4
900002b2:	f100 33ff 	add.w	r3, r0, #4294967295
900002b6:	f080 8105 	bcs.w	900004c4 <__udivmoddi4+0x28c>
900002ba:	45a6      	cmp	lr, r4
900002bc:	f240 8102 	bls.w	900004c4 <__udivmoddi4+0x28c>
900002c0:	3802      	subs	r0, #2
900002c2:	443c      	add	r4, r7
900002c4:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
900002c8:	eba4 040e 	sub.w	r4, r4, lr
900002cc:	2600      	movs	r6, #0
900002ce:	b11d      	cbz	r5, 900002d8 <__udivmoddi4+0xa0>
900002d0:	40d4      	lsrs	r4, r2
900002d2:	2300      	movs	r3, #0
900002d4:	e9c5 4300 	strd	r4, r3, [r5]
900002d8:	4631      	mov	r1, r6
900002da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900002de:	b902      	cbnz	r2, 900002e2 <__udivmoddi4+0xaa>
900002e0:	deff      	udf	#255	; 0xff
900002e2:	fab2 f282 	clz	r2, r2
900002e6:	2a00      	cmp	r2, #0
900002e8:	d150      	bne.n	9000038c <__udivmoddi4+0x154>
900002ea:	1bcb      	subs	r3, r1, r7
900002ec:	ea4f 4e17 	mov.w	lr, r7, lsr #16
900002f0:	fa1f f887 	uxth.w	r8, r7
900002f4:	2601      	movs	r6, #1
900002f6:	fbb3 fcfe 	udiv	ip, r3, lr
900002fa:	0c21      	lsrs	r1, r4, #16
900002fc:	fb0e 331c 	mls	r3, lr, ip, r3
90000300:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
90000304:	fb08 f30c 	mul.w	r3, r8, ip
90000308:	428b      	cmp	r3, r1
9000030a:	d907      	bls.n	9000031c <__udivmoddi4+0xe4>
9000030c:	1879      	adds	r1, r7, r1
9000030e:	f10c 30ff 	add.w	r0, ip, #4294967295
90000312:	d202      	bcs.n	9000031a <__udivmoddi4+0xe2>
90000314:	428b      	cmp	r3, r1
90000316:	f200 80e9 	bhi.w	900004ec <__udivmoddi4+0x2b4>
9000031a:	4684      	mov	ip, r0
9000031c:	1ac9      	subs	r1, r1, r3
9000031e:	b2a3      	uxth	r3, r4
90000320:	fbb1 f0fe 	udiv	r0, r1, lr
90000324:	fb0e 1110 	mls	r1, lr, r0, r1
90000328:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
9000032c:	fb08 f800 	mul.w	r8, r8, r0
90000330:	45a0      	cmp	r8, r4
90000332:	d907      	bls.n	90000344 <__udivmoddi4+0x10c>
90000334:	193c      	adds	r4, r7, r4
90000336:	f100 33ff 	add.w	r3, r0, #4294967295
9000033a:	d202      	bcs.n	90000342 <__udivmoddi4+0x10a>
9000033c:	45a0      	cmp	r8, r4
9000033e:	f200 80d9 	bhi.w	900004f4 <__udivmoddi4+0x2bc>
90000342:	4618      	mov	r0, r3
90000344:	eba4 0408 	sub.w	r4, r4, r8
90000348:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
9000034c:	e7bf      	b.n	900002ce <__udivmoddi4+0x96>
9000034e:	428b      	cmp	r3, r1
90000350:	d909      	bls.n	90000366 <__udivmoddi4+0x12e>
90000352:	2d00      	cmp	r5, #0
90000354:	f000 80b1 	beq.w	900004ba <__udivmoddi4+0x282>
90000358:	2600      	movs	r6, #0
9000035a:	e9c5 0100 	strd	r0, r1, [r5]
9000035e:	4630      	mov	r0, r6
90000360:	4631      	mov	r1, r6
90000362:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90000366:	fab3 f683 	clz	r6, r3
9000036a:	2e00      	cmp	r6, #0
9000036c:	d14a      	bne.n	90000404 <__udivmoddi4+0x1cc>
9000036e:	428b      	cmp	r3, r1
90000370:	d302      	bcc.n	90000378 <__udivmoddi4+0x140>
90000372:	4282      	cmp	r2, r0
90000374:	f200 80b8 	bhi.w	900004e8 <__udivmoddi4+0x2b0>
90000378:	1a84      	subs	r4, r0, r2
9000037a:	eb61 0103 	sbc.w	r1, r1, r3
9000037e:	2001      	movs	r0, #1
90000380:	468c      	mov	ip, r1
90000382:	2d00      	cmp	r5, #0
90000384:	d0a8      	beq.n	900002d8 <__udivmoddi4+0xa0>
90000386:	e9c5 4c00 	strd	r4, ip, [r5]
9000038a:	e7a5      	b.n	900002d8 <__udivmoddi4+0xa0>
9000038c:	f1c2 0320 	rsb	r3, r2, #32
90000390:	fa20 f603 	lsr.w	r6, r0, r3
90000394:	4097      	lsls	r7, r2
90000396:	fa01 f002 	lsl.w	r0, r1, r2
9000039a:	ea4f 4e17 	mov.w	lr, r7, lsr #16
9000039e:	40d9      	lsrs	r1, r3
900003a0:	4330      	orrs	r0, r6
900003a2:	0c03      	lsrs	r3, r0, #16
900003a4:	fbb1 f6fe 	udiv	r6, r1, lr
900003a8:	fa1f f887 	uxth.w	r8, r7
900003ac:	fb0e 1116 	mls	r1, lr, r6, r1
900003b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
900003b4:	fb06 f108 	mul.w	r1, r6, r8
900003b8:	4299      	cmp	r1, r3
900003ba:	fa04 f402 	lsl.w	r4, r4, r2
900003be:	d909      	bls.n	900003d4 <__udivmoddi4+0x19c>
900003c0:	18fb      	adds	r3, r7, r3
900003c2:	f106 3cff 	add.w	ip, r6, #4294967295
900003c6:	f080 808d 	bcs.w	900004e4 <__udivmoddi4+0x2ac>
900003ca:	4299      	cmp	r1, r3
900003cc:	f240 808a 	bls.w	900004e4 <__udivmoddi4+0x2ac>
900003d0:	3e02      	subs	r6, #2
900003d2:	443b      	add	r3, r7
900003d4:	1a5b      	subs	r3, r3, r1
900003d6:	b281      	uxth	r1, r0
900003d8:	fbb3 f0fe 	udiv	r0, r3, lr
900003dc:	fb0e 3310 	mls	r3, lr, r0, r3
900003e0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
900003e4:	fb00 f308 	mul.w	r3, r0, r8
900003e8:	428b      	cmp	r3, r1
900003ea:	d907      	bls.n	900003fc <__udivmoddi4+0x1c4>
900003ec:	1879      	adds	r1, r7, r1
900003ee:	f100 3cff 	add.w	ip, r0, #4294967295
900003f2:	d273      	bcs.n	900004dc <__udivmoddi4+0x2a4>
900003f4:	428b      	cmp	r3, r1
900003f6:	d971      	bls.n	900004dc <__udivmoddi4+0x2a4>
900003f8:	3802      	subs	r0, #2
900003fa:	4439      	add	r1, r7
900003fc:	1acb      	subs	r3, r1, r3
900003fe:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
90000402:	e778      	b.n	900002f6 <__udivmoddi4+0xbe>
90000404:	f1c6 0c20 	rsb	ip, r6, #32
90000408:	fa03 f406 	lsl.w	r4, r3, r6
9000040c:	fa22 f30c 	lsr.w	r3, r2, ip
90000410:	431c      	orrs	r4, r3
90000412:	fa20 f70c 	lsr.w	r7, r0, ip
90000416:	fa01 f306 	lsl.w	r3, r1, r6
9000041a:	ea4f 4e14 	mov.w	lr, r4, lsr #16
9000041e:	fa21 f10c 	lsr.w	r1, r1, ip
90000422:	431f      	orrs	r7, r3
90000424:	0c3b      	lsrs	r3, r7, #16
90000426:	fbb1 f9fe 	udiv	r9, r1, lr
9000042a:	fa1f f884 	uxth.w	r8, r4
9000042e:	fb0e 1119 	mls	r1, lr, r9, r1
90000432:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
90000436:	fb09 fa08 	mul.w	sl, r9, r8
9000043a:	458a      	cmp	sl, r1
9000043c:	fa02 f206 	lsl.w	r2, r2, r6
90000440:	fa00 f306 	lsl.w	r3, r0, r6
90000444:	d908      	bls.n	90000458 <__udivmoddi4+0x220>
90000446:	1861      	adds	r1, r4, r1
90000448:	f109 30ff 	add.w	r0, r9, #4294967295
9000044c:	d248      	bcs.n	900004e0 <__udivmoddi4+0x2a8>
9000044e:	458a      	cmp	sl, r1
90000450:	d946      	bls.n	900004e0 <__udivmoddi4+0x2a8>
90000452:	f1a9 0902 	sub.w	r9, r9, #2
90000456:	4421      	add	r1, r4
90000458:	eba1 010a 	sub.w	r1, r1, sl
9000045c:	b2bf      	uxth	r7, r7
9000045e:	fbb1 f0fe 	udiv	r0, r1, lr
90000462:	fb0e 1110 	mls	r1, lr, r0, r1
90000466:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
9000046a:	fb00 f808 	mul.w	r8, r0, r8
9000046e:	45b8      	cmp	r8, r7
90000470:	d907      	bls.n	90000482 <__udivmoddi4+0x24a>
90000472:	19e7      	adds	r7, r4, r7
90000474:	f100 31ff 	add.w	r1, r0, #4294967295
90000478:	d22e      	bcs.n	900004d8 <__udivmoddi4+0x2a0>
9000047a:	45b8      	cmp	r8, r7
9000047c:	d92c      	bls.n	900004d8 <__udivmoddi4+0x2a0>
9000047e:	3802      	subs	r0, #2
90000480:	4427      	add	r7, r4
90000482:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
90000486:	eba7 0708 	sub.w	r7, r7, r8
9000048a:	fba0 8902 	umull	r8, r9, r0, r2
9000048e:	454f      	cmp	r7, r9
90000490:	46c6      	mov	lr, r8
90000492:	4649      	mov	r1, r9
90000494:	d31a      	bcc.n	900004cc <__udivmoddi4+0x294>
90000496:	d017      	beq.n	900004c8 <__udivmoddi4+0x290>
90000498:	b15d      	cbz	r5, 900004b2 <__udivmoddi4+0x27a>
9000049a:	ebb3 020e 	subs.w	r2, r3, lr
9000049e:	eb67 0701 	sbc.w	r7, r7, r1
900004a2:	fa07 fc0c 	lsl.w	ip, r7, ip
900004a6:	40f2      	lsrs	r2, r6
900004a8:	ea4c 0202 	orr.w	r2, ip, r2
900004ac:	40f7      	lsrs	r7, r6
900004ae:	e9c5 2700 	strd	r2, r7, [r5]
900004b2:	2600      	movs	r6, #0
900004b4:	4631      	mov	r1, r6
900004b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900004ba:	462e      	mov	r6, r5
900004bc:	4628      	mov	r0, r5
900004be:	e70b      	b.n	900002d8 <__udivmoddi4+0xa0>
900004c0:	4606      	mov	r6, r0
900004c2:	e6e9      	b.n	90000298 <__udivmoddi4+0x60>
900004c4:	4618      	mov	r0, r3
900004c6:	e6fd      	b.n	900002c4 <__udivmoddi4+0x8c>
900004c8:	4543      	cmp	r3, r8
900004ca:	d2e5      	bcs.n	90000498 <__udivmoddi4+0x260>
900004cc:	ebb8 0e02 	subs.w	lr, r8, r2
900004d0:	eb69 0104 	sbc.w	r1, r9, r4
900004d4:	3801      	subs	r0, #1
900004d6:	e7df      	b.n	90000498 <__udivmoddi4+0x260>
900004d8:	4608      	mov	r0, r1
900004da:	e7d2      	b.n	90000482 <__udivmoddi4+0x24a>
900004dc:	4660      	mov	r0, ip
900004de:	e78d      	b.n	900003fc <__udivmoddi4+0x1c4>
900004e0:	4681      	mov	r9, r0
900004e2:	e7b9      	b.n	90000458 <__udivmoddi4+0x220>
900004e4:	4666      	mov	r6, ip
900004e6:	e775      	b.n	900003d4 <__udivmoddi4+0x19c>
900004e8:	4630      	mov	r0, r6
900004ea:	e74a      	b.n	90000382 <__udivmoddi4+0x14a>
900004ec:	f1ac 0c02 	sub.w	ip, ip, #2
900004f0:	4439      	add	r1, r7
900004f2:	e713      	b.n	9000031c <__udivmoddi4+0xe4>
900004f4:	3802      	subs	r0, #2
900004f6:	443c      	add	r4, r7
900004f8:	e724      	b.n	90000344 <__udivmoddi4+0x10c>
900004fa:	bf00      	nop

900004fc <__aeabi_idiv0>:
900004fc:	4770      	bx	lr
900004fe:	bf00      	nop

90000500 <_ZN17AUDIO_DISCO_F7508C1Ev>:

#include "AUDIO_DISCO_F7508.h"
#include "stm32f7508_discovery_audio.h"

// Constructor
AUDIO_DISCO_F7508::AUDIO_DISCO_F7508()
90000500:	b580      	push	{r7, lr}
90000502:	b084      	sub	sp, #16
90000504:	af02      	add	r7, sp, #8
90000506:	6078      	str	r0, [r7, #4]
{
    BSP_AUDIO_IN_OUT_Init(INPUT_DEVICE_DIGITAL_MICROPHONE_2, OUTPUT_DEVICE_HEADPHONE, DEFAULT_AUDIO_IN_FREQ, DEFAULT_AUDIO_IN_BIT_RESOLUTION, DEFAULT_AUDIO_IN_CHANNEL_NBR);
90000508:	2302      	movs	r3, #2
9000050a:	9300      	str	r3, [sp, #0]
9000050c:	2310      	movs	r3, #16
9000050e:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
90000512:	2102      	movs	r1, #2
90000514:	f44f 7000 	mov.w	r0, #512	; 0x200
90000518:	f002 fd2c 	bl	90002f74 <BSP_AUDIO_IN_OUT_Init>
}
9000051c:	687b      	ldr	r3, [r7, #4]
9000051e:	4618      	mov	r0, r3
90000520:	3708      	adds	r7, #8
90000522:	46bd      	mov	sp, r7
90000524:	bd80      	pop	{r7, pc}

90000526 <_ZN17AUDIO_DISCO_F75088OUT_PlayEPtm>:
{
    return BSP_AUDIO_OUT_Init(OutputDevice, Volume, AudioFreq);
}

uint8_t AUDIO_DISCO_F7508::OUT_Play(uint16_t* pBuffer, uint32_t Size)
{
90000526:	b580      	push	{r7, lr}
90000528:	b084      	sub	sp, #16
9000052a:	af00      	add	r7, sp, #0
9000052c:	60f8      	str	r0, [r7, #12]
9000052e:	60b9      	str	r1, [r7, #8]
90000530:	607a      	str	r2, [r7, #4]
    return BSP_AUDIO_OUT_Play(pBuffer, Size);
90000532:	6879      	ldr	r1, [r7, #4]
90000534:	68b8      	ldr	r0, [r7, #8]
90000536:	f002 fb53 	bl	90002be0 <BSP_AUDIO_OUT_Play>
9000053a:	4603      	mov	r3, r0
}
9000053c:	4618      	mov	r0, r3
9000053e:	3710      	adds	r7, #16
90000540:	46bd      	mov	sp, r7
90000542:	bd80      	pop	{r7, pc}

90000544 <_ZN17AUDIO_DISCO_F750821OUT_SetAudioFrameSlotEm>:
{
    BSP_AUDIO_OUT_SetFrequency(AudioFreq);
}

void AUDIO_DISCO_F7508::OUT_SetAudioFrameSlot(uint32_t AudioFrameSlot)
{
90000544:	b580      	push	{r7, lr}
90000546:	b082      	sub	sp, #8
90000548:	af00      	add	r7, sp, #0
9000054a:	6078      	str	r0, [r7, #4]
9000054c:	6039      	str	r1, [r7, #0]
    BSP_AUDIO_OUT_SetAudioFrameSlot(AudioFrameSlot);
9000054e:	6838      	ldr	r0, [r7, #0]
90000550:	f002 fb70 	bl	90002c34 <BSP_AUDIO_OUT_SetAudioFrameSlot>
}
90000554:	bf00      	nop
90000556:	3708      	adds	r7, #8
90000558:	46bd      	mov	sp, r7
9000055a:	bd80      	pop	{r7, pc}

9000055c <_ZN17AUDIO_DISCO_F75089IN_RecordEPtm>:
{
    return BSP_AUDIO_IN_OUT_Init(InputDevice, OutputDevice, AudioFreq, BitRes, ChnlNbr);
}

uint8_t  AUDIO_DISCO_F7508::IN_Record(uint16_t* pbuf, uint32_t size)
{
9000055c:	b580      	push	{r7, lr}
9000055e:	b084      	sub	sp, #16
90000560:	af00      	add	r7, sp, #0
90000562:	60f8      	str	r0, [r7, #12]
90000564:	60b9      	str	r1, [r7, #8]
90000566:	607a      	str	r2, [r7, #4]
    return BSP_AUDIO_IN_Record(pbuf, size);
90000568:	6879      	ldr	r1, [r7, #4]
9000056a:	68b8      	ldr	r0, [r7, #8]
9000056c:	f002 fd7c 	bl	90003068 <BSP_AUDIO_IN_Record>
90000570:	4603      	mov	r3, r0
}
90000572:	4618      	mov	r0, r3
90000574:	3710      	adds	r7, #16
90000576:	46bd      	mov	sp, r7
90000578:	bd80      	pop	{r7, pc}
	...

9000057c <MainTask>:
/**
  * @brief  The application entry point.
  * @retval int
  */
void MainTask()
{
9000057c:	b580      	push	{r7, lr}
9000057e:	b082      	sub	sp, #8
90000580:	af00      	add	r7, sp, #0

  /* MCU Configuration--------------------------------------------------------*/


  /* USER CODE END SysInit */
  AUDIO_DISCO_F7508 audio;
90000582:	1d3b      	adds	r3, r7, #4
90000584:	4618      	mov	r0, r3
90000586:	f7ff ffbb 	bl	90000500 <_ZN17AUDIO_DISCO_F7508C1Ev>
  // audio IN_OUT buffer is stored in the SDRAM, SDRAM needs to be initialized and FMC enabled
  SDRAM_DISCO_F7508 sdram;
9000058a:	463b      	mov	r3, r7
9000058c:	4618      	mov	r0, r3
9000058e:	f006 fc80 	bl	90006e92 <_ZN17SDRAM_DISCO_F7508C1Ev>

  /* Initialize all configured peripherals */

  /* USER CODE BEGIN 2 */
      memset((uint16_t *)AUDIO_BUFFER_IN, 0, AUDIO_BLOCK_SIZE * 2);
90000592:	f44f 6280 	mov.w	r2, #1024	; 0x400
90000596:	2100      	movs	r1, #0
90000598:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
9000059c:	f006 fcb6 	bl	90006f0c <memset>
      memset((uint16_t *)AUDIO_BUFFER_OUT, 0, AUDIO_BLOCK_SIZE * 2);
900005a0:	f44f 6280 	mov.w	r2, #1024	; 0x400
900005a4:	2100      	movs	r1, #0
900005a6:	4823      	ldr	r0, [pc, #140]	; (90000634 <MainTask+0xb8>)
900005a8:	f006 fcb0 	bl	90006f0c <memset>
      audio_rec_buffer_state = BUFFER_OFFSET_NONE;
900005ac:	4b22      	ldr	r3, [pc, #136]	; (90000638 <MainTask+0xbc>)
900005ae:	2200      	movs	r2, #0
900005b0:	601a      	str	r2, [r3, #0]
      /* Start Recording */
      audio.IN_Record((uint16_t *)AUDIO_BUFFER_IN, AUDIO_BLOCK_SIZE);
900005b2:	1d3b      	adds	r3, r7, #4
900005b4:	f44f 7200 	mov.w	r2, #512	; 0x200
900005b8:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
900005bc:	4618      	mov	r0, r3
900005be:	f7ff ffcd 	bl	9000055c <_ZN17AUDIO_DISCO_F75089IN_RecordEPtm>
      /* Start Playback */
      audio.OUT_SetAudioFrameSlot(CODEC_AUDIOFRAME_SLOT_02);
900005c2:	1d3b      	adds	r3, r7, #4
900005c4:	2105      	movs	r1, #5
900005c6:	4618      	mov	r0, r3
900005c8:	f7ff ffbc 	bl	90000544 <_ZN17AUDIO_DISCO_F750821OUT_SetAudioFrameSlotEm>
      audio.OUT_Play((uint16_t *)AUDIO_BUFFER_OUT, AUDIO_BLOCK_SIZE * 2);
900005cc:	1d3b      	adds	r3, r7, #4
900005ce:	f44f 6280 	mov.w	r2, #1024	; 0x400
900005d2:	4918      	ldr	r1, [pc, #96]	; (90000634 <MainTask+0xb8>)
900005d4:	4618      	mov	r0, r3
900005d6:	f7ff ffa6 	bl	90000526 <_ZN17AUDIO_DISCO_F75088OUT_PlayEPtm>
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
   //HAL_Delay(50);
   HAL_GPIO_TogglePin(GPIOI, GPIO_PIN_1);
900005da:	2102      	movs	r1, #2
900005dc:	4817      	ldr	r0, [pc, #92]	; (9000063c <MainTask+0xc0>)
900005de:	f003 fe58 	bl	90004292 <HAL_GPIO_TogglePin>

   /* Wait end of half block recording */
          while (audio_rec_buffer_state == BUFFER_OFFSET_HALF) {
900005e2:	4b15      	ldr	r3, [pc, #84]	; (90000638 <MainTask+0xbc>)
900005e4:	681b      	ldr	r3, [r3, #0]
900005e6:	2b01      	cmp	r3, #1
900005e8:	bf0c      	ite	eq
900005ea:	2301      	moveq	r3, #1
900005ec:	2300      	movne	r3, #0
900005ee:	b2db      	uxtb	r3, r3
900005f0:	2b00      	cmp	r3, #0
900005f2:	d000      	beq.n	900005f6 <MainTask+0x7a>
900005f4:	e7f5      	b.n	900005e2 <MainTask+0x66>
          }

          audio_rec_buffer_state = BUFFER_OFFSET_NONE;
900005f6:	4b10      	ldr	r3, [pc, #64]	; (90000638 <MainTask+0xbc>)
900005f8:	2200      	movs	r2, #0
900005fa:	601a      	str	r2, [r3, #0]
          /* Copy recorded 1st half block */
          memcpy((uint16_t *)(AUDIO_BUFFER_OUT), (uint16_t *)(AUDIO_BUFFER_IN), AUDIO_BLOCK_SIZE);
900005fc:	f44f 7200 	mov.w	r2, #512	; 0x200
90000600:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
90000604:	480b      	ldr	r0, [pc, #44]	; (90000634 <MainTask+0xb8>)
90000606:	f006 fc73 	bl	90006ef0 <memcpy>

          /* Wait end of one block recording */
          while (audio_rec_buffer_state == BUFFER_OFFSET_FULL) {
9000060a:	4b0b      	ldr	r3, [pc, #44]	; (90000638 <MainTask+0xbc>)
9000060c:	681b      	ldr	r3, [r3, #0]
9000060e:	2b02      	cmp	r3, #2
90000610:	bf0c      	ite	eq
90000612:	2301      	moveq	r3, #1
90000614:	2300      	movne	r3, #0
90000616:	b2db      	uxtb	r3, r3
90000618:	2b00      	cmp	r3, #0
9000061a:	d000      	beq.n	9000061e <MainTask+0xa2>
9000061c:	e7f5      	b.n	9000060a <MainTask+0x8e>
          }

          audio_rec_buffer_state = BUFFER_OFFSET_NONE;
9000061e:	4b06      	ldr	r3, [pc, #24]	; (90000638 <MainTask+0xbc>)
90000620:	2200      	movs	r2, #0
90000622:	601a      	str	r2, [r3, #0]
          /* Copy recorded 2nd half block */
          memcpy((uint16_t *)(AUDIO_BUFFER_OUT + (AUDIO_BLOCK_SIZE)),
90000624:	f44f 7200 	mov.w	r2, #512	; 0x200
90000628:	4905      	ldr	r1, [pc, #20]	; (90000640 <MainTask+0xc4>)
9000062a:	4806      	ldr	r0, [pc, #24]	; (90000644 <MainTask+0xc8>)
9000062c:	f006 fc60 	bl	90006ef0 <memcpy>
   HAL_GPIO_TogglePin(GPIOI, GPIO_PIN_1);
90000630:	e7d3      	b.n	900005da <MainTask+0x5e>
90000632:	bf00      	nop
90000634:	c0000400 	.word	0xc0000400
90000638:	2000005c 	.word	0x2000005c
9000063c:	40022000 	.word	0x40022000
90000640:	c0000200 	.word	0xc0000200
90000644:	c0000600 	.word	0xc0000600

90000648 <BSP_AUDIO_IN_TransferComplete_CallBack>:
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

void BSP_AUDIO_IN_TransferComplete_CallBack(void) {
90000648:	b480      	push	{r7}
9000064a:	af00      	add	r7, sp, #0
    audio_rec_buffer_state = BUFFER_OFFSET_FULL;
9000064c:	4b03      	ldr	r3, [pc, #12]	; (9000065c <BSP_AUDIO_IN_TransferComplete_CallBack+0x14>)
9000064e:	2202      	movs	r2, #2
90000650:	601a      	str	r2, [r3, #0]
    return;
90000652:	bf00      	nop
}
90000654:	46bd      	mov	sp, r7
90000656:	f85d 7b04 	ldr.w	r7, [sp], #4
9000065a:	4770      	bx	lr
9000065c:	2000005c 	.word	0x2000005c

90000660 <BSP_AUDIO_IN_HalfTransfer_CallBack>:
/**
    @brief  Manages the DMA Half Transfer complete interrupt.
    @param  None
    @retval None
*/
void BSP_AUDIO_IN_HalfTransfer_CallBack(void) {
90000660:	b480      	push	{r7}
90000662:	af00      	add	r7, sp, #0
    audio_rec_buffer_state = BUFFER_OFFSET_HALF;
90000664:	4b03      	ldr	r3, [pc, #12]	; (90000674 <BSP_AUDIO_IN_HalfTransfer_CallBack+0x14>)
90000666:	2201      	movs	r2, #1
90000668:	601a      	str	r2, [r3, #0]
    return;
9000066a:	bf00      	nop
}
9000066c:	46bd      	mov	sp, r7
9000066e:	f85d 7b04 	ldr.w	r7, [sp], #4
90000672:	4770      	bx	lr
90000674:	2000005c 	.word	0x2000005c

90000678 <main>:

void SystemClock_Config(void);
static void MX_GPIO_Init(void);

int main()
{
90000678:	b580      	push	{r7, lr}
9000067a:	af00      	add	r7, sp, #0
	 /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	  HAL_Init();
9000067c:	f003 f85c 	bl	90003738 <HAL_Init>
	  /* USER CODE BEGIN Init */

	  /* USER CODE END Init */

	  /* Configure the system clock */
	  SystemClock_Config();
90000680:	f000 f808 	bl	90000694 <SystemClock_Config>

	  MX_GPIO_Init();
90000684:	f000 f874 	bl	90000770 <MX_GPIO_Init>

	  /* USER CODE BEGIN SysInit */

	MainTask();
90000688:	f7ff ff78 	bl	9000057c <MainTask>
9000068c:	2300      	movs	r3, #0
}
9000068e:	4618      	mov	r0, r3
90000690:	bd80      	pop	{r7, pc}
	...

90000694 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
90000694:	b580      	push	{r7, lr}
90000696:	b094      	sub	sp, #80	; 0x50
90000698:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
9000069a:	f107 0320 	add.w	r3, r7, #32
9000069e:	2230      	movs	r2, #48	; 0x30
900006a0:	2100      	movs	r1, #0
900006a2:	4618      	mov	r0, r3
900006a4:	f006 fc32 	bl	90006f0c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
900006a8:	f107 030c 	add.w	r3, r7, #12
900006ac:	2200      	movs	r2, #0
900006ae:	601a      	str	r2, [r3, #0]
900006b0:	605a      	str	r2, [r3, #4]
900006b2:	609a      	str	r2, [r3, #8]
900006b4:	60da      	str	r2, [r3, #12]
900006b6:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
900006b8:	4b2b      	ldr	r3, [pc, #172]	; (90000768 <SystemClock_Config+0xd4>)
900006ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900006bc:	4a2a      	ldr	r2, [pc, #168]	; (90000768 <SystemClock_Config+0xd4>)
900006be:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
900006c2:	6413      	str	r3, [r2, #64]	; 0x40
900006c4:	4b28      	ldr	r3, [pc, #160]	; (90000768 <SystemClock_Config+0xd4>)
900006c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900006c8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
900006cc:	60bb      	str	r3, [r7, #8]
900006ce:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
900006d0:	4b26      	ldr	r3, [pc, #152]	; (9000076c <SystemClock_Config+0xd8>)
900006d2:	681b      	ldr	r3, [r3, #0]
900006d4:	4a25      	ldr	r2, [pc, #148]	; (9000076c <SystemClock_Config+0xd8>)
900006d6:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
900006da:	6013      	str	r3, [r2, #0]
900006dc:	4b23      	ldr	r3, [pc, #140]	; (9000076c <SystemClock_Config+0xd8>)
900006de:	681b      	ldr	r3, [r3, #0]
900006e0:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
900006e4:	607b      	str	r3, [r7, #4]
900006e6:	687b      	ldr	r3, [r7, #4]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
900006e8:	2301      	movs	r3, #1
900006ea:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
900006ec:	f44f 3380 	mov.w	r3, #65536	; 0x10000
900006f0:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
900006f2:	2302      	movs	r3, #2
900006f4:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
900006f6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
900006fa:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 25;
900006fc:	2319      	movs	r3, #25
900006fe:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 432;
90000700:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
90000704:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
90000706:	2302      	movs	r3, #2
90000708:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 2;
9000070a:	2302      	movs	r3, #2
9000070c:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
9000070e:	f107 0320 	add.w	r3, r7, #32
90000712:	4618      	mov	r0, r3
90000714:	f004 fb54 	bl	90004dc0 <HAL_RCC_OscConfig>
90000718:	4603      	mov	r3, r0
9000071a:	2b00      	cmp	r3, #0
9000071c:	d001      	beq.n	90000722 <SystemClock_Config+0x8e>
  {
    Error_Handler();
9000071e:	f000 fcaf 	bl	90001080 <Error_Handler>
  }
  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
90000722:	f004 fafd 	bl	90004d20 <HAL_PWREx_EnableOverDrive>
90000726:	4603      	mov	r3, r0
90000728:	2b00      	cmp	r3, #0
9000072a:	d001      	beq.n	90000730 <SystemClock_Config+0x9c>
  {
    Error_Handler();
9000072c:	f000 fca8 	bl	90001080 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
90000730:	230f      	movs	r3, #15
90000732:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
90000734:	2302      	movs	r3, #2
90000736:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
90000738:	2300      	movs	r3, #0
9000073a:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
9000073c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
90000740:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
90000742:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90000746:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
90000748:	f107 030c 	add.w	r3, r7, #12
9000074c:	2107      	movs	r1, #7
9000074e:	4618      	mov	r0, r3
90000750:	f004 fdda 	bl	90005308 <HAL_RCC_ClockConfig>
90000754:	4603      	mov	r3, r0
90000756:	2b00      	cmp	r3, #0
90000758:	d001      	beq.n	9000075e <SystemClock_Config+0xca>
  {
    Error_Handler();
9000075a:	f000 fc91 	bl	90001080 <Error_Handler>
  }
}
9000075e:	bf00      	nop
90000760:	3750      	adds	r7, #80	; 0x50
90000762:	46bd      	mov	sp, r7
90000764:	bd80      	pop	{r7, pc}
90000766:	bf00      	nop
90000768:	40023800 	.word	0x40023800
9000076c:	40007000 	.word	0x40007000

90000770 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
90000770:	b580      	push	{r7, lr}
90000772:	b090      	sub	sp, #64	; 0x40
90000774:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
90000776:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000077a:	2200      	movs	r2, #0
9000077c:	601a      	str	r2, [r3, #0]
9000077e:	605a      	str	r2, [r3, #4]
90000780:	609a      	str	r2, [r3, #8]
90000782:	60da      	str	r2, [r3, #12]
90000784:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
90000786:	4bad      	ldr	r3, [pc, #692]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000788:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000078a:	4aac      	ldr	r2, [pc, #688]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000078c:	f043 0310 	orr.w	r3, r3, #16
90000790:	6313      	str	r3, [r2, #48]	; 0x30
90000792:	4baa      	ldr	r3, [pc, #680]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000794:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000796:	f003 0310 	and.w	r3, r3, #16
9000079a:	62bb      	str	r3, [r7, #40]	; 0x28
9000079c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  __HAL_RCC_GPIOG_CLK_ENABLE();
9000079e:	4ba7      	ldr	r3, [pc, #668]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007a2:	4aa6      	ldr	r2, [pc, #664]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
900007a8:	6313      	str	r3, [r2, #48]	; 0x30
900007aa:	4ba4      	ldr	r3, [pc, #656]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007ae:	f003 0340 	and.w	r3, r3, #64	; 0x40
900007b2:	627b      	str	r3, [r7, #36]	; 0x24
900007b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  __HAL_RCC_GPIOB_CLK_ENABLE();
900007b6:	4ba1      	ldr	r3, [pc, #644]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007ba:	4aa0      	ldr	r2, [pc, #640]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007bc:	f043 0302 	orr.w	r3, r3, #2
900007c0:	6313      	str	r3, [r2, #48]	; 0x30
900007c2:	4b9e      	ldr	r3, [pc, #632]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007c6:	f003 0302 	and.w	r3, r3, #2
900007ca:	623b      	str	r3, [r7, #32]
900007cc:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
900007ce:	4b9b      	ldr	r3, [pc, #620]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007d2:	4a9a      	ldr	r2, [pc, #616]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007d4:	f043 0308 	orr.w	r3, r3, #8
900007d8:	6313      	str	r3, [r2, #48]	; 0x30
900007da:	4b98      	ldr	r3, [pc, #608]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007de:	f003 0308 	and.w	r3, r3, #8
900007e2:	61fb      	str	r3, [r7, #28]
900007e4:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOC_CLK_ENABLE();
900007e6:	4b95      	ldr	r3, [pc, #596]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007ea:	4a94      	ldr	r2, [pc, #592]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007ec:	f043 0304 	orr.w	r3, r3, #4
900007f0:	6313      	str	r3, [r2, #48]	; 0x30
900007f2:	4b92      	ldr	r3, [pc, #584]	; (90000a3c <MX_GPIO_Init+0x2cc>)
900007f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900007f6:	f003 0304 	and.w	r3, r3, #4
900007fa:	61bb      	str	r3, [r7, #24]
900007fc:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOA_CLK_ENABLE();
900007fe:	4b8f      	ldr	r3, [pc, #572]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000800:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000802:	4a8e      	ldr	r2, [pc, #568]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000804:	f043 0301 	orr.w	r3, r3, #1
90000808:	6313      	str	r3, [r2, #48]	; 0x30
9000080a:	4b8c      	ldr	r3, [pc, #560]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000080c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000080e:	f003 0301 	and.w	r3, r3, #1
90000812:	617b      	str	r3, [r7, #20]
90000814:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
90000816:	4b89      	ldr	r3, [pc, #548]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000818:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000081a:	4a88      	ldr	r2, [pc, #544]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000081c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
90000820:	6313      	str	r3, [r2, #48]	; 0x30
90000822:	4b86      	ldr	r3, [pc, #536]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000824:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000826:	f403 7300 	and.w	r3, r3, #512	; 0x200
9000082a:	613b      	str	r3, [r7, #16]
9000082c:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOI_CLK_ENABLE();
9000082e:	4b83      	ldr	r3, [pc, #524]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000830:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000832:	4a82      	ldr	r2, [pc, #520]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000834:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90000838:	6313      	str	r3, [r2, #48]	; 0x30
9000083a:	4b80      	ldr	r3, [pc, #512]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000083c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000083e:	f403 7380 	and.w	r3, r3, #256	; 0x100
90000842:	60fb      	str	r3, [r7, #12]
90000844:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOK_CLK_ENABLE();
90000846:	4b7d      	ldr	r3, [pc, #500]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000848:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000084a:	4a7c      	ldr	r2, [pc, #496]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000084c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
90000850:	6313      	str	r3, [r2, #48]	; 0x30
90000852:	4b7a      	ldr	r3, [pc, #488]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000854:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000856:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9000085a:	60bb      	str	r3, [r7, #8]
9000085c:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
9000085e:	4b77      	ldr	r3, [pc, #476]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000860:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000862:	4a76      	ldr	r2, [pc, #472]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000864:	f043 0320 	orr.w	r3, r3, #32
90000868:	6313      	str	r3, [r2, #48]	; 0x30
9000086a:	4b74      	ldr	r3, [pc, #464]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000086c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000086e:	f003 0320 	and.w	r3, r3, #32
90000872:	607b      	str	r3, [r7, #4]
90000874:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
90000876:	4b71      	ldr	r3, [pc, #452]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000878:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000087a:	4a70      	ldr	r2, [pc, #448]	; (90000a3c <MX_GPIO_Init+0x2cc>)
9000087c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90000880:	6313      	str	r3, [r2, #48]	; 0x30
90000882:	4b6e      	ldr	r3, [pc, #440]	; (90000a3c <MX_GPIO_Init+0x2cc>)
90000884:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90000886:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000088a:	603b      	str	r3, [r7, #0]
9000088c:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
9000088e:	2201      	movs	r2, #1
90000890:	2120      	movs	r1, #32
90000892:	486b      	ldr	r0, [pc, #428]	; (90000a40 <MX_GPIO_Init+0x2d0>)
90000894:	f003 fce4 	bl	90004260 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOI, ARDUINO_D7_Pin|ARDUINO_D8_Pin|GPIO_PIN_1|LCD_DISP_Pin, GPIO_PIN_RESET);
90000898:	2200      	movs	r2, #0
9000089a:	f241 010e 	movw	r1, #4110	; 0x100e
9000089e:	4869      	ldr	r0, [pc, #420]	; (90000a44 <MX_GPIO_Init+0x2d4>)
900008a0:	f003 fcde 	bl	90004260 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_RESET);
900008a4:	2200      	movs	r2, #0
900008a6:	2108      	movs	r1, #8
900008a8:	4867      	ldr	r0, [pc, #412]	; (90000a48 <MX_GPIO_Init+0x2d8>)
900008aa:	f003 fcd9 	bl	90004260 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(DCMI_PWR_EN_GPIO_Port, DCMI_PWR_EN_Pin, GPIO_PIN_RESET);
900008ae:	2200      	movs	r2, #0
900008b0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
900008b4:	4865      	ldr	r0, [pc, #404]	; (90000a4c <MX_GPIO_Init+0x2dc>)
900008b6:	f003 fcd3 	bl	90004260 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin, GPIO_PIN_RESET);
900008ba:	2200      	movs	r2, #0
900008bc:	21c8      	movs	r1, #200	; 0xc8
900008be:	4864      	ldr	r0, [pc, #400]	; (90000a50 <MX_GPIO_Init+0x2e0>)
900008c0:	f003 fcce 	bl	90004260 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : LCD_B0_Pin */
  GPIO_InitStruct.Pin = LCD_B0_Pin;
900008c4:	2310      	movs	r3, #16
900008c6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900008c8:	2302      	movs	r3, #2
900008ca:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
900008cc:	2300      	movs	r3, #0
900008ce:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
900008d0:	2300      	movs	r3, #0
900008d2:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
900008d4:	230e      	movs	r3, #14
900008d6:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(LCD_B0_GPIO_Port, &GPIO_InitStruct);
900008d8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
900008dc:	4619      	mov	r1, r3
900008de:	485d      	ldr	r0, [pc, #372]	; (90000a54 <MX_GPIO_Init+0x2e4>)
900008e0:	f003 fb12 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_HS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_HS_OverCurrent_Pin;
900008e4:	2308      	movs	r3, #8
900008e6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
900008e8:	2300      	movs	r3, #0
900008ea:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
900008ec:	2300      	movs	r3, #0
900008ee:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(OTG_HS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
900008f0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
900008f4:	4619      	mov	r1, r3
900008f6:	4857      	ldr	r0, [pc, #348]	; (90000a54 <MX_GPIO_Init+0x2e4>)
900008f8:	f003 fb06 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_D2_Pin */
  GPIO_InitStruct.Pin = QSPI_D2_Pin;
900008fc:	2304      	movs	r3, #4
900008fe:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000900:	2302      	movs	r3, #2
90000902:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000904:	2300      	movs	r3, #0
90000906:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000908:	2303      	movs	r3, #3
9000090a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
9000090c:	2309      	movs	r3, #9
9000090e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D2_GPIO_Port, &GPIO_InitStruct);
90000910:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000914:	4619      	mov	r1, r3
90000916:	484f      	ldr	r0, [pc, #316]	; (90000a54 <MX_GPIO_Init+0x2e4>)
90000918:	f003 faf6 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_TXD1_Pin RMII_TXD0_Pin RMII_TX_EN_Pin */
  GPIO_InitStruct.Pin = RMII_TXD1_Pin|RMII_TXD0_Pin|RMII_TX_EN_Pin;
9000091c:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
90000920:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000922:	2302      	movs	r3, #2
90000924:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000926:	2300      	movs	r3, #0
90000928:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000092a:	2303      	movs	r3, #3
9000092c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
9000092e:	230b      	movs	r3, #11
90000930:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
90000932:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000936:	4619      	mov	r1, r3
90000938:	4845      	ldr	r0, [pc, #276]	; (90000a50 <MX_GPIO_Init+0x2e0>)
9000093a:	f003 fae5 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : FMC_NBL1_Pin FMC_NBL0_Pin FMC_D5_Pin FMC_D6_Pin
                           FMC_D8_Pin FMC_D11_Pin FMC_D4_Pin FMC_D7_Pin
                           FMC_D9_Pin FMC_D12_Pin FMC_D10_Pin */
  GPIO_InitStruct.Pin = FMC_NBL1_Pin|FMC_NBL0_Pin|FMC_D5_Pin|FMC_D6_Pin
9000093e:	f64f 7383 	movw	r3, #65411	; 0xff83
90000942:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |FMC_D8_Pin|FMC_D11_Pin|FMC_D4_Pin|FMC_D7_Pin
                          |FMC_D9_Pin|FMC_D12_Pin|FMC_D10_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000944:	2302      	movs	r3, #2
90000946:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000948:	2300      	movs	r3, #0
9000094a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000094c:	2303      	movs	r3, #3
9000094e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000950:	230c      	movs	r3, #12
90000952:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
90000954:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000958:	4619      	mov	r1, r3
9000095a:	483e      	ldr	r0, [pc, #248]	; (90000a54 <MX_GPIO_Init+0x2e4>)
9000095c:	f003 fad4 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_SCL_D15_Pin ARDUINO_SDA_D14_Pin */
  GPIO_InitStruct.Pin = ARDUINO_SCL_D15_Pin|ARDUINO_SDA_D14_Pin;
90000960:	f44f 7340 	mov.w	r3, #768	; 0x300
90000964:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
90000966:	2312      	movs	r3, #18
90000968:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
9000096a:	2301      	movs	r3, #1
9000096c:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
9000096e:	2300      	movs	r3, #0
90000970:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
90000972:	2304      	movs	r3, #4
90000974:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
90000976:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000097a:	4619      	mov	r1, r3
9000097c:	4836      	ldr	r0, [pc, #216]	; (90000a58 <MX_GPIO_Init+0x2e8>)
9000097e:	f003 fac3 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_D7_Pin ULPI_D6_Pin ULPI_D5_Pin ULPI_D3_Pin
                           ULPI_D2_Pin ULPI_D1_Pin ULPI_D4_Pin */
  GPIO_InitStruct.Pin = ULPI_D7_Pin|ULPI_D6_Pin|ULPI_D5_Pin|ULPI_D3_Pin
90000982:	f643 4323 	movw	r3, #15395	; 0x3c23
90000986:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |ULPI_D2_Pin|ULPI_D1_Pin|ULPI_D4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000988:	2302      	movs	r3, #2
9000098a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
9000098c:	2300      	movs	r3, #0
9000098e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000990:	2303      	movs	r3, #3
90000992:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
90000994:	230a      	movs	r3, #10
90000996:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
90000998:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000099c:	4619      	mov	r1, r3
9000099e:	482e      	ldr	r0, [pc, #184]	; (90000a58 <MX_GPIO_Init+0x2e8>)
900009a0:	f003 fab2 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_PWM_D3_Pin */
  GPIO_InitStruct.Pin = ARDUINO_PWM_D3_Pin;
900009a4:	2310      	movs	r3, #16
900009a6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900009a8:	2302      	movs	r3, #2
900009aa:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
900009ac:	2300      	movs	r3, #0
900009ae:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
900009b0:	2300      	movs	r3, #0
900009b2:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
900009b4:	2302      	movs	r3, #2
900009b6:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_PWM_D3_GPIO_Port, &GPIO_InitStruct);
900009b8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
900009bc:	4619      	mov	r1, r3
900009be:	4826      	ldr	r0, [pc, #152]	; (90000a58 <MX_GPIO_Init+0x2e8>)
900009c0:	f003 faa2 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : SPDIF_RX0_Pin */
  GPIO_InitStruct.Pin = SPDIF_RX0_Pin;
900009c4:	2380      	movs	r3, #128	; 0x80
900009c6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900009c8:	2302      	movs	r3, #2
900009ca:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
900009cc:	2300      	movs	r3, #0
900009ce:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
900009d0:	2300      	movs	r3, #0
900009d2:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF8_SPDIFRX;
900009d4:	2308      	movs	r3, #8
900009d6:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SPDIF_RX0_GPIO_Port, &GPIO_InitStruct);
900009d8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
900009dc:	4619      	mov	r1, r3
900009de:	4818      	ldr	r0, [pc, #96]	; (90000a40 <MX_GPIO_Init+0x2d0>)
900009e0:	f003 fa92 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : SDMMC_CK_Pin SDMMC_D3_Pin SDMMC_D2_Pin PC9
                           PC8 */
  GPIO_InitStruct.Pin = SDMMC_CK_Pin|SDMMC_D3_Pin|SDMMC_D2_Pin|GPIO_PIN_9
900009e4:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
900009e8:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
900009ea:	2302      	movs	r3, #2
900009ec:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
900009ee:	2300      	movs	r3, #0
900009f0:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900009f2:	2303      	movs	r3, #3
900009f4:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
900009f6:	230c      	movs	r3, #12
900009f8:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
900009fa:	f107 032c 	add.w	r3, r7, #44	; 0x2c
900009fe:	4619      	mov	r1, r3
90000a00:	4816      	ldr	r0, [pc, #88]	; (90000a5c <MX_GPIO_Init+0x2ec>)
90000a02:	f003 fa81 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_PWM_D9_Pin */
  GPIO_InitStruct.Pin = ARDUINO_PWM_D9_Pin;
90000a06:	f44f 4300 	mov.w	r3, #32768	; 0x8000
90000a0a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a0c:	2302      	movs	r3, #2
90000a0e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000a10:	2300      	movs	r3, #0
90000a12:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000a14:	2300      	movs	r3, #0
90000a16:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
90000a18:	2301      	movs	r3, #1
90000a1a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_PWM_D9_GPIO_Port, &GPIO_InitStruct);
90000a1c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000a20:	4619      	mov	r1, r3
90000a22:	480f      	ldr	r0, [pc, #60]	; (90000a60 <MX_GPIO_Init+0x2f0>)
90000a24:	f003 fa70 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : DCMI_D6_Pin DCMI_D7_Pin */
  GPIO_InitStruct.Pin = DCMI_D6_Pin|DCMI_D7_Pin;
90000a28:	2360      	movs	r3, #96	; 0x60
90000a2a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a2c:	2302      	movs	r3, #2
90000a2e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000a30:	2300      	movs	r3, #0
90000a32:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000a34:	2300      	movs	r3, #0
90000a36:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
90000a38:	230d      	movs	r3, #13
90000a3a:	e013      	b.n	90000a64 <MX_GPIO_Init+0x2f4>
90000a3c:	40023800 	.word	0x40023800
90000a40:	40020c00 	.word	0x40020c00
90000a44:	40022000 	.word	0x40022000
90000a48:	40022800 	.word	0x40022800
90000a4c:	40021c00 	.word	0x40021c00
90000a50:	40021800 	.word	0x40021800
90000a54:	40021000 	.word	0x40021000
90000a58:	40020400 	.word	0x40020400
90000a5c:	40020800 	.word	0x40020800
90000a60:	40020000 	.word	0x40020000
90000a64:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
90000a66:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000a6a:	4619      	mov	r1, r3
90000a6c:	48bb      	ldr	r0, [pc, #748]	; (90000d5c <MX_GPIO_Init+0x5ec>)
90000a6e:	f003 fa4b 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : VCP_RX_Pin */
  GPIO_InitStruct.Pin = VCP_RX_Pin;
90000a72:	2380      	movs	r3, #128	; 0x80
90000a74:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a76:	2302      	movs	r3, #2
90000a78:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000a7a:	2300      	movs	r3, #0
90000a7c:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000a7e:	2300      	movs	r3, #0
90000a80:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
90000a82:	2307      	movs	r3, #7
90000a84:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
90000a86:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000a8a:	4619      	mov	r1, r3
90000a8c:	48b4      	ldr	r0, [pc, #720]	; (90000d60 <MX_GPIO_Init+0x5f0>)
90000a8e:	f003 fa3b 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_NCS_Pin */
  GPIO_InitStruct.Pin = QSPI_NCS_Pin;
90000a92:	2340      	movs	r3, #64	; 0x40
90000a94:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000a96:	2302      	movs	r3, #2
90000a98:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000a9a:	2300      	movs	r3, #0
90000a9c:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000a9e:	2303      	movs	r3, #3
90000aa0:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
90000aa2:	230a      	movs	r3, #10
90000aa4:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_NCS_GPIO_Port, &GPIO_InitStruct);
90000aa6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000aaa:	4619      	mov	r1, r3
90000aac:	48ac      	ldr	r0, [pc, #688]	; (90000d60 <MX_GPIO_Init+0x5f0>)
90000aae:	f003 fa2b 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : FMC_SDNCAS_Pin FMC_SDCLK_Pin FMC_A11_Pin FMC_A10_Pin
                           FMC_BA1_Pin FMC_BA0_Pin */
  GPIO_InitStruct.Pin = FMC_SDNCAS_Pin|FMC_SDCLK_Pin|FMC_A11_Pin|FMC_A10_Pin
90000ab2:	f248 1333 	movw	r3, #33075	; 0x8133
90000ab6:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |FMC_BA1_Pin|FMC_BA0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000ab8:	2302      	movs	r3, #2
90000aba:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000abc:	2300      	movs	r3, #0
90000abe:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000ac0:	2303      	movs	r3, #3
90000ac2:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000ac4:	230c      	movs	r3, #12
90000ac6:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
90000ac8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000acc:	4619      	mov	r1, r3
90000ace:	48a5      	ldr	r0, [pc, #660]	; (90000d64 <MX_GPIO_Init+0x5f4>)
90000ad0:	f003 fa1a 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_B1_Pin LCD_B2_Pin LCD_B3_Pin LCD_G4_Pin
                           LCD_G1_Pin LCD_G3_Pin LCD_G0_Pin LCD_G2_Pin
                           LCD_R7_Pin LCD_R5_Pin LCD_R6_Pin LCD_R4_Pin
                           LCD_R3_Pin LCD_R1_Pin LCD_R2_Pin */
  GPIO_InitStruct.Pin = LCD_B1_Pin|LCD_B2_Pin|LCD_B3_Pin|LCD_G4_Pin
90000ad4:	f64e 73ff 	movw	r3, #61439	; 0xefff
90000ad8:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |LCD_G1_Pin|LCD_G3_Pin|LCD_G0_Pin|LCD_G2_Pin
                          |LCD_R7_Pin|LCD_R5_Pin|LCD_R6_Pin|LCD_R4_Pin
                          |LCD_R3_Pin|LCD_R1_Pin|LCD_R2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000ada:	2302      	movs	r3, #2
90000adc:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000ade:	2300      	movs	r3, #0
90000ae0:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000ae2:	2300      	movs	r3, #0
90000ae4:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
90000ae6:	230e      	movs	r3, #14
90000ae8:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
90000aea:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000aee:	4619      	mov	r1, r3
90000af0:	489d      	ldr	r0, [pc, #628]	; (90000d68 <MX_GPIO_Init+0x5f8>)
90000af2:	f003 fa09 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_VBUS_Pin */
  GPIO_InitStruct.Pin = OTG_FS_VBUS_Pin;
90000af6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90000afa:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
90000afc:	2300      	movs	r3, #0
90000afe:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000b00:	2300      	movs	r3, #0
90000b02:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(OTG_FS_VBUS_GPIO_Port, &GPIO_InitStruct);
90000b04:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000b08:	4619      	mov	r1, r3
90000b0a:	4897      	ldr	r0, [pc, #604]	; (90000d68 <MX_GPIO_Init+0x5f8>)
90000b0c:	f003 f9fc 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : Audio_INT_Pin */
  GPIO_InitStruct.Pin = Audio_INT_Pin;
90000b10:	2340      	movs	r3, #64	; 0x40
90000b12:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
90000b14:	4b95      	ldr	r3, [pc, #596]	; (90000d6c <MX_GPIO_Init+0x5fc>)
90000b16:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000b18:	2300      	movs	r3, #0
90000b1a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(Audio_INT_GPIO_Port, &GPIO_InitStruct);
90000b1c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000b20:	4619      	mov	r1, r3
90000b22:	4893      	ldr	r0, [pc, #588]	; (90000d70 <MX_GPIO_Init+0x600>)
90000b24:	f003 f9f0 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : FMC_D2_Pin FMC_D3_Pin FMC_D1_Pin FMC_D15_Pin
                           FMC_D0_Pin FMC_D14_Pin FMC_D13_Pin */
  GPIO_InitStruct.Pin = FMC_D2_Pin|FMC_D3_Pin|FMC_D1_Pin|FMC_D15_Pin
90000b28:	f24c 7303 	movw	r3, #50947	; 0xc703
90000b2c:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |FMC_D0_Pin|FMC_D14_Pin|FMC_D13_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000b2e:	2302      	movs	r3, #2
90000b30:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000b32:	2300      	movs	r3, #0
90000b34:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000b36:	2303      	movs	r3, #3
90000b38:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000b3a:	230c      	movs	r3, #12
90000b3c:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
90000b3e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000b42:	4619      	mov	r1, r3
90000b44:	488a      	ldr	r0, [pc, #552]	; (90000d70 <MX_GPIO_Init+0x600>)
90000b46:	f003 f9df 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : OTG_FS_P_Pin OTG_FS_N_Pin OTG_FS_ID_Pin */
  GPIO_InitStruct.Pin = OTG_FS_P_Pin|OTG_FS_N_Pin|OTG_FS_ID_Pin;
90000b4a:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
90000b4e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000b50:	2302      	movs	r3, #2
90000b52:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000b54:	2300      	movs	r3, #0
90000b56:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000b58:	2303      	movs	r3, #3
90000b5a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
90000b5c:	230a      	movs	r3, #10
90000b5e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90000b60:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000b64:	4619      	mov	r1, r3
90000b66:	4883      	ldr	r0, [pc, #524]	; (90000d74 <MX_GPIO_Init+0x604>)
90000b68:	f003 f9ce 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : SAI2_MCLKA_Pin SAI2_SCKA_Pin SAI2_FSA_Pin SAI2_SDA_Pin */
  GPIO_InitStruct.Pin = SAI2_MCLKA_Pin|SAI2_SCKA_Pin|SAI2_FSA_Pin|SAI2_SDA_Pin;
90000b6c:	23f0      	movs	r3, #240	; 0xf0
90000b6e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000b70:	2302      	movs	r3, #2
90000b72:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000b74:	2300      	movs	r3, #0
90000b76:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000b78:	2300      	movs	r3, #0
90000b7a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
90000b7c:	230a      	movs	r3, #10
90000b7e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
90000b80:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000b84:	4619      	mov	r1, r3
90000b86:	487c      	ldr	r0, [pc, #496]	; (90000d78 <MX_GPIO_Init+0x608>)
90000b88:	f003 f9be 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_DE_Pin LCD_B7_Pin LCD_B6_Pin LCD_B5_Pin
                           LCD_G6_Pin LCD_G7_Pin LCD_G5_Pin */
  GPIO_InitStruct.Pin = LCD_DE_Pin|LCD_B7_Pin|LCD_B6_Pin|LCD_B5_Pin
90000b8c:	23f7      	movs	r3, #247	; 0xf7
90000b8e:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |LCD_G6_Pin|LCD_G7_Pin|LCD_G5_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000b90:	2302      	movs	r3, #2
90000b92:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000b94:	2300      	movs	r3, #0
90000b96:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000b98:	2300      	movs	r3, #0
90000b9a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
90000b9c:	230e      	movs	r3, #14
90000b9e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
90000ba0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000ba4:	4619      	mov	r1, r3
90000ba6:	4875      	ldr	r0, [pc, #468]	; (90000d7c <MX_GPIO_Init+0x60c>)
90000ba8:	f003 f9ae 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_B4_Pin */
  GPIO_InitStruct.Pin = LCD_B4_Pin;
90000bac:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90000bb0:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000bb2:	2302      	movs	r3, #2
90000bb4:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000bb6:	2300      	movs	r3, #0
90000bb8:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000bba:	2300      	movs	r3, #0
90000bbc:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
90000bbe:	2309      	movs	r3, #9
90000bc0:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(LCD_B4_GPIO_Port, &GPIO_InitStruct);
90000bc2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000bc6:	4619      	mov	r1, r3
90000bc8:	4866      	ldr	r0, [pc, #408]	; (90000d64 <MX_GPIO_Init+0x5f4>)
90000bca:	f003 f99d 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : SAI2_SDB_Pin */
  GPIO_InitStruct.Pin = SAI2_SDB_Pin;
90000bce:	f44f 6380 	mov.w	r3, #1024	; 0x400
90000bd2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000bd4:	2302      	movs	r3, #2
90000bd6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000bd8:	2300      	movs	r3, #0
90000bda:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000bdc:	2300      	movs	r3, #0
90000bde:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
90000be0:	230a      	movs	r3, #10
90000be2:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SAI2_SDB_GPIO_Port, &GPIO_InitStruct);
90000be4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000be8:	4619      	mov	r1, r3
90000bea:	485e      	ldr	r0, [pc, #376]	; (90000d64 <MX_GPIO_Init+0x5f4>)
90000bec:	f003 f98c 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
90000bf0:	2320      	movs	r3, #32
90000bf2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
90000bf4:	2301      	movs	r3, #1
90000bf6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000bf8:	2300      	movs	r3, #0
90000bfa:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000bfc:	2300      	movs	r3, #0
90000bfe:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
90000c00:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000c04:	4619      	mov	r1, r3
90000c06:	485a      	ldr	r0, [pc, #360]	; (90000d70 <MX_GPIO_Init+0x600>)
90000c08:	f003 f97e 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : DCMI_D5_Pin */
  GPIO_InitStruct.Pin = DCMI_D5_Pin;
90000c0c:	2308      	movs	r3, #8
90000c0e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000c10:	2302      	movs	r3, #2
90000c12:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000c14:	2300      	movs	r3, #0
90000c16:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000c18:	2300      	movs	r3, #0
90000c1a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
90000c1c:	230d      	movs	r3, #13
90000c1e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(DCMI_D5_GPIO_Port, &GPIO_InitStruct);
90000c20:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000c24:	4619      	mov	r1, r3
90000c26:	4852      	ldr	r0, [pc, #328]	; (90000d70 <MX_GPIO_Init+0x600>)
90000c28:	f003 f96e 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_D7_Pin ARDUINO_D8_Pin PI1 LCD_DISP_Pin */
  GPIO_InitStruct.Pin = ARDUINO_D7_Pin|ARDUINO_D8_Pin|GPIO_PIN_1|LCD_DISP_Pin;
90000c2c:	f241 030e 	movw	r3, #4110	; 0x100e
90000c30:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
90000c32:	2301      	movs	r3, #1
90000c34:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000c36:	2300      	movs	r3, #0
90000c38:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000c3a:	2300      	movs	r3, #0
90000c3c:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
90000c3e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000c42:	4619      	mov	r1, r3
90000c44:	484c      	ldr	r0, [pc, #304]	; (90000d78 <MX_GPIO_Init+0x608>)
90000c46:	f003 f95f 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : uSD_Detect_Pin */
  GPIO_InitStruct.Pin = uSD_Detect_Pin;
90000c4a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90000c4e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
90000c50:	2300      	movs	r3, #0
90000c52:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000c54:	2300      	movs	r3, #0
90000c56:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(uSD_Detect_GPIO_Port, &GPIO_InitStruct);
90000c58:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000c5c:	4619      	mov	r1, r3
90000c5e:	4848      	ldr	r0, [pc, #288]	; (90000d80 <MX_GPIO_Init+0x610>)
90000c60:	f003 f952 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : FMC_A0_Pin FMC_A1_Pin FMC_A2_Pin FMC_A3_Pin
                           FMC_A4_Pin FMC_A5_Pin FMC_A6_Pin FMC_A9_Pin
                           FMC_A7_Pin FMC_A8_Pin FMC_SDNRAS_Pin */
  GPIO_InitStruct.Pin = FMC_A0_Pin|FMC_A1_Pin|FMC_A2_Pin|FMC_A3_Pin
90000c64:	f64f 033f 	movw	r3, #63551	; 0xf83f
90000c68:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |FMC_A4_Pin|FMC_A5_Pin|FMC_A6_Pin|FMC_A9_Pin
                          |FMC_A7_Pin|FMC_A8_Pin|FMC_SDNRAS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000c6a:	2302      	movs	r3, #2
90000c6c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000c6e:	2300      	movs	r3, #0
90000c70:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000c72:	2303      	movs	r3, #3
90000c74:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000c76:	230c      	movs	r3, #12
90000c78:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
90000c7a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000c7e:	4619      	mov	r1, r3
90000c80:	4840      	ldr	r0, [pc, #256]	; (90000d84 <MX_GPIO_Init+0x614>)
90000c82:	f003 f941 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_HSYNC_Pin LCD_VSYNC_Pin LCD_R0_Pin LCD_CLK_Pin */
  GPIO_InitStruct.Pin = LCD_HSYNC_Pin|LCD_VSYNC_Pin|LCD_R0_Pin|LCD_CLK_Pin;
90000c86:	f44f 4346 	mov.w	r3, #50688	; 0xc600
90000c8a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000c8c:	2302      	movs	r3, #2
90000c8e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000c90:	2300      	movs	r3, #0
90000c92:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000c94:	2300      	movs	r3, #0
90000c96:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
90000c98:	230e      	movs	r3, #14
90000c9a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
90000c9c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000ca0:	4619      	mov	r1, r3
90000ca2:	4835      	ldr	r0, [pc, #212]	; (90000d78 <MX_GPIO_Init+0x608>)
90000ca4:	f003 f930 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_BL_CTRL_Pin */
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin;
90000ca8:	2308      	movs	r3, #8
90000caa:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
90000cac:	2301      	movs	r3, #1
90000cae:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000cb0:	2300      	movs	r3, #0
90000cb2:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000cb4:	2300      	movs	r3, #0
90000cb6:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
90000cb8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000cbc:	4619      	mov	r1, r3
90000cbe:	482f      	ldr	r0, [pc, #188]	; (90000d7c <MX_GPIO_Init+0x60c>)
90000cc0:	f003 f922 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : DCMI_VSYNC_Pin */
  GPIO_InitStruct.Pin = DCMI_VSYNC_Pin;
90000cc4:	f44f 7300 	mov.w	r3, #512	; 0x200
90000cc8:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000cca:	2302      	movs	r3, #2
90000ccc:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000cce:	2300      	movs	r3, #0
90000cd0:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000cd2:	2300      	movs	r3, #0
90000cd4:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
90000cd6:	230d      	movs	r3, #13
90000cd8:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(DCMI_VSYNC_GPIO_Port, &GPIO_InitStruct);
90000cda:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000cde:	4619      	mov	r1, r3
90000ce0:	4820      	ldr	r0, [pc, #128]	; (90000d64 <MX_GPIO_Init+0x5f4>)
90000ce2:	f003 f911 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
90000ce6:	2310      	movs	r3, #16
90000ce8:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
90000cea:	2300      	movs	r3, #0
90000cec:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000cee:	2300      	movs	r3, #0
90000cf0:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
90000cf2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000cf6:	4619      	mov	r1, r3
90000cf8:	481d      	ldr	r0, [pc, #116]	; (90000d70 <MX_GPIO_Init+0x600>)
90000cfa:	f003 f905 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : SDMMC_D0_Pin */
  GPIO_InitStruct.Pin = SDMMC_D0_Pin;
90000cfe:	2304      	movs	r3, #4
90000d00:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000d02:	2302      	movs	r3, #2
90000d04:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000d06:	2300      	movs	r3, #0
90000d08:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000d0a:	2303      	movs	r3, #3
90000d0c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
90000d0e:	230c      	movs	r3, #12
90000d10:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SDMMC_D0_GPIO_Port, &GPIO_InitStruct);
90000d12:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000d16:	4619      	mov	r1, r3
90000d18:	4815      	ldr	r0, [pc, #84]	; (90000d70 <MX_GPIO_Init+0x600>)
90000d1a:	f003 f8f5 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : TP3_Pin NC2_Pin */
  GPIO_InitStruct.Pin = TP3_Pin|NC2_Pin;
90000d1e:	f248 0304 	movw	r3, #32772	; 0x8004
90000d22:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
90000d24:	2300      	movs	r3, #0
90000d26:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000d28:	2300      	movs	r3, #0
90000d2a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
90000d2c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000d30:	4619      	mov	r1, r3
90000d32:	4815      	ldr	r0, [pc, #84]	; (90000d88 <MX_GPIO_Init+0x618>)
90000d34:	f003 f8e8 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : DCMI_PWR_EN_Pin */
  GPIO_InitStruct.Pin = DCMI_PWR_EN_Pin;
90000d38:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90000d3c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
90000d3e:	2301      	movs	r3, #1
90000d40:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000d42:	2300      	movs	r3, #0
90000d44:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000d46:	2300      	movs	r3, #0
90000d48:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(DCMI_PWR_EN_GPIO_Port, &GPIO_InitStruct);
90000d4a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000d4e:	4619      	mov	r1, r3
90000d50:	480d      	ldr	r0, [pc, #52]	; (90000d88 <MX_GPIO_Init+0x618>)
90000d52:	f003 f8d9 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : DCMI_D4_Pin DCMI_D3_Pin DCMI_D0_Pin DCMI_D2_Pin
                           DCMI_D1_Pin */
  GPIO_InitStruct.Pin = DCMI_D4_Pin|DCMI_D3_Pin|DCMI_D0_Pin|DCMI_D2_Pin
90000d56:	f44f 43bc 	mov.w	r3, #24064	; 0x5e00
90000d5a:	e017      	b.n	90000d8c <MX_GPIO_Init+0x61c>
90000d5c:	40021000 	.word	0x40021000
90000d60:	40020400 	.word	0x40020400
90000d64:	40021800 	.word	0x40021800
90000d68:	40022400 	.word	0x40022400
90000d6c:	10120000 	.word	0x10120000
90000d70:	40020c00 	.word	0x40020c00
90000d74:	40020000 	.word	0x40020000
90000d78:	40022000 	.word	0x40022000
90000d7c:	40022800 	.word	0x40022800
90000d80:	40020800 	.word	0x40020800
90000d84:	40021400 	.word	0x40021400
90000d88:	40021c00 	.word	0x40021c00
90000d8c:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |DCMI_D1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000d8e:	2302      	movs	r3, #2
90000d90:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000d92:	2300      	movs	r3, #0
90000d94:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000d96:	2300      	movs	r3, #0
90000d98:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
90000d9a:	230d      	movs	r3, #13
90000d9c:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
90000d9e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000da2:	4619      	mov	r1, r3
90000da4:	48ad      	ldr	r0, [pc, #692]	; (9000105c <MX_GPIO_Init+0x8ec>)
90000da6:	f003 f8af 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_PWM_CS_D5_Pin */
  GPIO_InitStruct.Pin = ARDUINO_PWM_CS_D5_Pin;
90000daa:	2301      	movs	r3, #1
90000dac:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000dae:	2302      	movs	r3, #2
90000db0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000db2:	2300      	movs	r3, #0
90000db4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000db6:	2300      	movs	r3, #0
90000db8:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
90000dba:	2302      	movs	r3, #2
90000dbc:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_PWM_CS_D5_GPIO_Port, &GPIO_InitStruct);
90000dbe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000dc2:	4619      	mov	r1, r3
90000dc4:	48a6      	ldr	r0, [pc, #664]	; (90001060 <MX_GPIO_Init+0x8f0>)
90000dc6:	f003 f89f 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : VCP_TX_Pin */
  GPIO_InitStruct.Pin = VCP_TX_Pin;
90000dca:	f44f 7300 	mov.w	r3, #512	; 0x200
90000dce:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000dd0:	2302      	movs	r3, #2
90000dd2:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000dd4:	2300      	movs	r3, #0
90000dd6:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000dd8:	2300      	movs	r3, #0
90000dda:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
90000ddc:	2307      	movs	r3, #7
90000dde:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
90000de0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000de4:	4619      	mov	r1, r3
90000de6:	489f      	ldr	r0, [pc, #636]	; (90001064 <MX_GPIO_Init+0x8f4>)
90000de8:	f003 f88e 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_PWM_D10_Pin */
  GPIO_InitStruct.Pin = ARDUINO_PWM_D10_Pin;
90000dec:	f44f 7380 	mov.w	r3, #256	; 0x100
90000df0:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000df2:	2302      	movs	r3, #2
90000df4:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000df6:	2300      	movs	r3, #0
90000df8:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000dfa:	2300      	movs	r3, #0
90000dfc:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
90000dfe:	2301      	movs	r3, #1
90000e00:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_PWM_D10_GPIO_Port, &GPIO_InitStruct);
90000e02:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000e06:	4619      	mov	r1, r3
90000e08:	4896      	ldr	r0, [pc, #600]	; (90001064 <MX_GPIO_Init+0x8f4>)
90000e0a:	f003 f87d 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_INT_Pin */
  GPIO_InitStruct.Pin = LCD_INT_Pin;
90000e0e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90000e12:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
90000e14:	4b94      	ldr	r3, [pc, #592]	; (90001068 <MX_GPIO_Init+0x8f8>)
90000e16:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000e18:	2300      	movs	r3, #0
90000e1a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
90000e1c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000e20:	4619      	mov	r1, r3
90000e22:	488f      	ldr	r0, [pc, #572]	; (90001060 <MX_GPIO_Init+0x8f0>)
90000e24:	f003 f870 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_RX_D0_Pin ARDUINO_TX_D1_Pin */
  GPIO_InitStruct.Pin = ARDUINO_RX_D0_Pin|ARDUINO_TX_D1_Pin;
90000e28:	23c0      	movs	r3, #192	; 0xc0
90000e2a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000e2c:	2302      	movs	r3, #2
90000e2e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000e30:	2300      	movs	r3, #0
90000e32:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000e34:	2303      	movs	r3, #3
90000e36:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
90000e38:	2308      	movs	r3, #8
90000e3a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000e3c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000e40:	4619      	mov	r1, r3
90000e42:	488a      	ldr	r0, [pc, #552]	; (9000106c <MX_GPIO_Init+0x8fc>)
90000e44:	f003 f860 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ULPI_NXT_Pin */
  GPIO_InitStruct.Pin = ULPI_NXT_Pin;
90000e48:	2310      	movs	r3, #16
90000e4a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000e4c:	2302      	movs	r3, #2
90000e4e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000e50:	2300      	movs	r3, #0
90000e52:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000e54:	2303      	movs	r3, #3
90000e56:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
90000e58:	230a      	movs	r3, #10
90000e5a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ULPI_NXT_GPIO_Port, &GPIO_InitStruct);
90000e5c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000e60:	4619      	mov	r1, r3
90000e62:	487e      	ldr	r0, [pc, #504]	; (9000105c <MX_GPIO_Init+0x8ec>)
90000e64:	f003 f850 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : FMC_SDNME_Pin FMC_SDNE0_Pin */
  GPIO_InitStruct.Pin = FMC_SDNME_Pin|FMC_SDNE0_Pin;
90000e68:	2328      	movs	r3, #40	; 0x28
90000e6a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000e6c:	2302      	movs	r3, #2
90000e6e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000e70:	2300      	movs	r3, #0
90000e72:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000e74:	2303      	movs	r3, #3
90000e76:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000e78:	230c      	movs	r3, #12
90000e7a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
90000e7c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000e80:	4619      	mov	r1, r3
90000e82:	4876      	ldr	r0, [pc, #472]	; (9000105c <MX_GPIO_Init+0x8ec>)
90000e84:	f003 f840 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_D4_Pin ARDUINO_D2_Pin EXT_RST_Pin */
  GPIO_InitStruct.Pin = ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin;
90000e88:	23c8      	movs	r3, #200	; 0xc8
90000e8a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
90000e8c:	2301      	movs	r3, #1
90000e8e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000e90:	2300      	movs	r3, #0
90000e92:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000e94:	2300      	movs	r3, #0
90000e96:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
90000e98:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000e9c:	4619      	mov	r1, r3
90000e9e:	4874      	ldr	r0, [pc, #464]	; (90001070 <MX_GPIO_Init+0x900>)
90000ea0:	f003 f832 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_A4_Pin ARDUINO_A5_Pin ARDUINO_A1_Pin ARDUINO_A2_Pin
                           ARDUINO_A3_Pin */
  GPIO_InitStruct.Pin = ARDUINO_A4_Pin|ARDUINO_A5_Pin|ARDUINO_A1_Pin|ARDUINO_A2_Pin
90000ea4:	f44f 63f8 	mov.w	r3, #1984	; 0x7c0
90000ea8:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |ARDUINO_A3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
90000eaa:	2303      	movs	r3, #3
90000eac:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000eae:	2300      	movs	r3, #0
90000eb0:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
90000eb2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000eb6:	4619      	mov	r1, r3
90000eb8:	486e      	ldr	r0, [pc, #440]	; (90001074 <MX_GPIO_Init+0x904>)
90000eba:	f003 f825 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : FMC_SDCKE0_Pin */
  GPIO_InitStruct.Pin = FMC_SDCKE0_Pin;
90000ebe:	2308      	movs	r3, #8
90000ec0:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000ec2:	2302      	movs	r3, #2
90000ec4:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000ec6:	2300      	movs	r3, #0
90000ec8:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000eca:	2303      	movs	r3, #3
90000ecc:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
90000ece:	230c      	movs	r3, #12
90000ed0:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(FMC_SDCKE0_GPIO_Port, &GPIO_InitStruct);
90000ed2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000ed6:	4619      	mov	r1, r3
90000ed8:	4864      	ldr	r0, [pc, #400]	; (9000106c <MX_GPIO_Init+0x8fc>)
90000eda:	f003 f815 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_STP_Pin ULPI_DIR_Pin */
  GPIO_InitStruct.Pin = ULPI_STP_Pin|ULPI_DIR_Pin;
90000ede:	2305      	movs	r3, #5
90000ee0:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000ee2:	2302      	movs	r3, #2
90000ee4:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000ee6:	2300      	movs	r3, #0
90000ee8:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000eea:	2303      	movs	r3, #3
90000eec:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
90000eee:	230a      	movs	r3, #10
90000ef0:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000ef2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000ef6:	4619      	mov	r1, r3
90000ef8:	485c      	ldr	r0, [pc, #368]	; (9000106c <MX_GPIO_Init+0x8fc>)
90000efa:	f003 f805 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_MDC_Pin RMII_RXD0_Pin RMII_RXD1_Pin */
  GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
90000efe:	2332      	movs	r3, #50	; 0x32
90000f00:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000f02:	2302      	movs	r3, #2
90000f04:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000f06:	2300      	movs	r3, #0
90000f08:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000f0a:	2303      	movs	r3, #3
90000f0c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
90000f0e:	230b      	movs	r3, #11
90000f10:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000f12:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000f16:	4619      	mov	r1, r3
90000f18:	4854      	ldr	r0, [pc, #336]	; (9000106c <MX_GPIO_Init+0x8fc>)
90000f1a:	f002 fff5 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
90000f1e:	2304      	movs	r3, #4
90000f20:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000f22:	2302      	movs	r3, #2
90000f24:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000f26:	2300      	movs	r3, #0
90000f28:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000f2a:	2303      	movs	r3, #3
90000f2c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
90000f2e:	2309      	movs	r3, #9
90000f30:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
90000f32:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000f36:	4619      	mov	r1, r3
90000f38:	484f      	ldr	r0, [pc, #316]	; (90001078 <MX_GPIO_Init+0x908>)
90000f3a:	f002 ffe5 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : QSPI_D1_Pin QSPI_D3_Pin QSPI_D0_Pin */
  GPIO_InitStruct.Pin = QSPI_D1_Pin|QSPI_D3_Pin|QSPI_D0_Pin;
90000f3e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
90000f42:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000f44:	2302      	movs	r3, #2
90000f46:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000f48:	2300      	movs	r3, #0
90000f4a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000f4c:	2303      	movs	r3, #3
90000f4e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
90000f50:	2309      	movs	r3, #9
90000f52:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
90000f54:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000f58:	4619      	mov	r1, r3
90000f5a:	4848      	ldr	r0, [pc, #288]	; (9000107c <MX_GPIO_Init+0x90c>)
90000f5c:	f002 ffd4 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : RMII_RXER_Pin */
  GPIO_InitStruct.Pin = RMII_RXER_Pin;
90000f60:	2304      	movs	r3, #4
90000f62:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
90000f64:	2300      	movs	r3, #0
90000f66:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000f68:	2300      	movs	r3, #0
90000f6a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(RMII_RXER_GPIO_Port, &GPIO_InitStruct);
90000f6c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000f70:	4619      	mov	r1, r3
90000f72:	483f      	ldr	r0, [pc, #252]	; (90001070 <MX_GPIO_Init+0x900>)
90000f74:	f002 ffc8 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_REF_CLK_Pin RMII_MDIO_Pin RMII_CRS_DV_Pin */
  GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
90000f78:	2386      	movs	r3, #134	; 0x86
90000f7a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000f7c:	2302      	movs	r3, #2
90000f7e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000f80:	2300      	movs	r3, #0
90000f82:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000f84:	2303      	movs	r3, #3
90000f86:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
90000f88:	230b      	movs	r3, #11
90000f8a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90000f8c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000f90:	4619      	mov	r1, r3
90000f92:	4834      	ldr	r0, [pc, #208]	; (90001064 <MX_GPIO_Init+0x8f4>)
90000f94:	f002 ffb8 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_A0_Pin */
  GPIO_InitStruct.Pin = ARDUINO_A0_Pin;
90000f98:	2301      	movs	r3, #1
90000f9a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
90000f9c:	2303      	movs	r3, #3
90000f9e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000fa0:	2300      	movs	r3, #0
90000fa2:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(ARDUINO_A0_GPIO_Port, &GPIO_InitStruct);
90000fa4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000fa8:	4619      	mov	r1, r3
90000faa:	482e      	ldr	r0, [pc, #184]	; (90001064 <MX_GPIO_Init+0x8f4>)
90000fac:	f002 ffac 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : DCMI_HSYNC_Pin PA6 */
  GPIO_InitStruct.Pin = DCMI_HSYNC_Pin|GPIO_PIN_6;
90000fb0:	2350      	movs	r3, #80	; 0x50
90000fb2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000fb4:	2302      	movs	r3, #2
90000fb6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000fb8:	2300      	movs	r3, #0
90000fba:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90000fbc:	2300      	movs	r3, #0
90000fbe:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
90000fc0:	230d      	movs	r3, #13
90000fc2:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90000fc4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000fc8:	4619      	mov	r1, r3
90000fca:	4826      	ldr	r0, [pc, #152]	; (90001064 <MX_GPIO_Init+0x8f4>)
90000fcc:	f002 ff9c 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_SCL_Pin LCD_SDA_Pin */
  GPIO_InitStruct.Pin = LCD_SCL_Pin|LCD_SDA_Pin;
90000fd0:	f44f 73c0 	mov.w	r3, #384	; 0x180
90000fd4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
90000fd6:	2312      	movs	r3, #18
90000fd8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
90000fda:	2301      	movs	r3, #1
90000fdc:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000fde:	2303      	movs	r3, #3
90000fe0:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
90000fe2:	2304      	movs	r3, #4
90000fe4:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
90000fe6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90000fea:	4619      	mov	r1, r3
90000fec:	481b      	ldr	r0, [pc, #108]	; (9000105c <MX_GPIO_Init+0x8ec>)
90000fee:	f002 ff8b 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_CLK_Pin ULPI_D0_Pin */
  GPIO_InitStruct.Pin = ULPI_CLK_Pin|ULPI_D0_Pin;
90000ff2:	2328      	movs	r3, #40	; 0x28
90000ff4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000ff6:	2302      	movs	r3, #2
90000ff8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
90000ffa:	2300      	movs	r3, #0
90000ffc:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000ffe:	2303      	movs	r3, #3
90001000:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
90001002:	230a      	movs	r3, #10
90001004:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
90001006:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000100a:	4619      	mov	r1, r3
9000100c:	4815      	ldr	r0, [pc, #84]	; (90001064 <MX_GPIO_Init+0x8f4>)
9000100e:	f002 ff7b 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_PWM_D6_Pin */
  GPIO_InitStruct.Pin = ARDUINO_PWM_D6_Pin;
90001012:	2340      	movs	r3, #64	; 0x40
90001014:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90001016:	2302      	movs	r3, #2
90001018:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
9000101a:	2300      	movs	r3, #0
9000101c:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
9000101e:	2300      	movs	r3, #0
90001020:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
90001022:	2309      	movs	r3, #9
90001024:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_PWM_D6_GPIO_Port, &GPIO_InitStruct);
90001026:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000102a:	4619      	mov	r1, r3
9000102c:	480b      	ldr	r0, [pc, #44]	; (9000105c <MX_GPIO_Init+0x8ec>)
9000102e:	f002 ff6b 	bl	90003f08 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_MISO_D12_Pin ARDUINO_MOSI_PWM_D11_Pin */
  GPIO_InitStruct.Pin = ARDUINO_MISO_D12_Pin|ARDUINO_MOSI_PWM_D11_Pin;
90001032:	f44f 4340 	mov.w	r3, #49152	; 0xc000
90001036:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90001038:	2302      	movs	r3, #2
9000103a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
9000103c:	2300      	movs	r3, #0
9000103e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
90001040:	2300      	movs	r3, #0
90001042:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
90001044:	2305      	movs	r3, #5
90001046:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
90001048:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000104c:	4619      	mov	r1, r3
9000104e:	480a      	ldr	r0, [pc, #40]	; (90001078 <MX_GPIO_Init+0x908>)
90001050:	f002 ff5a 	bl	90003f08 <HAL_GPIO_Init>

}
90001054:	bf00      	nop
90001056:	3740      	adds	r7, #64	; 0x40
90001058:	46bd      	mov	sp, r7
9000105a:	bd80      	pop	{r7, pc}
9000105c:	40021c00 	.word	0x40021c00
90001060:	40022000 	.word	0x40022000
90001064:	40020000 	.word	0x40020000
90001068:	10120000 	.word	0x10120000
9000106c:	40020800 	.word	0x40020800
90001070:	40021800 	.word	0x40021800
90001074:	40021400 	.word	0x40021400
90001078:	40020400 	.word	0x40020400
9000107c:	40020c00 	.word	0x40020c00

90001080 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
90001080:	b480      	push	{r7}
90001082:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
90001084:	b672      	cpsid	i
}
90001086:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
90001088:	e7fe      	b.n	90001088 <Error_Handler+0x8>
	...

9000108c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
9000108c:	b480      	push	{r7}
9000108e:	b083      	sub	sp, #12
90001090:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
90001092:	4b0f      	ldr	r3, [pc, #60]	; (900010d0 <HAL_MspInit+0x44>)
90001094:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90001096:	4a0e      	ldr	r2, [pc, #56]	; (900010d0 <HAL_MspInit+0x44>)
90001098:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
9000109c:	6413      	str	r3, [r2, #64]	; 0x40
9000109e:	4b0c      	ldr	r3, [pc, #48]	; (900010d0 <HAL_MspInit+0x44>)
900010a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900010a2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
900010a6:	607b      	str	r3, [r7, #4]
900010a8:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
900010aa:	4b09      	ldr	r3, [pc, #36]	; (900010d0 <HAL_MspInit+0x44>)
900010ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
900010ae:	4a08      	ldr	r2, [pc, #32]	; (900010d0 <HAL_MspInit+0x44>)
900010b0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
900010b4:	6453      	str	r3, [r2, #68]	; 0x44
900010b6:	4b06      	ldr	r3, [pc, #24]	; (900010d0 <HAL_MspInit+0x44>)
900010b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
900010ba:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
900010be:	603b      	str	r3, [r7, #0]
900010c0:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
900010c2:	bf00      	nop
900010c4:	370c      	adds	r7, #12
900010c6:	46bd      	mov	sp, r7
900010c8:	f85d 7b04 	ldr.w	r7, [sp], #4
900010cc:	4770      	bx	lr
900010ce:	bf00      	nop
900010d0:	40023800 	.word	0x40023800

900010d4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
900010d4:	b480      	push	{r7}
900010d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
900010d8:	e7fe      	b.n	900010d8 <NMI_Handler+0x4>

900010da <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
900010da:	b480      	push	{r7}
900010dc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
900010de:	e7fe      	b.n	900010de <HardFault_Handler+0x4>

900010e0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
900010e0:	b480      	push	{r7}
900010e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
900010e4:	e7fe      	b.n	900010e4 <MemManage_Handler+0x4>

900010e6 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
900010e6:	b480      	push	{r7}
900010e8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
900010ea:	e7fe      	b.n	900010ea <BusFault_Handler+0x4>

900010ec <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
900010ec:	b480      	push	{r7}
900010ee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
900010f0:	e7fe      	b.n	900010f0 <UsageFault_Handler+0x4>

900010f2 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
900010f2:	b480      	push	{r7}
900010f4:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
900010f6:	bf00      	nop
900010f8:	46bd      	mov	sp, r7
900010fa:	f85d 7b04 	ldr.w	r7, [sp], #4
900010fe:	4770      	bx	lr

90001100 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
90001100:	b480      	push	{r7}
90001102:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
90001104:	bf00      	nop
90001106:	46bd      	mov	sp, r7
90001108:	f85d 7b04 	ldr.w	r7, [sp], #4
9000110c:	4770      	bx	lr

9000110e <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
9000110e:	b480      	push	{r7}
90001110:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
90001112:	bf00      	nop
90001114:	46bd      	mov	sp, r7
90001116:	f85d 7b04 	ldr.w	r7, [sp], #4
9000111a:	4770      	bx	lr

9000111c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
9000111c:	b580      	push	{r7, lr}
9000111e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
90001120:	f002 fb50 	bl	900037c4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
90001124:	bf00      	nop
90001126:	bd80      	pop	{r7, pc}

90001128 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
90001128:	b480      	push	{r7}
9000112a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
9000112c:	4b15      	ldr	r3, [pc, #84]	; (90001184 <SystemInit+0x5c>)
9000112e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90001132:	4a14      	ldr	r2, [pc, #80]	; (90001184 <SystemInit+0x5c>)
90001134:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
90001138:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
9000113c:	4b12      	ldr	r3, [pc, #72]	; (90001188 <SystemInit+0x60>)
9000113e:	681b      	ldr	r3, [r3, #0]
90001140:	4a11      	ldr	r2, [pc, #68]	; (90001188 <SystemInit+0x60>)
90001142:	f043 0301 	orr.w	r3, r3, #1
90001146:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
90001148:	4b0f      	ldr	r3, [pc, #60]	; (90001188 <SystemInit+0x60>)
9000114a:	2200      	movs	r2, #0
9000114c:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
9000114e:	4b0e      	ldr	r3, [pc, #56]	; (90001188 <SystemInit+0x60>)
90001150:	681a      	ldr	r2, [r3, #0]
90001152:	490d      	ldr	r1, [pc, #52]	; (90001188 <SystemInit+0x60>)
90001154:	4b0d      	ldr	r3, [pc, #52]	; (9000118c <SystemInit+0x64>)
90001156:	4013      	ands	r3, r2
90001158:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
9000115a:	4b0b      	ldr	r3, [pc, #44]	; (90001188 <SystemInit+0x60>)
9000115c:	4a0c      	ldr	r2, [pc, #48]	; (90001190 <SystemInit+0x68>)
9000115e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
90001160:	4b09      	ldr	r3, [pc, #36]	; (90001188 <SystemInit+0x60>)
90001162:	681b      	ldr	r3, [r3, #0]
90001164:	4a08      	ldr	r2, [pc, #32]	; (90001188 <SystemInit+0x60>)
90001166:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
9000116a:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
9000116c:	4b06      	ldr	r3, [pc, #24]	; (90001188 <SystemInit+0x60>)
9000116e:	2200      	movs	r2, #0
90001170:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = APPLICATION_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation to APPLICATION_ADDRESS in preprocessor defines */
90001172:	4b04      	ldr	r3, [pc, #16]	; (90001184 <SystemInit+0x5c>)
90001174:	f04f 4210 	mov.w	r2, #2415919104	; 0x90000000
90001178:	609a      	str	r2, [r3, #8]
#endif
}
9000117a:	bf00      	nop
9000117c:	46bd      	mov	sp, r7
9000117e:	f85d 7b04 	ldr.w	r7, [sp], #4
90001182:	4770      	bx	lr
90001184:	e000ed00 	.word	0xe000ed00
90001188:	40023800 	.word	0x40023800
9000118c:	fef6ffff 	.word	0xfef6ffff
90001190:	24003010 	.word	0x24003010

90001194 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
90001194:	f8df d034 	ldr.w	sp, [pc, #52]	; 900011cc <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
90001198:	480d      	ldr	r0, [pc, #52]	; (900011d0 <LoopFillZerobss+0x16>)
  ldr r1, =_edata
9000119a:	490e      	ldr	r1, [pc, #56]	; (900011d4 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
9000119c:	4a0e      	ldr	r2, [pc, #56]	; (900011d8 <LoopFillZerobss+0x1e>)
  movs r3, #0
9000119e:	2300      	movs	r3, #0
  b LoopCopyDataInit
900011a0:	e002      	b.n	900011a8 <LoopCopyDataInit>

900011a2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
900011a2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
900011a4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
900011a6:	3304      	adds	r3, #4

900011a8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
900011a8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
900011aa:	428c      	cmp	r4, r1
  bcc CopyDataInit
900011ac:	d3f9      	bcc.n	900011a2 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
900011ae:	4a0b      	ldr	r2, [pc, #44]	; (900011dc <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
900011b0:	4c0b      	ldr	r4, [pc, #44]	; (900011e0 <LoopFillZerobss+0x26>)
  movs r3, #0
900011b2:	2300      	movs	r3, #0
  b LoopFillZerobss
900011b4:	e001      	b.n	900011ba <LoopFillZerobss>

900011b6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
900011b6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
900011b8:	3204      	adds	r2, #4

900011ba <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
900011ba:	42a2      	cmp	r2, r4
  bcc FillZerobss
900011bc:	d3fb      	bcc.n	900011b6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
900011be:	f7ff ffb3 	bl	90001128 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
900011c2:	f005 fe71 	bl	90006ea8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
900011c6:	f7ff fa57 	bl	90000678 <main>
  bx  lr    
900011ca:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
900011cc:	20050000 	.word	0x20050000
  ldr r0, =_sdata
900011d0:	20000000 	.word	0x20000000
  ldr r1, =_edata
900011d4:	20000040 	.word	0x20000040
  ldr r2, =_sidata
900011d8:	90006f5c 	.word	0x90006f5c
  ldr r2, =_sbss
900011dc:	20000040 	.word	0x20000040
  ldr r4, =_ebss
900011e0:	20000390 	.word	0x20000390

900011e4 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
900011e4:	e7fe      	b.n	900011e4 <ADC_IRQHandler>
	...

900011e8 <wm8994_Init>:
  * @param Volume: Initial volume level (from 0 (Mute) to 100 (Max))
  * @param AudioFreq: Audio Frequency 
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_Init(uint16_t DeviceAddr, uint16_t OutputInputDevice, uint8_t Volume, uint32_t AudioFreq)
{
900011e8:	b580      	push	{r7, lr}
900011ea:	b088      	sub	sp, #32
900011ec:	af00      	add	r7, sp, #0
900011ee:	607b      	str	r3, [r7, #4]
900011f0:	4603      	mov	r3, r0
900011f2:	81fb      	strh	r3, [r7, #14]
900011f4:	460b      	mov	r3, r1
900011f6:	81bb      	strh	r3, [r7, #12]
900011f8:	4613      	mov	r3, r2
900011fa:	72fb      	strb	r3, [r7, #11]
  uint32_t counter = 0;
900011fc:	2300      	movs	r3, #0
900011fe:	61fb      	str	r3, [r7, #28]
  uint16_t output_device = OutputInputDevice & 0xFF;
90001200:	89bb      	ldrh	r3, [r7, #12]
90001202:	b2db      	uxtb	r3, r3
90001204:	833b      	strh	r3, [r7, #24]
  uint16_t input_device = OutputInputDevice & 0xFF00;
90001206:	89bb      	ldrh	r3, [r7, #12]
90001208:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
9000120c:	82fb      	strh	r3, [r7, #22]
  uint16_t power_mgnt_reg_1 = 0;
9000120e:	2300      	movs	r3, #0
90001210:	837b      	strh	r3, [r7, #26]
  
  /* Initialize the Control interface of the Audio Codec */
  AUDIO_IO_Init();
90001212:	f001 fc71 	bl	90002af8 <AUDIO_IO_Init>
  /* wm8994 Errata Work-Arounds */
  counter += CODEC_IO_Write(DeviceAddr, 0x102, 0x0003);
90001216:	89fb      	ldrh	r3, [r7, #14]
90001218:	b2db      	uxtb	r3, r3
9000121a:	2203      	movs	r2, #3
9000121c:	f44f 7181 	mov.w	r1, #258	; 0x102
90001220:	4618      	mov	r0, r3
90001222:	f001 fafb 	bl	9000281c <CODEC_IO_Write>
90001226:	4603      	mov	r3, r0
90001228:	461a      	mov	r2, r3
9000122a:	69fb      	ldr	r3, [r7, #28]
9000122c:	4413      	add	r3, r2
9000122e:	61fb      	str	r3, [r7, #28]
  counter += CODEC_IO_Write(DeviceAddr, 0x817, 0x0000);
90001230:	89fb      	ldrh	r3, [r7, #14]
90001232:	b2db      	uxtb	r3, r3
90001234:	2200      	movs	r2, #0
90001236:	f640 0117 	movw	r1, #2071	; 0x817
9000123a:	4618      	mov	r0, r3
9000123c:	f001 faee 	bl	9000281c <CODEC_IO_Write>
90001240:	4603      	mov	r3, r0
90001242:	461a      	mov	r2, r3
90001244:	69fb      	ldr	r3, [r7, #28]
90001246:	4413      	add	r3, r2
90001248:	61fb      	str	r3, [r7, #28]
  counter += CODEC_IO_Write(DeviceAddr, 0x102, 0x0000);
9000124a:	89fb      	ldrh	r3, [r7, #14]
9000124c:	b2db      	uxtb	r3, r3
9000124e:	2200      	movs	r2, #0
90001250:	f44f 7181 	mov.w	r1, #258	; 0x102
90001254:	4618      	mov	r0, r3
90001256:	f001 fae1 	bl	9000281c <CODEC_IO_Write>
9000125a:	4603      	mov	r3, r0
9000125c:	461a      	mov	r2, r3
9000125e:	69fb      	ldr	r3, [r7, #28]
90001260:	4413      	add	r3, r2
90001262:	61fb      	str	r3, [r7, #28]

  /* Enable VMID soft start (fast), Start-up Bias Current Enabled */
  counter += CODEC_IO_Write(DeviceAddr, 0x39, 0x006C);
90001264:	89fb      	ldrh	r3, [r7, #14]
90001266:	b2db      	uxtb	r3, r3
90001268:	226c      	movs	r2, #108	; 0x6c
9000126a:	2139      	movs	r1, #57	; 0x39
9000126c:	4618      	mov	r0, r3
9000126e:	f001 fad5 	bl	9000281c <CODEC_IO_Write>
90001272:	4603      	mov	r3, r0
90001274:	461a      	mov	r2, r3
90001276:	69fb      	ldr	r3, [r7, #28]
90001278:	4413      	add	r3, r2
9000127a:	61fb      	str	r3, [r7, #28]

    /* Enable bias generator, Enable VMID */
  if (input_device > 0)
9000127c:	8afb      	ldrh	r3, [r7, #22]
9000127e:	2b00      	cmp	r3, #0
90001280:	d00c      	beq.n	9000129c <wm8994_Init+0xb4>
  {
    counter += CODEC_IO_Write(DeviceAddr, 0x01, 0x0013);
90001282:	89fb      	ldrh	r3, [r7, #14]
90001284:	b2db      	uxtb	r3, r3
90001286:	2213      	movs	r2, #19
90001288:	2101      	movs	r1, #1
9000128a:	4618      	mov	r0, r3
9000128c:	f001 fac6 	bl	9000281c <CODEC_IO_Write>
90001290:	4603      	mov	r3, r0
90001292:	461a      	mov	r2, r3
90001294:	69fb      	ldr	r3, [r7, #28]
90001296:	4413      	add	r3, r2
90001298:	61fb      	str	r3, [r7, #28]
9000129a:	e00b      	b.n	900012b4 <wm8994_Init+0xcc>
  }
  else
  {
    counter += CODEC_IO_Write(DeviceAddr, 0x01, 0x0003);
9000129c:	89fb      	ldrh	r3, [r7, #14]
9000129e:	b2db      	uxtb	r3, r3
900012a0:	2203      	movs	r2, #3
900012a2:	2101      	movs	r1, #1
900012a4:	4618      	mov	r0, r3
900012a6:	f001 fab9 	bl	9000281c <CODEC_IO_Write>
900012aa:	4603      	mov	r3, r0
900012ac:	461a      	mov	r2, r3
900012ae:	69fb      	ldr	r3, [r7, #28]
900012b0:	4413      	add	r3, r2
900012b2:	61fb      	str	r3, [r7, #28]
  }

  /* Add Delay */
  AUDIO_IO_Delay(50);
900012b4:	2032      	movs	r0, #50	; 0x32
900012b6:	f001 fc87 	bl	90002bc8 <AUDIO_IO_Delay>

  /* Path Configurations for output */
  if (output_device > 0)
900012ba:	8b3b      	ldrh	r3, [r7, #24]
900012bc:	2b00      	cmp	r3, #0
900012be:	f000 815f 	beq.w	90001580 <wm8994_Init+0x398>
  {
    outputEnabled = 1;
900012c2:	4bae      	ldr	r3, [pc, #696]	; (9000157c <wm8994_Init+0x394>)
900012c4:	2201      	movs	r2, #1
900012c6:	601a      	str	r2, [r3, #0]

    switch (output_device)
900012c8:	8b3b      	ldrh	r3, [r7, #24]
900012ca:	2b03      	cmp	r3, #3
900012cc:	f000 808c 	beq.w	900013e8 <wm8994_Init+0x200>
900012d0:	2b03      	cmp	r3, #3
900012d2:	f300 8111 	bgt.w	900014f8 <wm8994_Init+0x310>
900012d6:	2b01      	cmp	r3, #1
900012d8:	d002      	beq.n	900012e0 <wm8994_Init+0xf8>
900012da:	2b02      	cmp	r3, #2
900012dc:	d042      	beq.n	90001364 <wm8994_Init+0x17c>
900012de:	e10b      	b.n	900014f8 <wm8994_Init+0x310>
    {
    case OUTPUT_DEVICE_SPEAKER:
      /* Enable DAC1 (Left), Enable DAC1 (Right),
      Disable DAC2 (Left), Disable DAC2 (Right)*/
      counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0C0C);
900012e0:	89fb      	ldrh	r3, [r7, #14]
900012e2:	b2db      	uxtb	r3, r3
900012e4:	f640 420c 	movw	r2, #3084	; 0xc0c
900012e8:	2105      	movs	r1, #5
900012ea:	4618      	mov	r0, r3
900012ec:	f001 fa96 	bl	9000281c <CODEC_IO_Write>
900012f0:	4603      	mov	r3, r0
900012f2:	461a      	mov	r2, r3
900012f4:	69fb      	ldr	r3, [r7, #28]
900012f6:	4413      	add	r3, r2
900012f8:	61fb      	str	r3, [r7, #28]

      /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0000);
900012fa:	89fb      	ldrh	r3, [r7, #14]
900012fc:	b2db      	uxtb	r3, r3
900012fe:	2200      	movs	r2, #0
90001300:	f240 6101 	movw	r1, #1537	; 0x601
90001304:	4618      	mov	r0, r3
90001306:	f001 fa89 	bl	9000281c <CODEC_IO_Write>
9000130a:	4603      	mov	r3, r0
9000130c:	461a      	mov	r2, r3
9000130e:	69fb      	ldr	r3, [r7, #28]
90001310:	4413      	add	r3, r2
90001312:	61fb      	str	r3, [r7, #28]

      /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0000);
90001314:	89fb      	ldrh	r3, [r7, #14]
90001316:	b2db      	uxtb	r3, r3
90001318:	2200      	movs	r2, #0
9000131a:	f240 6102 	movw	r1, #1538	; 0x602
9000131e:	4618      	mov	r0, r3
90001320:	f001 fa7c 	bl	9000281c <CODEC_IO_Write>
90001324:	4603      	mov	r3, r0
90001326:	461a      	mov	r2, r3
90001328:	69fb      	ldr	r3, [r7, #28]
9000132a:	4413      	add	r3, r2
9000132c:	61fb      	str	r3, [r7, #28]

      /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0002);
9000132e:	89fb      	ldrh	r3, [r7, #14]
90001330:	b2db      	uxtb	r3, r3
90001332:	2202      	movs	r2, #2
90001334:	f240 6104 	movw	r1, #1540	; 0x604
90001338:	4618      	mov	r0, r3
9000133a:	f001 fa6f 	bl	9000281c <CODEC_IO_Write>
9000133e:	4603      	mov	r3, r0
90001340:	461a      	mov	r2, r3
90001342:	69fb      	ldr	r3, [r7, #28]
90001344:	4413      	add	r3, r2
90001346:	61fb      	str	r3, [r7, #28]

      /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0002);
90001348:	89fb      	ldrh	r3, [r7, #14]
9000134a:	b2db      	uxtb	r3, r3
9000134c:	2202      	movs	r2, #2
9000134e:	f240 6105 	movw	r1, #1541	; 0x605
90001352:	4618      	mov	r0, r3
90001354:	f001 fa62 	bl	9000281c <CODEC_IO_Write>
90001358:	4603      	mov	r3, r0
9000135a:	461a      	mov	r2, r3
9000135c:	69fb      	ldr	r3, [r7, #28]
9000135e:	4413      	add	r3, r2
90001360:	61fb      	str	r3, [r7, #28]
      break;
90001362:	e110      	b.n	90001586 <wm8994_Init+0x39e>

    case OUTPUT_DEVICE_HEADPHONE:
      /* Disable DAC1 (Left), Disable DAC1 (Right),
      Enable DAC2 (Left), Enable DAC2 (Right)*/
      counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303);
90001364:	89fb      	ldrh	r3, [r7, #14]
90001366:	b2db      	uxtb	r3, r3
90001368:	f240 3203 	movw	r2, #771	; 0x303
9000136c:	2105      	movs	r1, #5
9000136e:	4618      	mov	r0, r3
90001370:	f001 fa54 	bl	9000281c <CODEC_IO_Write>
90001374:	4603      	mov	r3, r0
90001376:	461a      	mov	r2, r3
90001378:	69fb      	ldr	r3, [r7, #28]
9000137a:	4413      	add	r3, r2
9000137c:	61fb      	str	r3, [r7, #28]

      /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0001);
9000137e:	89fb      	ldrh	r3, [r7, #14]
90001380:	b2db      	uxtb	r3, r3
90001382:	2201      	movs	r2, #1
90001384:	f240 6101 	movw	r1, #1537	; 0x601
90001388:	4618      	mov	r0, r3
9000138a:	f001 fa47 	bl	9000281c <CODEC_IO_Write>
9000138e:	4603      	mov	r3, r0
90001390:	461a      	mov	r2, r3
90001392:	69fb      	ldr	r3, [r7, #28]
90001394:	4413      	add	r3, r2
90001396:	61fb      	str	r3, [r7, #28]

      /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0001);
90001398:	89fb      	ldrh	r3, [r7, #14]
9000139a:	b2db      	uxtb	r3, r3
9000139c:	2201      	movs	r2, #1
9000139e:	f240 6102 	movw	r1, #1538	; 0x602
900013a2:	4618      	mov	r0, r3
900013a4:	f001 fa3a 	bl	9000281c <CODEC_IO_Write>
900013a8:	4603      	mov	r3, r0
900013aa:	461a      	mov	r2, r3
900013ac:	69fb      	ldr	r3, [r7, #28]
900013ae:	4413      	add	r3, r2
900013b0:	61fb      	str	r3, [r7, #28]

      /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0000);
900013b2:	89fb      	ldrh	r3, [r7, #14]
900013b4:	b2db      	uxtb	r3, r3
900013b6:	2200      	movs	r2, #0
900013b8:	f240 6104 	movw	r1, #1540	; 0x604
900013bc:	4618      	mov	r0, r3
900013be:	f001 fa2d 	bl	9000281c <CODEC_IO_Write>
900013c2:	4603      	mov	r3, r0
900013c4:	461a      	mov	r2, r3
900013c6:	69fb      	ldr	r3, [r7, #28]
900013c8:	4413      	add	r3, r2
900013ca:	61fb      	str	r3, [r7, #28]

      /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0000);
900013cc:	89fb      	ldrh	r3, [r7, #14]
900013ce:	b2db      	uxtb	r3, r3
900013d0:	2200      	movs	r2, #0
900013d2:	f240 6105 	movw	r1, #1541	; 0x605
900013d6:	4618      	mov	r0, r3
900013d8:	f001 fa20 	bl	9000281c <CODEC_IO_Write>
900013dc:	4603      	mov	r3, r0
900013de:	461a      	mov	r2, r3
900013e0:	69fb      	ldr	r3, [r7, #28]
900013e2:	4413      	add	r3, r2
900013e4:	61fb      	str	r3, [r7, #28]
      break;
900013e6:	e0ce      	b.n	90001586 <wm8994_Init+0x39e>

    case OUTPUT_DEVICE_BOTH:
      if (input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
900013e8:	8afb      	ldrh	r3, [r7, #22]
900013ea:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
900013ee:	d141      	bne.n	90001474 <wm8994_Init+0x28c>
      {
        /* Enable DAC1 (Left), Enable DAC1 (Right),
        also Enable DAC2 (Left), Enable DAC2 (Right)*/
        counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303 | 0x0C0C);
900013f0:	89fb      	ldrh	r3, [r7, #14]
900013f2:	b2db      	uxtb	r3, r3
900013f4:	f640 720f 	movw	r2, #3855	; 0xf0f
900013f8:	2105      	movs	r1, #5
900013fa:	4618      	mov	r0, r3
900013fc:	f001 fa0e 	bl	9000281c <CODEC_IO_Write>
90001400:	4603      	mov	r3, r0
90001402:	461a      	mov	r2, r3
90001404:	69fb      	ldr	r3, [r7, #28]
90001406:	4413      	add	r3, r2
90001408:	61fb      	str	r3, [r7, #28]
        
        /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path
        Enable the AIF1 Timeslot 1 (Left) to DAC 1 (Left) mixer path */
        counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0003);
9000140a:	89fb      	ldrh	r3, [r7, #14]
9000140c:	b2db      	uxtb	r3, r3
9000140e:	2203      	movs	r2, #3
90001410:	f240 6101 	movw	r1, #1537	; 0x601
90001414:	4618      	mov	r0, r3
90001416:	f001 fa01 	bl	9000281c <CODEC_IO_Write>
9000141a:	4603      	mov	r3, r0
9000141c:	461a      	mov	r2, r3
9000141e:	69fb      	ldr	r3, [r7, #28]
90001420:	4413      	add	r3, r2
90001422:	61fb      	str	r3, [r7, #28]
        
        /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path
        Enable the AIF1 Timeslot 1 (Right) to DAC 1 (Right) mixer path */
        counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0003);
90001424:	89fb      	ldrh	r3, [r7, #14]
90001426:	b2db      	uxtb	r3, r3
90001428:	2203      	movs	r2, #3
9000142a:	f240 6102 	movw	r1, #1538	; 0x602
9000142e:	4618      	mov	r0, r3
90001430:	f001 f9f4 	bl	9000281c <CODEC_IO_Write>
90001434:	4603      	mov	r3, r0
90001436:	461a      	mov	r2, r3
90001438:	69fb      	ldr	r3, [r7, #28]
9000143a:	4413      	add	r3, r2
9000143c:	61fb      	str	r3, [r7, #28]
        
        /* Enable the AIF1 Timeslot 0 (Left) to DAC 2 (Left) mixer path
        Enable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path  */
        counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0003);
9000143e:	89fb      	ldrh	r3, [r7, #14]
90001440:	b2db      	uxtb	r3, r3
90001442:	2203      	movs	r2, #3
90001444:	f240 6104 	movw	r1, #1540	; 0x604
90001448:	4618      	mov	r0, r3
9000144a:	f001 f9e7 	bl	9000281c <CODEC_IO_Write>
9000144e:	4603      	mov	r3, r0
90001450:	461a      	mov	r2, r3
90001452:	69fb      	ldr	r3, [r7, #28]
90001454:	4413      	add	r3, r2
90001456:	61fb      	str	r3, [r7, #28]
        
        /* Enable the AIF1 Timeslot 0 (Right) to DAC 2 (Right) mixer path
        Enable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
        counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0003);
90001458:	89fb      	ldrh	r3, [r7, #14]
9000145a:	b2db      	uxtb	r3, r3
9000145c:	2203      	movs	r2, #3
9000145e:	f240 6105 	movw	r1, #1541	; 0x605
90001462:	4618      	mov	r0, r3
90001464:	f001 f9da 	bl	9000281c <CODEC_IO_Write>
90001468:	4603      	mov	r3, r0
9000146a:	461a      	mov	r2, r3
9000146c:	69fb      	ldr	r3, [r7, #28]
9000146e:	4413      	add	r3, r2
90001470:	61fb      	str	r3, [r7, #28]
        counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0002);
        
        /* Enable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
        counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0002);      
      }
      break;
90001472:	e088      	b.n	90001586 <wm8994_Init+0x39e>
        counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303 | 0x0C0C);
90001474:	89fb      	ldrh	r3, [r7, #14]
90001476:	b2db      	uxtb	r3, r3
90001478:	f640 720f 	movw	r2, #3855	; 0xf0f
9000147c:	2105      	movs	r1, #5
9000147e:	4618      	mov	r0, r3
90001480:	f001 f9cc 	bl	9000281c <CODEC_IO_Write>
90001484:	4603      	mov	r3, r0
90001486:	461a      	mov	r2, r3
90001488:	69fb      	ldr	r3, [r7, #28]
9000148a:	4413      	add	r3, r2
9000148c:	61fb      	str	r3, [r7, #28]
        counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0001);
9000148e:	89fb      	ldrh	r3, [r7, #14]
90001490:	b2db      	uxtb	r3, r3
90001492:	2201      	movs	r2, #1
90001494:	f240 6101 	movw	r1, #1537	; 0x601
90001498:	4618      	mov	r0, r3
9000149a:	f001 f9bf 	bl	9000281c <CODEC_IO_Write>
9000149e:	4603      	mov	r3, r0
900014a0:	461a      	mov	r2, r3
900014a2:	69fb      	ldr	r3, [r7, #28]
900014a4:	4413      	add	r3, r2
900014a6:	61fb      	str	r3, [r7, #28]
        counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0001);
900014a8:	89fb      	ldrh	r3, [r7, #14]
900014aa:	b2db      	uxtb	r3, r3
900014ac:	2201      	movs	r2, #1
900014ae:	f240 6102 	movw	r1, #1538	; 0x602
900014b2:	4618      	mov	r0, r3
900014b4:	f001 f9b2 	bl	9000281c <CODEC_IO_Write>
900014b8:	4603      	mov	r3, r0
900014ba:	461a      	mov	r2, r3
900014bc:	69fb      	ldr	r3, [r7, #28]
900014be:	4413      	add	r3, r2
900014c0:	61fb      	str	r3, [r7, #28]
        counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0002);
900014c2:	89fb      	ldrh	r3, [r7, #14]
900014c4:	b2db      	uxtb	r3, r3
900014c6:	2202      	movs	r2, #2
900014c8:	f240 6104 	movw	r1, #1540	; 0x604
900014cc:	4618      	mov	r0, r3
900014ce:	f001 f9a5 	bl	9000281c <CODEC_IO_Write>
900014d2:	4603      	mov	r3, r0
900014d4:	461a      	mov	r2, r3
900014d6:	69fb      	ldr	r3, [r7, #28]
900014d8:	4413      	add	r3, r2
900014da:	61fb      	str	r3, [r7, #28]
        counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0002);      
900014dc:	89fb      	ldrh	r3, [r7, #14]
900014de:	b2db      	uxtb	r3, r3
900014e0:	2202      	movs	r2, #2
900014e2:	f240 6105 	movw	r1, #1541	; 0x605
900014e6:	4618      	mov	r0, r3
900014e8:	f001 f998 	bl	9000281c <CODEC_IO_Write>
900014ec:	4603      	mov	r3, r0
900014ee:	461a      	mov	r2, r3
900014f0:	69fb      	ldr	r3, [r7, #28]
900014f2:	4413      	add	r3, r2
900014f4:	61fb      	str	r3, [r7, #28]
      break;
900014f6:	e046      	b.n	90001586 <wm8994_Init+0x39e>

    case OUTPUT_DEVICE_AUTO :
    default:
      /* Disable DAC1 (Left), Disable DAC1 (Right),
      Enable DAC2 (Left), Enable DAC2 (Right)*/
      counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303);
900014f8:	89fb      	ldrh	r3, [r7, #14]
900014fa:	b2db      	uxtb	r3, r3
900014fc:	f240 3203 	movw	r2, #771	; 0x303
90001500:	2105      	movs	r1, #5
90001502:	4618      	mov	r0, r3
90001504:	f001 f98a 	bl	9000281c <CODEC_IO_Write>
90001508:	4603      	mov	r3, r0
9000150a:	461a      	mov	r2, r3
9000150c:	69fb      	ldr	r3, [r7, #28]
9000150e:	4413      	add	r3, r2
90001510:	61fb      	str	r3, [r7, #28]

      /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0001);
90001512:	89fb      	ldrh	r3, [r7, #14]
90001514:	b2db      	uxtb	r3, r3
90001516:	2201      	movs	r2, #1
90001518:	f240 6101 	movw	r1, #1537	; 0x601
9000151c:	4618      	mov	r0, r3
9000151e:	f001 f97d 	bl	9000281c <CODEC_IO_Write>
90001522:	4603      	mov	r3, r0
90001524:	461a      	mov	r2, r3
90001526:	69fb      	ldr	r3, [r7, #28]
90001528:	4413      	add	r3, r2
9000152a:	61fb      	str	r3, [r7, #28]

      /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0001);
9000152c:	89fb      	ldrh	r3, [r7, #14]
9000152e:	b2db      	uxtb	r3, r3
90001530:	2201      	movs	r2, #1
90001532:	f240 6102 	movw	r1, #1538	; 0x602
90001536:	4618      	mov	r0, r3
90001538:	f001 f970 	bl	9000281c <CODEC_IO_Write>
9000153c:	4603      	mov	r3, r0
9000153e:	461a      	mov	r2, r3
90001540:	69fb      	ldr	r3, [r7, #28]
90001542:	4413      	add	r3, r2
90001544:	61fb      	str	r3, [r7, #28]

      /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0000);
90001546:	89fb      	ldrh	r3, [r7, #14]
90001548:	b2db      	uxtb	r3, r3
9000154a:	2200      	movs	r2, #0
9000154c:	f240 6104 	movw	r1, #1540	; 0x604
90001550:	4618      	mov	r0, r3
90001552:	f001 f963 	bl	9000281c <CODEC_IO_Write>
90001556:	4603      	mov	r3, r0
90001558:	461a      	mov	r2, r3
9000155a:	69fb      	ldr	r3, [r7, #28]
9000155c:	4413      	add	r3, r2
9000155e:	61fb      	str	r3, [r7, #28]

      /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0000);
90001560:	89fb      	ldrh	r3, [r7, #14]
90001562:	b2db      	uxtb	r3, r3
90001564:	2200      	movs	r2, #0
90001566:	f240 6105 	movw	r1, #1541	; 0x605
9000156a:	4618      	mov	r0, r3
9000156c:	f001 f956 	bl	9000281c <CODEC_IO_Write>
90001570:	4603      	mov	r3, r0
90001572:	461a      	mov	r2, r3
90001574:	69fb      	ldr	r3, [r7, #28]
90001576:	4413      	add	r3, r2
90001578:	61fb      	str	r3, [r7, #28]
      break;
9000157a:	e004      	b.n	90001586 <wm8994_Init+0x39e>
9000157c:	20000060 	.word	0x20000060
    }
  }
  else
  {
    outputEnabled = 0;
90001580:	4b99      	ldr	r3, [pc, #612]	; (900017e8 <wm8994_Init+0x600>)
90001582:	2200      	movs	r2, #0
90001584:	601a      	str	r2, [r3, #0]
  }

  /* Path Configurations for input */
  if (input_device > 0)
90001586:	8afb      	ldrh	r3, [r7, #22]
90001588:	2b00      	cmp	r3, #0
9000158a:	f000 81ab 	beq.w	900018e4 <wm8994_Init+0x6fc>
  {
    inputEnabled = 1;
9000158e:	4b97      	ldr	r3, [pc, #604]	; (900017ec <wm8994_Init+0x604>)
90001590:	2201      	movs	r2, #1
90001592:	601a      	str	r2, [r3, #0]
    switch (input_device)
90001594:	8afb      	ldrh	r3, [r7, #22]
90001596:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
9000159a:	f000 8129 	beq.w	900017f0 <wm8994_Init+0x608>
9000159e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
900015a2:	f300 819b 	bgt.w	900018dc <wm8994_Init+0x6f4>
900015a6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
900015aa:	d05a      	beq.n	90001662 <wm8994_Init+0x47a>
900015ac:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
900015b0:	f300 8194 	bgt.w	900018dc <wm8994_Init+0x6f4>
900015b4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900015b8:	f000 80c6 	beq.w	90001748 <wm8994_Init+0x560>
900015bc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
900015c0:	f040 818c 	bne.w	900018dc <wm8994_Init+0x6f4>
    {
    case INPUT_DEVICE_DIGITAL_MICROPHONE_2 :
      /* Enable AIF1ADC2 (Left), Enable AIF1ADC2 (Right)
       * Enable DMICDAT2 (Left), Enable DMICDAT2 (Right)
       * Enable Left ADC, Enable Right ADC */
      counter += CODEC_IO_Write(DeviceAddr, 0x04, 0x0C30);
900015c4:	89fb      	ldrh	r3, [r7, #14]
900015c6:	b2db      	uxtb	r3, r3
900015c8:	f44f 6243 	mov.w	r2, #3120	; 0xc30
900015cc:	2104      	movs	r1, #4
900015ce:	4618      	mov	r0, r3
900015d0:	f001 f924 	bl	9000281c <CODEC_IO_Write>
900015d4:	4603      	mov	r3, r0
900015d6:	461a      	mov	r2, r3
900015d8:	69fb      	ldr	r3, [r7, #28]
900015da:	4413      	add	r3, r2
900015dc:	61fb      	str	r3, [r7, #28]

      /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC2 Left/Right Timeslot 1 */
      counter += CODEC_IO_Write(DeviceAddr, 0x450, 0x00DB);
900015de:	89fb      	ldrh	r3, [r7, #14]
900015e0:	b2db      	uxtb	r3, r3
900015e2:	22db      	movs	r2, #219	; 0xdb
900015e4:	f44f 618a 	mov.w	r1, #1104	; 0x450
900015e8:	4618      	mov	r0, r3
900015ea:	f001 f917 	bl	9000281c <CODEC_IO_Write>
900015ee:	4603      	mov	r3, r0
900015f0:	461a      	mov	r2, r3
900015f2:	69fb      	ldr	r3, [r7, #28]
900015f4:	4413      	add	r3, r2
900015f6:	61fb      	str	r3, [r7, #28]

      /* Disable IN1L, IN1R, IN2L, IN2R, Enable Thermal sensor & shutdown */
      counter += CODEC_IO_Write(DeviceAddr, 0x02, 0x6000);
900015f8:	89fb      	ldrh	r3, [r7, #14]
900015fa:	b2db      	uxtb	r3, r3
900015fc:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
90001600:	2102      	movs	r1, #2
90001602:	4618      	mov	r0, r3
90001604:	f001 f90a 	bl	9000281c <CODEC_IO_Write>
90001608:	4603      	mov	r3, r0
9000160a:	461a      	mov	r2, r3
9000160c:	69fb      	ldr	r3, [r7, #28]
9000160e:	4413      	add	r3, r2
90001610:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Left) to AIF1 Timeslot 1 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x608, 0x0002);
90001612:	89fb      	ldrh	r3, [r7, #14]
90001614:	b2db      	uxtb	r3, r3
90001616:	2202      	movs	r2, #2
90001618:	f44f 61c1 	mov.w	r1, #1544	; 0x608
9000161c:	4618      	mov	r0, r3
9000161e:	f001 f8fd 	bl	9000281c <CODEC_IO_Write>
90001622:	4603      	mov	r3, r0
90001624:	461a      	mov	r2, r3
90001626:	69fb      	ldr	r3, [r7, #28]
90001628:	4413      	add	r3, r2
9000162a:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Right) to AIF1 Timeslot 1 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x609, 0x0002);
9000162c:	89fb      	ldrh	r3, [r7, #14]
9000162e:	b2db      	uxtb	r3, r3
90001630:	2202      	movs	r2, #2
90001632:	f240 6109 	movw	r1, #1545	; 0x609
90001636:	4618      	mov	r0, r3
90001638:	f001 f8f0 	bl	9000281c <CODEC_IO_Write>
9000163c:	4603      	mov	r3, r0
9000163e:	461a      	mov	r2, r3
90001640:	69fb      	ldr	r3, [r7, #28]
90001642:	4413      	add	r3, r2
90001644:	61fb      	str	r3, [r7, #28]

      /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC2 signal detect */
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000E);
90001646:	89fb      	ldrh	r3, [r7, #14]
90001648:	b2db      	uxtb	r3, r3
9000164a:	220e      	movs	r2, #14
9000164c:	f44f 61e0 	mov.w	r1, #1792	; 0x700
90001650:	4618      	mov	r0, r3
90001652:	f001 f8e3 	bl	9000281c <CODEC_IO_Write>
90001656:	4603      	mov	r3, r0
90001658:	461a      	mov	r2, r3
9000165a:	69fb      	ldr	r3, [r7, #28]
9000165c:	4413      	add	r3, r2
9000165e:	61fb      	str	r3, [r7, #28]
      break;
90001660:	e143      	b.n	900018ea <wm8994_Init+0x702>

    case INPUT_DEVICE_INPUT_LINE_1 :
      /* IN1LN_TO_IN1L, IN1LP_TO_VMID, IN1RN_TO_IN1R, IN1RP_TO_VMID */
      counter += CODEC_IO_Write(DeviceAddr, 0x28, 0x0011);
90001662:	89fb      	ldrh	r3, [r7, #14]
90001664:	b2db      	uxtb	r3, r3
90001666:	2211      	movs	r2, #17
90001668:	2128      	movs	r1, #40	; 0x28
9000166a:	4618      	mov	r0, r3
9000166c:	f001 f8d6 	bl	9000281c <CODEC_IO_Write>
90001670:	4603      	mov	r3, r0
90001672:	461a      	mov	r2, r3
90001674:	69fb      	ldr	r3, [r7, #28]
90001676:	4413      	add	r3, r2
90001678:	61fb      	str	r3, [r7, #28]

      /* Disable mute on IN1L_TO_MIXINL and +30dB on IN1L PGA output */
      counter += CODEC_IO_Write(DeviceAddr, 0x29, 0x0035);
9000167a:	89fb      	ldrh	r3, [r7, #14]
9000167c:	b2db      	uxtb	r3, r3
9000167e:	2235      	movs	r2, #53	; 0x35
90001680:	2129      	movs	r1, #41	; 0x29
90001682:	4618      	mov	r0, r3
90001684:	f001 f8ca 	bl	9000281c <CODEC_IO_Write>
90001688:	4603      	mov	r3, r0
9000168a:	461a      	mov	r2, r3
9000168c:	69fb      	ldr	r3, [r7, #28]
9000168e:	4413      	add	r3, r2
90001690:	61fb      	str	r3, [r7, #28]

      /* Disable mute on IN1R_TO_MIXINL, Gain = +30dB */
      counter += CODEC_IO_Write(DeviceAddr, 0x2A, 0x0035);
90001692:	89fb      	ldrh	r3, [r7, #14]
90001694:	b2db      	uxtb	r3, r3
90001696:	2235      	movs	r2, #53	; 0x35
90001698:	212a      	movs	r1, #42	; 0x2a
9000169a:	4618      	mov	r0, r3
9000169c:	f001 f8be 	bl	9000281c <CODEC_IO_Write>
900016a0:	4603      	mov	r3, r0
900016a2:	461a      	mov	r2, r3
900016a4:	69fb      	ldr	r3, [r7, #28]
900016a6:	4413      	add	r3, r2
900016a8:	61fb      	str	r3, [r7, #28]

      /* Enable AIF1ADC1 (Left), Enable AIF1ADC1 (Right)
       * Enable Left ADC, Enable Right ADC */
      counter += CODEC_IO_Write(DeviceAddr, 0x04, 0x0303);
900016aa:	89fb      	ldrh	r3, [r7, #14]
900016ac:	b2db      	uxtb	r3, r3
900016ae:	f240 3203 	movw	r2, #771	; 0x303
900016b2:	2104      	movs	r1, #4
900016b4:	4618      	mov	r0, r3
900016b6:	f001 f8b1 	bl	9000281c <CODEC_IO_Write>
900016ba:	4603      	mov	r3, r0
900016bc:	461a      	mov	r2, r3
900016be:	69fb      	ldr	r3, [r7, #28]
900016c0:	4413      	add	r3, r2
900016c2:	61fb      	str	r3, [r7, #28]

      /* Enable AIF1 DRC1 Signal Detect & DRC in AIF1ADC1 Left/Right Timeslot 0 */
      counter += CODEC_IO_Write(DeviceAddr, 0x440, 0x00DB);
900016c4:	89fb      	ldrh	r3, [r7, #14]
900016c6:	b2db      	uxtb	r3, r3
900016c8:	22db      	movs	r2, #219	; 0xdb
900016ca:	f44f 6188 	mov.w	r1, #1088	; 0x440
900016ce:	4618      	mov	r0, r3
900016d0:	f001 f8a4 	bl	9000281c <CODEC_IO_Write>
900016d4:	4603      	mov	r3, r0
900016d6:	461a      	mov	r2, r3
900016d8:	69fb      	ldr	r3, [r7, #28]
900016da:	4413      	add	r3, r2
900016dc:	61fb      	str	r3, [r7, #28]

      /* Enable IN1L and IN1R, Disable IN2L and IN2R, Enable Thermal sensor & shutdown */
      counter += CODEC_IO_Write(DeviceAddr, 0x02, 0x6350);
900016de:	89fb      	ldrh	r3, [r7, #14]
900016e0:	b2db      	uxtb	r3, r3
900016e2:	f246 3250 	movw	r2, #25424	; 0x6350
900016e6:	2102      	movs	r1, #2
900016e8:	4618      	mov	r0, r3
900016ea:	f001 f897 	bl	9000281c <CODEC_IO_Write>
900016ee:	4603      	mov	r3, r0
900016f0:	461a      	mov	r2, r3
900016f2:	69fb      	ldr	r3, [r7, #28]
900016f4:	4413      	add	r3, r2
900016f6:	61fb      	str	r3, [r7, #28]

      /* Enable the ADCL(Left) to AIF1 Timeslot 0 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x606, 0x0002);
900016f8:	89fb      	ldrh	r3, [r7, #14]
900016fa:	b2db      	uxtb	r3, r3
900016fc:	2202      	movs	r2, #2
900016fe:	f240 6106 	movw	r1, #1542	; 0x606
90001702:	4618      	mov	r0, r3
90001704:	f001 f88a 	bl	9000281c <CODEC_IO_Write>
90001708:	4603      	mov	r3, r0
9000170a:	461a      	mov	r2, r3
9000170c:	69fb      	ldr	r3, [r7, #28]
9000170e:	4413      	add	r3, r2
90001710:	61fb      	str	r3, [r7, #28]

      /* Enable the ADCR(Right) to AIF1 Timeslot 0 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x607, 0x0002);
90001712:	89fb      	ldrh	r3, [r7, #14]
90001714:	b2db      	uxtb	r3, r3
90001716:	2202      	movs	r2, #2
90001718:	f240 6107 	movw	r1, #1543	; 0x607
9000171c:	4618      	mov	r0, r3
9000171e:	f001 f87d 	bl	9000281c <CODEC_IO_Write>
90001722:	4603      	mov	r3, r0
90001724:	461a      	mov	r2, r3
90001726:	69fb      	ldr	r3, [r7, #28]
90001728:	4413      	add	r3, r2
9000172a:	61fb      	str	r3, [r7, #28]

      /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC1 signal detect */
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
9000172c:	89fb      	ldrh	r3, [r7, #14]
9000172e:	b2db      	uxtb	r3, r3
90001730:	220d      	movs	r2, #13
90001732:	f44f 61e0 	mov.w	r1, #1792	; 0x700
90001736:	4618      	mov	r0, r3
90001738:	f001 f870 	bl	9000281c <CODEC_IO_Write>
9000173c:	4603      	mov	r3, r0
9000173e:	461a      	mov	r2, r3
90001740:	69fb      	ldr	r3, [r7, #28]
90001742:	4413      	add	r3, r2
90001744:	61fb      	str	r3, [r7, #28]
      break;
90001746:	e0d0      	b.n	900018ea <wm8994_Init+0x702>

    case INPUT_DEVICE_DIGITAL_MICROPHONE_1 :
      /* Enable AIF1ADC1 (Left), Enable AIF1ADC1 (Right)
       * Enable DMICDAT1 (Left), Enable DMICDAT1 (Right)
       * Enable Left ADC, Enable Right ADC */
      counter += CODEC_IO_Write(DeviceAddr, 0x04, 0x030C);
90001748:	89fb      	ldrh	r3, [r7, #14]
9000174a:	b2db      	uxtb	r3, r3
9000174c:	f44f 7243 	mov.w	r2, #780	; 0x30c
90001750:	2104      	movs	r1, #4
90001752:	4618      	mov	r0, r3
90001754:	f001 f862 	bl	9000281c <CODEC_IO_Write>
90001758:	4603      	mov	r3, r0
9000175a:	461a      	mov	r2, r3
9000175c:	69fb      	ldr	r3, [r7, #28]
9000175e:	4413      	add	r3, r2
90001760:	61fb      	str	r3, [r7, #28]

      /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC1 Left/Right Timeslot 0 */
      counter += CODEC_IO_Write(DeviceAddr, 0x440, 0x00DB);
90001762:	89fb      	ldrh	r3, [r7, #14]
90001764:	b2db      	uxtb	r3, r3
90001766:	22db      	movs	r2, #219	; 0xdb
90001768:	f44f 6188 	mov.w	r1, #1088	; 0x440
9000176c:	4618      	mov	r0, r3
9000176e:	f001 f855 	bl	9000281c <CODEC_IO_Write>
90001772:	4603      	mov	r3, r0
90001774:	461a      	mov	r2, r3
90001776:	69fb      	ldr	r3, [r7, #28]
90001778:	4413      	add	r3, r2
9000177a:	61fb      	str	r3, [r7, #28]

      /* Disable IN1L, IN1R, IN2L, IN2R, Enable Thermal sensor & shutdown */
      counter += CODEC_IO_Write(DeviceAddr, 0x02, 0x6350);
9000177c:	89fb      	ldrh	r3, [r7, #14]
9000177e:	b2db      	uxtb	r3, r3
90001780:	f246 3250 	movw	r2, #25424	; 0x6350
90001784:	2102      	movs	r1, #2
90001786:	4618      	mov	r0, r3
90001788:	f001 f848 	bl	9000281c <CODEC_IO_Write>
9000178c:	4603      	mov	r3, r0
9000178e:	461a      	mov	r2, r3
90001790:	69fb      	ldr	r3, [r7, #28]
90001792:	4413      	add	r3, r2
90001794:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Left) to AIF1 Timeslot 0 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x606, 0x0002);
90001796:	89fb      	ldrh	r3, [r7, #14]
90001798:	b2db      	uxtb	r3, r3
9000179a:	2202      	movs	r2, #2
9000179c:	f240 6106 	movw	r1, #1542	; 0x606
900017a0:	4618      	mov	r0, r3
900017a2:	f001 f83b 	bl	9000281c <CODEC_IO_Write>
900017a6:	4603      	mov	r3, r0
900017a8:	461a      	mov	r2, r3
900017aa:	69fb      	ldr	r3, [r7, #28]
900017ac:	4413      	add	r3, r2
900017ae:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Right) to AIF1 Timeslot 0 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x607, 0x0002);
900017b0:	89fb      	ldrh	r3, [r7, #14]
900017b2:	b2db      	uxtb	r3, r3
900017b4:	2202      	movs	r2, #2
900017b6:	f240 6107 	movw	r1, #1543	; 0x607
900017ba:	4618      	mov	r0, r3
900017bc:	f001 f82e 	bl	9000281c <CODEC_IO_Write>
900017c0:	4603      	mov	r3, r0
900017c2:	461a      	mov	r2, r3
900017c4:	69fb      	ldr	r3, [r7, #28]
900017c6:	4413      	add	r3, r2
900017c8:	61fb      	str	r3, [r7, #28]

      /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC1 signal detect */
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
900017ca:	89fb      	ldrh	r3, [r7, #14]
900017cc:	b2db      	uxtb	r3, r3
900017ce:	220d      	movs	r2, #13
900017d0:	f44f 61e0 	mov.w	r1, #1792	; 0x700
900017d4:	4618      	mov	r0, r3
900017d6:	f001 f821 	bl	9000281c <CODEC_IO_Write>
900017da:	4603      	mov	r3, r0
900017dc:	461a      	mov	r2, r3
900017de:	69fb      	ldr	r3, [r7, #28]
900017e0:	4413      	add	r3, r2
900017e2:	61fb      	str	r3, [r7, #28]
      break; 
900017e4:	e081      	b.n	900018ea <wm8994_Init+0x702>
900017e6:	bf00      	nop
900017e8:	20000060 	.word	0x20000060
900017ec:	20000064 	.word	0x20000064
    case INPUT_DEVICE_DIGITAL_MIC1_MIC2 :
      /* Enable AIF1ADC1 (Left), Enable AIF1ADC1 (Right)
       * Enable DMICDAT1 (Left), Enable DMICDAT1 (Right)
       * Enable Left ADC, Enable Right ADC */
      counter += CODEC_IO_Write(DeviceAddr, 0x04, 0x0F3C);
900017f0:	89fb      	ldrh	r3, [r7, #14]
900017f2:	b2db      	uxtb	r3, r3
900017f4:	f640 723c 	movw	r2, #3900	; 0xf3c
900017f8:	2104      	movs	r1, #4
900017fa:	4618      	mov	r0, r3
900017fc:	f001 f80e 	bl	9000281c <CODEC_IO_Write>
90001800:	4603      	mov	r3, r0
90001802:	461a      	mov	r2, r3
90001804:	69fb      	ldr	r3, [r7, #28]
90001806:	4413      	add	r3, r2
90001808:	61fb      	str	r3, [r7, #28]

      /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC2 Left/Right Timeslot 1 */
      counter += CODEC_IO_Write(DeviceAddr, 0x450, 0x00DB);
9000180a:	89fb      	ldrh	r3, [r7, #14]
9000180c:	b2db      	uxtb	r3, r3
9000180e:	22db      	movs	r2, #219	; 0xdb
90001810:	f44f 618a 	mov.w	r1, #1104	; 0x450
90001814:	4618      	mov	r0, r3
90001816:	f001 f801 	bl	9000281c <CODEC_IO_Write>
9000181a:	4603      	mov	r3, r0
9000181c:	461a      	mov	r2, r3
9000181e:	69fb      	ldr	r3, [r7, #28]
90001820:	4413      	add	r3, r2
90001822:	61fb      	str	r3, [r7, #28]
      
      /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC1 Left/Right Timeslot 0 */
      counter += CODEC_IO_Write(DeviceAddr, 0x440, 0x00DB);
90001824:	89fb      	ldrh	r3, [r7, #14]
90001826:	b2db      	uxtb	r3, r3
90001828:	22db      	movs	r2, #219	; 0xdb
9000182a:	f44f 6188 	mov.w	r1, #1088	; 0x440
9000182e:	4618      	mov	r0, r3
90001830:	f000 fff4 	bl	9000281c <CODEC_IO_Write>
90001834:	4603      	mov	r3, r0
90001836:	461a      	mov	r2, r3
90001838:	69fb      	ldr	r3, [r7, #28]
9000183a:	4413      	add	r3, r2
9000183c:	61fb      	str	r3, [r7, #28]

      /* Disable IN1L, IN1R, Enable IN2L, IN2R, Thermal sensor & shutdown */
      counter += CODEC_IO_Write(DeviceAddr, 0x02, 0x63A0);
9000183e:	89fb      	ldrh	r3, [r7, #14]
90001840:	b2db      	uxtb	r3, r3
90001842:	f246 32a0 	movw	r2, #25504	; 0x63a0
90001846:	2102      	movs	r1, #2
90001848:	4618      	mov	r0, r3
9000184a:	f000 ffe7 	bl	9000281c <CODEC_IO_Write>
9000184e:	4603      	mov	r3, r0
90001850:	461a      	mov	r2, r3
90001852:	69fb      	ldr	r3, [r7, #28]
90001854:	4413      	add	r3, r2
90001856:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Left) to AIF1 Timeslot 0 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x606, 0x0002);
90001858:	89fb      	ldrh	r3, [r7, #14]
9000185a:	b2db      	uxtb	r3, r3
9000185c:	2202      	movs	r2, #2
9000185e:	f240 6106 	movw	r1, #1542	; 0x606
90001862:	4618      	mov	r0, r3
90001864:	f000 ffda 	bl	9000281c <CODEC_IO_Write>
90001868:	4603      	mov	r3, r0
9000186a:	461a      	mov	r2, r3
9000186c:	69fb      	ldr	r3, [r7, #28]
9000186e:	4413      	add	r3, r2
90001870:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Right) to AIF1 Timeslot 0 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x607, 0x0002);
90001872:	89fb      	ldrh	r3, [r7, #14]
90001874:	b2db      	uxtb	r3, r3
90001876:	2202      	movs	r2, #2
90001878:	f240 6107 	movw	r1, #1543	; 0x607
9000187c:	4618      	mov	r0, r3
9000187e:	f000 ffcd 	bl	9000281c <CODEC_IO_Write>
90001882:	4603      	mov	r3, r0
90001884:	461a      	mov	r2, r3
90001886:	69fb      	ldr	r3, [r7, #28]
90001888:	4413      	add	r3, r2
9000188a:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Left) to AIF1 Timeslot 1 (Left) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x608, 0x0002);
9000188c:	89fb      	ldrh	r3, [r7, #14]
9000188e:	b2db      	uxtb	r3, r3
90001890:	2202      	movs	r2, #2
90001892:	f44f 61c1 	mov.w	r1, #1544	; 0x608
90001896:	4618      	mov	r0, r3
90001898:	f000 ffc0 	bl	9000281c <CODEC_IO_Write>
9000189c:	4603      	mov	r3, r0
9000189e:	461a      	mov	r2, r3
900018a0:	69fb      	ldr	r3, [r7, #28]
900018a2:	4413      	add	r3, r2
900018a4:	61fb      	str	r3, [r7, #28]

      /* Enable the DMIC2(Right) to AIF1 Timeslot 1 (Right) mixer path */
      counter += CODEC_IO_Write(DeviceAddr, 0x609, 0x0002);
900018a6:	89fb      	ldrh	r3, [r7, #14]
900018a8:	b2db      	uxtb	r3, r3
900018aa:	2202      	movs	r2, #2
900018ac:	f240 6109 	movw	r1, #1545	; 0x609
900018b0:	4618      	mov	r0, r3
900018b2:	f000 ffb3 	bl	9000281c <CODEC_IO_Write>
900018b6:	4603      	mov	r3, r0
900018b8:	461a      	mov	r2, r3
900018ba:	69fb      	ldr	r3, [r7, #28]
900018bc:	4413      	add	r3, r2
900018be:	61fb      	str	r3, [r7, #28]
      
      /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC1 signal detect */
      counter += CODEC_IO_Write(DeviceAddr, 0x700, 0x000D);
900018c0:	89fb      	ldrh	r3, [r7, #14]
900018c2:	b2db      	uxtb	r3, r3
900018c4:	220d      	movs	r2, #13
900018c6:	f44f 61e0 	mov.w	r1, #1792	; 0x700
900018ca:	4618      	mov	r0, r3
900018cc:	f000 ffa6 	bl	9000281c <CODEC_IO_Write>
900018d0:	4603      	mov	r3, r0
900018d2:	461a      	mov	r2, r3
900018d4:	69fb      	ldr	r3, [r7, #28]
900018d6:	4413      	add	r3, r2
900018d8:	61fb      	str	r3, [r7, #28]
      break;    
900018da:	e006      	b.n	900018ea <wm8994_Init+0x702>
    case INPUT_DEVICE_INPUT_LINE_2 :
    default:
      /* Actually, no other input devices supported */
      counter++;
900018dc:	69fb      	ldr	r3, [r7, #28]
900018de:	3301      	adds	r3, #1
900018e0:	61fb      	str	r3, [r7, #28]
      break;
900018e2:	e002      	b.n	900018ea <wm8994_Init+0x702>
    }
  }
  else
  {
    inputEnabled = 0;
900018e4:	4ba4      	ldr	r3, [pc, #656]	; (90001b78 <wm8994_Init+0x990>)
900018e6:	2200      	movs	r2, #0
900018e8:	601a      	str	r2, [r3, #0]
  }
  
  /*  Clock Configurations */
  switch (AudioFreq)
900018ea:	687b      	ldr	r3, [r7, #4]
900018ec:	4aa3      	ldr	r2, [pc, #652]	; (90001b7c <wm8994_Init+0x994>)
900018ee:	4293      	cmp	r3, r2
900018f0:	d079      	beq.n	900019e6 <wm8994_Init+0x7fe>
900018f2:	687b      	ldr	r3, [r7, #4]
900018f4:	4aa1      	ldr	r2, [pc, #644]	; (90001b7c <wm8994_Init+0x994>)
900018f6:	4293      	cmp	r3, r2
900018f8:	f200 80ad 	bhi.w	90001a56 <wm8994_Init+0x86e>
900018fc:	687b      	ldr	r3, [r7, #4]
900018fe:	f64b 3280 	movw	r2, #48000	; 0xbb80
90001902:	4293      	cmp	r3, r2
90001904:	d061      	beq.n	900019ca <wm8994_Init+0x7e2>
90001906:	687b      	ldr	r3, [r7, #4]
90001908:	f64b 3280 	movw	r2, #48000	; 0xbb80
9000190c:	4293      	cmp	r3, r2
9000190e:	f200 80a2 	bhi.w	90001a56 <wm8994_Init+0x86e>
90001912:	687b      	ldr	r3, [r7, #4]
90001914:	f64a 4244 	movw	r2, #44100	; 0xac44
90001918:	4293      	cmp	r3, r2
9000191a:	f000 808e 	beq.w	90001a3a <wm8994_Init+0x852>
9000191e:	687b      	ldr	r3, [r7, #4]
90001920:	f64a 4244 	movw	r2, #44100	; 0xac44
90001924:	4293      	cmp	r3, r2
90001926:	f200 8096 	bhi.w	90001a56 <wm8994_Init+0x86e>
9000192a:	687b      	ldr	r3, [r7, #4]
9000192c:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
90001930:	d03d      	beq.n	900019ae <wm8994_Init+0x7c6>
90001932:	687b      	ldr	r3, [r7, #4]
90001934:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
90001938:	f200 808d 	bhi.w	90001a56 <wm8994_Init+0x86e>
9000193c:	687b      	ldr	r3, [r7, #4]
9000193e:	f245 6222 	movw	r2, #22050	; 0x5622
90001942:	4293      	cmp	r3, r2
90001944:	d06b      	beq.n	90001a1e <wm8994_Init+0x836>
90001946:	687b      	ldr	r3, [r7, #4]
90001948:	f245 6222 	movw	r2, #22050	; 0x5622
9000194c:	4293      	cmp	r3, r2
9000194e:	f200 8082 	bhi.w	90001a56 <wm8994_Init+0x86e>
90001952:	687b      	ldr	r3, [r7, #4]
90001954:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
90001958:	d01b      	beq.n	90001992 <wm8994_Init+0x7aa>
9000195a:	687b      	ldr	r3, [r7, #4]
9000195c:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
90001960:	d879      	bhi.n	90001a56 <wm8994_Init+0x86e>
90001962:	687b      	ldr	r3, [r7, #4]
90001964:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
90001968:	d005      	beq.n	90001976 <wm8994_Init+0x78e>
9000196a:	687b      	ldr	r3, [r7, #4]
9000196c:	f642 3211 	movw	r2, #11025	; 0x2b11
90001970:	4293      	cmp	r3, r2
90001972:	d046      	beq.n	90001a02 <wm8994_Init+0x81a>
90001974:	e06f      	b.n	90001a56 <wm8994_Init+0x86e>
  {
  case  AUDIO_FREQUENCY_8K:
    /* AIF1 Sample Rate = 8 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0003);
90001976:	89fb      	ldrh	r3, [r7, #14]
90001978:	b2db      	uxtb	r3, r3
9000197a:	2203      	movs	r2, #3
9000197c:	f44f 7104 	mov.w	r1, #528	; 0x210
90001980:	4618      	mov	r0, r3
90001982:	f000 ff4b 	bl	9000281c <CODEC_IO_Write>
90001986:	4603      	mov	r3, r0
90001988:	461a      	mov	r2, r3
9000198a:	69fb      	ldr	r3, [r7, #28]
9000198c:	4413      	add	r3, r2
9000198e:	61fb      	str	r3, [r7, #28]
    break;
90001990:	e06f      	b.n	90001a72 <wm8994_Init+0x88a>
    
  case  AUDIO_FREQUENCY_16K:
    /* AIF1 Sample Rate = 16 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0033);
90001992:	89fb      	ldrh	r3, [r7, #14]
90001994:	b2db      	uxtb	r3, r3
90001996:	2233      	movs	r2, #51	; 0x33
90001998:	f44f 7104 	mov.w	r1, #528	; 0x210
9000199c:	4618      	mov	r0, r3
9000199e:	f000 ff3d 	bl	9000281c <CODEC_IO_Write>
900019a2:	4603      	mov	r3, r0
900019a4:	461a      	mov	r2, r3
900019a6:	69fb      	ldr	r3, [r7, #28]
900019a8:	4413      	add	r3, r2
900019aa:	61fb      	str	r3, [r7, #28]
    break;
900019ac:	e061      	b.n	90001a72 <wm8994_Init+0x88a>

  case  AUDIO_FREQUENCY_32K:
    /* AIF1 Sample Rate = 32 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0063);
900019ae:	89fb      	ldrh	r3, [r7, #14]
900019b0:	b2db      	uxtb	r3, r3
900019b2:	2263      	movs	r2, #99	; 0x63
900019b4:	f44f 7104 	mov.w	r1, #528	; 0x210
900019b8:	4618      	mov	r0, r3
900019ba:	f000 ff2f 	bl	9000281c <CODEC_IO_Write>
900019be:	4603      	mov	r3, r0
900019c0:	461a      	mov	r2, r3
900019c2:	69fb      	ldr	r3, [r7, #28]
900019c4:	4413      	add	r3, r2
900019c6:	61fb      	str	r3, [r7, #28]
    break;
900019c8:	e053      	b.n	90001a72 <wm8994_Init+0x88a>
    
  case  AUDIO_FREQUENCY_48K:
    /* AIF1 Sample Rate = 48 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0083);
900019ca:	89fb      	ldrh	r3, [r7, #14]
900019cc:	b2db      	uxtb	r3, r3
900019ce:	2283      	movs	r2, #131	; 0x83
900019d0:	f44f 7104 	mov.w	r1, #528	; 0x210
900019d4:	4618      	mov	r0, r3
900019d6:	f000 ff21 	bl	9000281c <CODEC_IO_Write>
900019da:	4603      	mov	r3, r0
900019dc:	461a      	mov	r2, r3
900019de:	69fb      	ldr	r3, [r7, #28]
900019e0:	4413      	add	r3, r2
900019e2:	61fb      	str	r3, [r7, #28]
    break;
900019e4:	e045      	b.n	90001a72 <wm8994_Init+0x88a>
    
  case  AUDIO_FREQUENCY_96K:
    /* AIF1 Sample Rate = 96 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x00A3);
900019e6:	89fb      	ldrh	r3, [r7, #14]
900019e8:	b2db      	uxtb	r3, r3
900019ea:	22a3      	movs	r2, #163	; 0xa3
900019ec:	f44f 7104 	mov.w	r1, #528	; 0x210
900019f0:	4618      	mov	r0, r3
900019f2:	f000 ff13 	bl	9000281c <CODEC_IO_Write>
900019f6:	4603      	mov	r3, r0
900019f8:	461a      	mov	r2, r3
900019fa:	69fb      	ldr	r3, [r7, #28]
900019fc:	4413      	add	r3, r2
900019fe:	61fb      	str	r3, [r7, #28]
    break;
90001a00:	e037      	b.n	90001a72 <wm8994_Init+0x88a>
    
  case  AUDIO_FREQUENCY_11K:
    /* AIF1 Sample Rate = 11.025 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0013);
90001a02:	89fb      	ldrh	r3, [r7, #14]
90001a04:	b2db      	uxtb	r3, r3
90001a06:	2213      	movs	r2, #19
90001a08:	f44f 7104 	mov.w	r1, #528	; 0x210
90001a0c:	4618      	mov	r0, r3
90001a0e:	f000 ff05 	bl	9000281c <CODEC_IO_Write>
90001a12:	4603      	mov	r3, r0
90001a14:	461a      	mov	r2, r3
90001a16:	69fb      	ldr	r3, [r7, #28]
90001a18:	4413      	add	r3, r2
90001a1a:	61fb      	str	r3, [r7, #28]
    break;
90001a1c:	e029      	b.n	90001a72 <wm8994_Init+0x88a>
    
  case  AUDIO_FREQUENCY_22K:
    /* AIF1 Sample Rate = 22.050 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0043);
90001a1e:	89fb      	ldrh	r3, [r7, #14]
90001a20:	b2db      	uxtb	r3, r3
90001a22:	2243      	movs	r2, #67	; 0x43
90001a24:	f44f 7104 	mov.w	r1, #528	; 0x210
90001a28:	4618      	mov	r0, r3
90001a2a:	f000 fef7 	bl	9000281c <CODEC_IO_Write>
90001a2e:	4603      	mov	r3, r0
90001a30:	461a      	mov	r2, r3
90001a32:	69fb      	ldr	r3, [r7, #28]
90001a34:	4413      	add	r3, r2
90001a36:	61fb      	str	r3, [r7, #28]
    break;
90001a38:	e01b      	b.n	90001a72 <wm8994_Init+0x88a>
    
  case  AUDIO_FREQUENCY_44K:
    /* AIF1 Sample Rate = 44.1 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0073);
90001a3a:	89fb      	ldrh	r3, [r7, #14]
90001a3c:	b2db      	uxtb	r3, r3
90001a3e:	2273      	movs	r2, #115	; 0x73
90001a40:	f44f 7104 	mov.w	r1, #528	; 0x210
90001a44:	4618      	mov	r0, r3
90001a46:	f000 fee9 	bl	9000281c <CODEC_IO_Write>
90001a4a:	4603      	mov	r3, r0
90001a4c:	461a      	mov	r2, r3
90001a4e:	69fb      	ldr	r3, [r7, #28]
90001a50:	4413      	add	r3, r2
90001a52:	61fb      	str	r3, [r7, #28]
    break; 
90001a54:	e00d      	b.n	90001a72 <wm8994_Init+0x88a>
    
  default:
    /* AIF1 Sample Rate = 48 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0083);
90001a56:	89fb      	ldrh	r3, [r7, #14]
90001a58:	b2db      	uxtb	r3, r3
90001a5a:	2283      	movs	r2, #131	; 0x83
90001a5c:	f44f 7104 	mov.w	r1, #528	; 0x210
90001a60:	4618      	mov	r0, r3
90001a62:	f000 fedb 	bl	9000281c <CODEC_IO_Write>
90001a66:	4603      	mov	r3, r0
90001a68:	461a      	mov	r2, r3
90001a6a:	69fb      	ldr	r3, [r7, #28]
90001a6c:	4413      	add	r3, r2
90001a6e:	61fb      	str	r3, [r7, #28]
    break; 
90001a70:	bf00      	nop
  }

  if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
90001a72:	8afb      	ldrh	r3, [r7, #22]
90001a74:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
90001a78:	d10e      	bne.n	90001a98 <wm8994_Init+0x8b0>
  {
  /* AIF1 Word Length = 16-bits, AIF1 Format = DSP mode */
  counter += CODEC_IO_Write(DeviceAddr, 0x300, 0x4018);    
90001a7a:	89fb      	ldrh	r3, [r7, #14]
90001a7c:	b2db      	uxtb	r3, r3
90001a7e:	f244 0218 	movw	r2, #16408	; 0x4018
90001a82:	f44f 7140 	mov.w	r1, #768	; 0x300
90001a86:	4618      	mov	r0, r3
90001a88:	f000 fec8 	bl	9000281c <CODEC_IO_Write>
90001a8c:	4603      	mov	r3, r0
90001a8e:	461a      	mov	r2, r3
90001a90:	69fb      	ldr	r3, [r7, #28]
90001a92:	4413      	add	r3, r2
90001a94:	61fb      	str	r3, [r7, #28]
90001a96:	e00d      	b.n	90001ab4 <wm8994_Init+0x8cc>
  }
  else
  {
  /* AIF1 Word Length = 16-bits, AIF1 Format = I2S (Default Register Value) */
  counter += CODEC_IO_Write(DeviceAddr, 0x300, 0x4010);
90001a98:	89fb      	ldrh	r3, [r7, #14]
90001a9a:	b2db      	uxtb	r3, r3
90001a9c:	f244 0210 	movw	r2, #16400	; 0x4010
90001aa0:	f44f 7140 	mov.w	r1, #768	; 0x300
90001aa4:	4618      	mov	r0, r3
90001aa6:	f000 feb9 	bl	9000281c <CODEC_IO_Write>
90001aaa:	4603      	mov	r3, r0
90001aac:	461a      	mov	r2, r3
90001aae:	69fb      	ldr	r3, [r7, #28]
90001ab0:	4413      	add	r3, r2
90001ab2:	61fb      	str	r3, [r7, #28]
  }
  
  /* slave mode */
  counter += CODEC_IO_Write(DeviceAddr, 0x302, 0x0000);
90001ab4:	89fb      	ldrh	r3, [r7, #14]
90001ab6:	b2db      	uxtb	r3, r3
90001ab8:	2200      	movs	r2, #0
90001aba:	f240 3102 	movw	r1, #770	; 0x302
90001abe:	4618      	mov	r0, r3
90001ac0:	f000 feac 	bl	9000281c <CODEC_IO_Write>
90001ac4:	4603      	mov	r3, r0
90001ac6:	461a      	mov	r2, r3
90001ac8:	69fb      	ldr	r3, [r7, #28]
90001aca:	4413      	add	r3, r2
90001acc:	61fb      	str	r3, [r7, #28]
  
  /* Enable the DSP processing clock for AIF1, Enable the core clock */
  counter += CODEC_IO_Write(DeviceAddr, 0x208, 0x000A);
90001ace:	89fb      	ldrh	r3, [r7, #14]
90001ad0:	b2db      	uxtb	r3, r3
90001ad2:	220a      	movs	r2, #10
90001ad4:	f44f 7102 	mov.w	r1, #520	; 0x208
90001ad8:	4618      	mov	r0, r3
90001ada:	f000 fe9f 	bl	9000281c <CODEC_IO_Write>
90001ade:	4603      	mov	r3, r0
90001ae0:	461a      	mov	r2, r3
90001ae2:	69fb      	ldr	r3, [r7, #28]
90001ae4:	4413      	add	r3, r2
90001ae6:	61fb      	str	r3, [r7, #28]
  
  /* Enable AIF1 Clock, AIF1 Clock Source = MCLK1 pin */
  counter += CODEC_IO_Write(DeviceAddr, 0x200, 0x0001);
90001ae8:	89fb      	ldrh	r3, [r7, #14]
90001aea:	b2db      	uxtb	r3, r3
90001aec:	2201      	movs	r2, #1
90001aee:	f44f 7100 	mov.w	r1, #512	; 0x200
90001af2:	4618      	mov	r0, r3
90001af4:	f000 fe92 	bl	9000281c <CODEC_IO_Write>
90001af8:	4603      	mov	r3, r0
90001afa:	461a      	mov	r2, r3
90001afc:	69fb      	ldr	r3, [r7, #28]
90001afe:	4413      	add	r3, r2
90001b00:	61fb      	str	r3, [r7, #28]

  if (output_device > 0)  /* Audio output selected */
90001b02:	8b3b      	ldrh	r3, [r7, #24]
90001b04:	2b00      	cmp	r3, #0
90001b06:	f000 817b 	beq.w	90001e00 <wm8994_Init+0xc18>
  {
    if (output_device == OUTPUT_DEVICE_HEADPHONE)
90001b0a:	8b3b      	ldrh	r3, [r7, #24]
90001b0c:	2b02      	cmp	r3, #2
90001b0e:	d157      	bne.n	90001bc0 <wm8994_Init+0x9d8>
    {      
      /* Select DAC1 (Left) to Left Headphone Output PGA (HPOUT1LVOL) path */
      counter += CODEC_IO_Write(DeviceAddr, 0x2D, 0x0100);
90001b10:	89fb      	ldrh	r3, [r7, #14]
90001b12:	b2db      	uxtb	r3, r3
90001b14:	f44f 7280 	mov.w	r2, #256	; 0x100
90001b18:	212d      	movs	r1, #45	; 0x2d
90001b1a:	4618      	mov	r0, r3
90001b1c:	f000 fe7e 	bl	9000281c <CODEC_IO_Write>
90001b20:	4603      	mov	r3, r0
90001b22:	461a      	mov	r2, r3
90001b24:	69fb      	ldr	r3, [r7, #28]
90001b26:	4413      	add	r3, r2
90001b28:	61fb      	str	r3, [r7, #28]
      
      /* Select DAC1 (Right) to Right Headphone Output PGA (HPOUT1RVOL) path */
      counter += CODEC_IO_Write(DeviceAddr, 0x2E, 0x0100);    
90001b2a:	89fb      	ldrh	r3, [r7, #14]
90001b2c:	b2db      	uxtb	r3, r3
90001b2e:	f44f 7280 	mov.w	r2, #256	; 0x100
90001b32:	212e      	movs	r1, #46	; 0x2e
90001b34:	4618      	mov	r0, r3
90001b36:	f000 fe71 	bl	9000281c <CODEC_IO_Write>
90001b3a:	4603      	mov	r3, r0
90001b3c:	461a      	mov	r2, r3
90001b3e:	69fb      	ldr	r3, [r7, #28]
90001b40:	4413      	add	r3, r2
90001b42:	61fb      	str	r3, [r7, #28]
            
      /* Startup sequence for Headphone */
      if(ColdStartup)
90001b44:	4b0e      	ldr	r3, [pc, #56]	; (90001b80 <wm8994_Init+0x998>)
90001b46:	781b      	ldrb	r3, [r3, #0]
90001b48:	2b00      	cmp	r3, #0
90001b4a:	d01b      	beq.n	90001b84 <wm8994_Init+0x99c>
      {
        counter += CODEC_IO_Write(DeviceAddr,0x110,0x8100);
90001b4c:	89fb      	ldrh	r3, [r7, #14]
90001b4e:	b2db      	uxtb	r3, r3
90001b50:	f44f 4201 	mov.w	r2, #33024	; 0x8100
90001b54:	f44f 7188 	mov.w	r1, #272	; 0x110
90001b58:	4618      	mov	r0, r3
90001b5a:	f000 fe5f 	bl	9000281c <CODEC_IO_Write>
90001b5e:	4603      	mov	r3, r0
90001b60:	461a      	mov	r2, r3
90001b62:	69fb      	ldr	r3, [r7, #28]
90001b64:	4413      	add	r3, r2
90001b66:	61fb      	str	r3, [r7, #28]
        
        ColdStartup=0;
90001b68:	4b05      	ldr	r3, [pc, #20]	; (90001b80 <wm8994_Init+0x998>)
90001b6a:	2200      	movs	r2, #0
90001b6c:	701a      	strb	r2, [r3, #0]
        /* Add Delay */
        AUDIO_IO_Delay(300);
90001b6e:	f44f 7096 	mov.w	r0, #300	; 0x12c
90001b72:	f001 f829 	bl	90002bc8 <AUDIO_IO_Delay>
90001b76:	e016      	b.n	90001ba6 <wm8994_Init+0x9be>
90001b78:	20000064 	.word	0x20000064
90001b7c:	00017700 	.word	0x00017700
90001b80:	20000034 	.word	0x20000034
      }
      else /* Headphone Warm Start-Up */
      { 
        counter += CODEC_IO_Write(DeviceAddr,0x110,0x8108);
90001b84:	89fb      	ldrh	r3, [r7, #14]
90001b86:	b2db      	uxtb	r3, r3
90001b88:	f248 1208 	movw	r2, #33032	; 0x8108
90001b8c:	f44f 7188 	mov.w	r1, #272	; 0x110
90001b90:	4618      	mov	r0, r3
90001b92:	f000 fe43 	bl	9000281c <CODEC_IO_Write>
90001b96:	4603      	mov	r3, r0
90001b98:	461a      	mov	r2, r3
90001b9a:	69fb      	ldr	r3, [r7, #28]
90001b9c:	4413      	add	r3, r2
90001b9e:	61fb      	str	r3, [r7, #28]
        /* Add Delay */
        AUDIO_IO_Delay(50);
90001ba0:	2032      	movs	r0, #50	; 0x32
90001ba2:	f001 f811 	bl	90002bc8 <AUDIO_IO_Delay>
      }

      /* Soft un-Mute the AIF1 Timeslot 0 DAC1 path L&R */
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0000);
90001ba6:	89fb      	ldrh	r3, [r7, #14]
90001ba8:	b2db      	uxtb	r3, r3
90001baa:	2200      	movs	r2, #0
90001bac:	f44f 6184 	mov.w	r1, #1056	; 0x420
90001bb0:	4618      	mov	r0, r3
90001bb2:	f000 fe33 	bl	9000281c <CODEC_IO_Write>
90001bb6:	4603      	mov	r3, r0
90001bb8:	461a      	mov	r2, r3
90001bba:	69fb      	ldr	r3, [r7, #28]
90001bbc:	4413      	add	r3, r2
90001bbe:	61fb      	str	r3, [r7, #28]
    }
    /* Analog Output Configuration */

    /* Enable SPKRVOL PGA, Enable SPKMIXR, Enable SPKLVOL PGA, Enable SPKMIXL */
    counter += CODEC_IO_Write(DeviceAddr, 0x03, 0x0300);
90001bc0:	89fb      	ldrh	r3, [r7, #14]
90001bc2:	b2db      	uxtb	r3, r3
90001bc4:	f44f 7240 	mov.w	r2, #768	; 0x300
90001bc8:	2103      	movs	r1, #3
90001bca:	4618      	mov	r0, r3
90001bcc:	f000 fe26 	bl	9000281c <CODEC_IO_Write>
90001bd0:	4603      	mov	r3, r0
90001bd2:	461a      	mov	r2, r3
90001bd4:	69fb      	ldr	r3, [r7, #28]
90001bd6:	4413      	add	r3, r2
90001bd8:	61fb      	str	r3, [r7, #28]

    /* Left Speaker Mixer Volume = 0dB */
    counter += CODEC_IO_Write(DeviceAddr, 0x22, 0x0000);
90001bda:	89fb      	ldrh	r3, [r7, #14]
90001bdc:	b2db      	uxtb	r3, r3
90001bde:	2200      	movs	r2, #0
90001be0:	2122      	movs	r1, #34	; 0x22
90001be2:	4618      	mov	r0, r3
90001be4:	f000 fe1a 	bl	9000281c <CODEC_IO_Write>
90001be8:	4603      	mov	r3, r0
90001bea:	461a      	mov	r2, r3
90001bec:	69fb      	ldr	r3, [r7, #28]
90001bee:	4413      	add	r3, r2
90001bf0:	61fb      	str	r3, [r7, #28]

    /* Speaker output mode = Class D, Right Speaker Mixer Volume = 0dB ((0x23, 0x0100) = class AB)*/
    counter += CODEC_IO_Write(DeviceAddr, 0x23, 0x0000);
90001bf2:	89fb      	ldrh	r3, [r7, #14]
90001bf4:	b2db      	uxtb	r3, r3
90001bf6:	2200      	movs	r2, #0
90001bf8:	2123      	movs	r1, #35	; 0x23
90001bfa:	4618      	mov	r0, r3
90001bfc:	f000 fe0e 	bl	9000281c <CODEC_IO_Write>
90001c00:	4603      	mov	r3, r0
90001c02:	461a      	mov	r2, r3
90001c04:	69fb      	ldr	r3, [r7, #28]
90001c06:	4413      	add	r3, r2
90001c08:	61fb      	str	r3, [r7, #28]

    /* Unmute DAC2 (Left) to Left Speaker Mixer (SPKMIXL) path,
    Unmute DAC2 (Right) to Right Speaker Mixer (SPKMIXR) path */
    counter += CODEC_IO_Write(DeviceAddr, 0x36, 0x0300);
90001c0a:	89fb      	ldrh	r3, [r7, #14]
90001c0c:	b2db      	uxtb	r3, r3
90001c0e:	f44f 7240 	mov.w	r2, #768	; 0x300
90001c12:	2136      	movs	r1, #54	; 0x36
90001c14:	4618      	mov	r0, r3
90001c16:	f000 fe01 	bl	9000281c <CODEC_IO_Write>
90001c1a:	4603      	mov	r3, r0
90001c1c:	461a      	mov	r2, r3
90001c1e:	69fb      	ldr	r3, [r7, #28]
90001c20:	4413      	add	r3, r2
90001c22:	61fb      	str	r3, [r7, #28]

    /* Enable bias generator, Enable VMID, Enable SPKOUTL, Enable SPKOUTR */
    counter += CODEC_IO_Write(DeviceAddr, 0x01, 0x3003);
90001c24:	89fb      	ldrh	r3, [r7, #14]
90001c26:	b2db      	uxtb	r3, r3
90001c28:	f243 0203 	movw	r2, #12291	; 0x3003
90001c2c:	2101      	movs	r1, #1
90001c2e:	4618      	mov	r0, r3
90001c30:	f000 fdf4 	bl	9000281c <CODEC_IO_Write>
90001c34:	4603      	mov	r3, r0
90001c36:	461a      	mov	r2, r3
90001c38:	69fb      	ldr	r3, [r7, #28]
90001c3a:	4413      	add	r3, r2
90001c3c:	61fb      	str	r3, [r7, #28]

    /* Headphone/Speaker Enable */

    if (input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
90001c3e:	8afb      	ldrh	r3, [r7, #22]
90001c40:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
90001c44:	d10d      	bne.n	90001c62 <wm8994_Init+0xa7a>
    {
    /* Enable Class W, Class W Envelope Tracking = AIF1 Timeslots 0 and 1 */
    counter += CODEC_IO_Write(DeviceAddr, 0x51, 0x0205);
90001c46:	89fb      	ldrh	r3, [r7, #14]
90001c48:	b2db      	uxtb	r3, r3
90001c4a:	f240 2205 	movw	r2, #517	; 0x205
90001c4e:	2151      	movs	r1, #81	; 0x51
90001c50:	4618      	mov	r0, r3
90001c52:	f000 fde3 	bl	9000281c <CODEC_IO_Write>
90001c56:	4603      	mov	r3, r0
90001c58:	461a      	mov	r2, r3
90001c5a:	69fb      	ldr	r3, [r7, #28]
90001c5c:	4413      	add	r3, r2
90001c5e:	61fb      	str	r3, [r7, #28]
90001c60:	e00b      	b.n	90001c7a <wm8994_Init+0xa92>
    }
    else
    {
    /* Enable Class W, Class W Envelope Tracking = AIF1 Timeslot 0 */
    counter += CODEC_IO_Write(DeviceAddr, 0x51, 0x0005);      
90001c62:	89fb      	ldrh	r3, [r7, #14]
90001c64:	b2db      	uxtb	r3, r3
90001c66:	2205      	movs	r2, #5
90001c68:	2151      	movs	r1, #81	; 0x51
90001c6a:	4618      	mov	r0, r3
90001c6c:	f000 fdd6 	bl	9000281c <CODEC_IO_Write>
90001c70:	4603      	mov	r3, r0
90001c72:	461a      	mov	r2, r3
90001c74:	69fb      	ldr	r3, [r7, #28]
90001c76:	4413      	add	r3, r2
90001c78:	61fb      	str	r3, [r7, #28]
    }

    /* Enable bias generator, Enable VMID, Enable HPOUT1 (Left) and Enable HPOUT1 (Right) input stages */
    /* idem for Speaker */
    power_mgnt_reg_1 |= 0x0303 | 0x3003;
90001c7a:	8b7b      	ldrh	r3, [r7, #26]
90001c7c:	f443 534c 	orr.w	r3, r3, #13056	; 0x3300
90001c80:	f043 0303 	orr.w	r3, r3, #3
90001c84:	837b      	strh	r3, [r7, #26]
    counter += CODEC_IO_Write(DeviceAddr, 0x01, power_mgnt_reg_1);
90001c86:	89fb      	ldrh	r3, [r7, #14]
90001c88:	b2db      	uxtb	r3, r3
90001c8a:	8b7a      	ldrh	r2, [r7, #26]
90001c8c:	2101      	movs	r1, #1
90001c8e:	4618      	mov	r0, r3
90001c90:	f000 fdc4 	bl	9000281c <CODEC_IO_Write>
90001c94:	4603      	mov	r3, r0
90001c96:	461a      	mov	r2, r3
90001c98:	69fb      	ldr	r3, [r7, #28]
90001c9a:	4413      	add	r3, r2
90001c9c:	61fb      	str	r3, [r7, #28]

    /* Enable HPOUT1 (Left) and HPOUT1 (Right) intermediate stages */
    counter += CODEC_IO_Write(DeviceAddr, 0x60, 0x0022);
90001c9e:	89fb      	ldrh	r3, [r7, #14]
90001ca0:	b2db      	uxtb	r3, r3
90001ca2:	2222      	movs	r2, #34	; 0x22
90001ca4:	2160      	movs	r1, #96	; 0x60
90001ca6:	4618      	mov	r0, r3
90001ca8:	f000 fdb8 	bl	9000281c <CODEC_IO_Write>
90001cac:	4603      	mov	r3, r0
90001cae:	461a      	mov	r2, r3
90001cb0:	69fb      	ldr	r3, [r7, #28]
90001cb2:	4413      	add	r3, r2
90001cb4:	61fb      	str	r3, [r7, #28]

    /* Enable Charge Pump */
    counter += CODEC_IO_Write(DeviceAddr, 0x4C, 0x9F25);
90001cb6:	89fb      	ldrh	r3, [r7, #14]
90001cb8:	b2db      	uxtb	r3, r3
90001cba:	f649 7225 	movw	r2, #40741	; 0x9f25
90001cbe:	214c      	movs	r1, #76	; 0x4c
90001cc0:	4618      	mov	r0, r3
90001cc2:	f000 fdab 	bl	9000281c <CODEC_IO_Write>
90001cc6:	4603      	mov	r3, r0
90001cc8:	461a      	mov	r2, r3
90001cca:	69fb      	ldr	r3, [r7, #28]
90001ccc:	4413      	add	r3, r2
90001cce:	61fb      	str	r3, [r7, #28]

    /* Add Delay */
    AUDIO_IO_Delay(15);
90001cd0:	200f      	movs	r0, #15
90001cd2:	f000 ff79 	bl	90002bc8 <AUDIO_IO_Delay>

    /* Select DAC1 (Left) to Left Headphone Output PGA (HPOUT1LVOL) path */
    counter += CODEC_IO_Write(DeviceAddr, 0x2D, 0x0001);
90001cd6:	89fb      	ldrh	r3, [r7, #14]
90001cd8:	b2db      	uxtb	r3, r3
90001cda:	2201      	movs	r2, #1
90001cdc:	212d      	movs	r1, #45	; 0x2d
90001cde:	4618      	mov	r0, r3
90001ce0:	f000 fd9c 	bl	9000281c <CODEC_IO_Write>
90001ce4:	4603      	mov	r3, r0
90001ce6:	461a      	mov	r2, r3
90001ce8:	69fb      	ldr	r3, [r7, #28]
90001cea:	4413      	add	r3, r2
90001cec:	61fb      	str	r3, [r7, #28]

    /* Select DAC1 (Right) to Right Headphone Output PGA (HPOUT1RVOL) path */
    counter += CODEC_IO_Write(DeviceAddr, 0x2E, 0x0001);
90001cee:	89fb      	ldrh	r3, [r7, #14]
90001cf0:	b2db      	uxtb	r3, r3
90001cf2:	2201      	movs	r2, #1
90001cf4:	212e      	movs	r1, #46	; 0x2e
90001cf6:	4618      	mov	r0, r3
90001cf8:	f000 fd90 	bl	9000281c <CODEC_IO_Write>
90001cfc:	4603      	mov	r3, r0
90001cfe:	461a      	mov	r2, r3
90001d00:	69fb      	ldr	r3, [r7, #28]
90001d02:	4413      	add	r3, r2
90001d04:	61fb      	str	r3, [r7, #28]

    /* Enable Left Output Mixer (MIXOUTL), Enable Right Output Mixer (MIXOUTR) */
    /* idem for SPKOUTL and SPKOUTR */
    counter += CODEC_IO_Write(DeviceAddr, 0x03, 0x0030 | 0x0300);
90001d06:	89fb      	ldrh	r3, [r7, #14]
90001d08:	b2db      	uxtb	r3, r3
90001d0a:	f44f 724c 	mov.w	r2, #816	; 0x330
90001d0e:	2103      	movs	r1, #3
90001d10:	4618      	mov	r0, r3
90001d12:	f000 fd83 	bl	9000281c <CODEC_IO_Write>
90001d16:	4603      	mov	r3, r0
90001d18:	461a      	mov	r2, r3
90001d1a:	69fb      	ldr	r3, [r7, #28]
90001d1c:	4413      	add	r3, r2
90001d1e:	61fb      	str	r3, [r7, #28]

    /* Enable DC Servo and trigger start-up mode on left and right channels */
    counter += CODEC_IO_Write(DeviceAddr, 0x54, 0x0033);
90001d20:	89fb      	ldrh	r3, [r7, #14]
90001d22:	b2db      	uxtb	r3, r3
90001d24:	2233      	movs	r2, #51	; 0x33
90001d26:	2154      	movs	r1, #84	; 0x54
90001d28:	4618      	mov	r0, r3
90001d2a:	f000 fd77 	bl	9000281c <CODEC_IO_Write>
90001d2e:	4603      	mov	r3, r0
90001d30:	461a      	mov	r2, r3
90001d32:	69fb      	ldr	r3, [r7, #28]
90001d34:	4413      	add	r3, r2
90001d36:	61fb      	str	r3, [r7, #28]

    /* Add Delay */
    AUDIO_IO_Delay(257);
90001d38:	f240 1001 	movw	r0, #257	; 0x101
90001d3c:	f000 ff44 	bl	90002bc8 <AUDIO_IO_Delay>

    /* Enable HPOUT1 (Left) and HPOUT1 (Right) intermediate and output stages. Remove clamps */
    counter += CODEC_IO_Write(DeviceAddr, 0x60, 0x00EE);
90001d40:	89fb      	ldrh	r3, [r7, #14]
90001d42:	b2db      	uxtb	r3, r3
90001d44:	22ee      	movs	r2, #238	; 0xee
90001d46:	2160      	movs	r1, #96	; 0x60
90001d48:	4618      	mov	r0, r3
90001d4a:	f000 fd67 	bl	9000281c <CODEC_IO_Write>
90001d4e:	4603      	mov	r3, r0
90001d50:	461a      	mov	r2, r3
90001d52:	69fb      	ldr	r3, [r7, #28]
90001d54:	4413      	add	r3, r2
90001d56:	61fb      	str	r3, [r7, #28]

    /* Unmutes */

    /* Unmute DAC 1 (Left) */
    counter += CODEC_IO_Write(DeviceAddr, 0x610, 0x00C0);
90001d58:	89fb      	ldrh	r3, [r7, #14]
90001d5a:	b2db      	uxtb	r3, r3
90001d5c:	22c0      	movs	r2, #192	; 0xc0
90001d5e:	f44f 61c2 	mov.w	r1, #1552	; 0x610
90001d62:	4618      	mov	r0, r3
90001d64:	f000 fd5a 	bl	9000281c <CODEC_IO_Write>
90001d68:	4603      	mov	r3, r0
90001d6a:	461a      	mov	r2, r3
90001d6c:	69fb      	ldr	r3, [r7, #28]
90001d6e:	4413      	add	r3, r2
90001d70:	61fb      	str	r3, [r7, #28]

    /* Unmute DAC 1 (Right) */
    counter += CODEC_IO_Write(DeviceAddr, 0x611, 0x00C0);
90001d72:	89fb      	ldrh	r3, [r7, #14]
90001d74:	b2db      	uxtb	r3, r3
90001d76:	22c0      	movs	r2, #192	; 0xc0
90001d78:	f240 6111 	movw	r1, #1553	; 0x611
90001d7c:	4618      	mov	r0, r3
90001d7e:	f000 fd4d 	bl	9000281c <CODEC_IO_Write>
90001d82:	4603      	mov	r3, r0
90001d84:	461a      	mov	r2, r3
90001d86:	69fb      	ldr	r3, [r7, #28]
90001d88:	4413      	add	r3, r2
90001d8a:	61fb      	str	r3, [r7, #28]

    /* Unmute the AIF1 Timeslot 0 DAC path */
    counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0010);
90001d8c:	89fb      	ldrh	r3, [r7, #14]
90001d8e:	b2db      	uxtb	r3, r3
90001d90:	2210      	movs	r2, #16
90001d92:	f44f 6184 	mov.w	r1, #1056	; 0x420
90001d96:	4618      	mov	r0, r3
90001d98:	f000 fd40 	bl	9000281c <CODEC_IO_Write>
90001d9c:	4603      	mov	r3, r0
90001d9e:	461a      	mov	r2, r3
90001da0:	69fb      	ldr	r3, [r7, #28]
90001da2:	4413      	add	r3, r2
90001da4:	61fb      	str	r3, [r7, #28]

    /* Unmute DAC 2 (Left) */
    counter += CODEC_IO_Write(DeviceAddr, 0x612, 0x00C0);
90001da6:	89fb      	ldrh	r3, [r7, #14]
90001da8:	b2db      	uxtb	r3, r3
90001daa:	22c0      	movs	r2, #192	; 0xc0
90001dac:	f240 6112 	movw	r1, #1554	; 0x612
90001db0:	4618      	mov	r0, r3
90001db2:	f000 fd33 	bl	9000281c <CODEC_IO_Write>
90001db6:	4603      	mov	r3, r0
90001db8:	461a      	mov	r2, r3
90001dba:	69fb      	ldr	r3, [r7, #28]
90001dbc:	4413      	add	r3, r2
90001dbe:	61fb      	str	r3, [r7, #28]

    /* Unmute DAC 2 (Right) */
    counter += CODEC_IO_Write(DeviceAddr, 0x613, 0x00C0);
90001dc0:	89fb      	ldrh	r3, [r7, #14]
90001dc2:	b2db      	uxtb	r3, r3
90001dc4:	22c0      	movs	r2, #192	; 0xc0
90001dc6:	f240 6113 	movw	r1, #1555	; 0x613
90001dca:	4618      	mov	r0, r3
90001dcc:	f000 fd26 	bl	9000281c <CODEC_IO_Write>
90001dd0:	4603      	mov	r3, r0
90001dd2:	461a      	mov	r2, r3
90001dd4:	69fb      	ldr	r3, [r7, #28]
90001dd6:	4413      	add	r3, r2
90001dd8:	61fb      	str	r3, [r7, #28]

    /* Unmute the AIF1 Timeslot 1 DAC2 path */
    counter += CODEC_IO_Write(DeviceAddr, 0x422, 0x0010);
90001dda:	89fb      	ldrh	r3, [r7, #14]
90001ddc:	b2db      	uxtb	r3, r3
90001dde:	2210      	movs	r2, #16
90001de0:	f240 4122 	movw	r1, #1058	; 0x422
90001de4:	4618      	mov	r0, r3
90001de6:	f000 fd19 	bl	9000281c <CODEC_IO_Write>
90001dea:	4603      	mov	r3, r0
90001dec:	461a      	mov	r2, r3
90001dee:	69fb      	ldr	r3, [r7, #28]
90001df0:	4413      	add	r3, r2
90001df2:	61fb      	str	r3, [r7, #28]
    
    /* Volume Control */
    wm8994_SetVolume(DeviceAddr, Volume);
90001df4:	7afa      	ldrb	r2, [r7, #11]
90001df6:	89fb      	ldrh	r3, [r7, #14]
90001df8:	4611      	mov	r1, r2
90001dfa:	4618      	mov	r0, r3
90001dfc:	f000 f984 	bl	90002108 <wm8994_SetVolume>
  }

  if (input_device > 0) /* Audio input selected */
90001e00:	8afb      	ldrh	r3, [r7, #22]
90001e02:	2b00      	cmp	r3, #0
90001e04:	f000 80a6 	beq.w	90001f54 <wm8994_Init+0xd6c>
  {
    if ((input_device == INPUT_DEVICE_DIGITAL_MICROPHONE_1) || (input_device == INPUT_DEVICE_DIGITAL_MICROPHONE_2))
90001e08:	8afb      	ldrh	r3, [r7, #22]
90001e0a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90001e0e:	d003      	beq.n	90001e18 <wm8994_Init+0xc30>
90001e10:	8afb      	ldrh	r3, [r7, #22]
90001e12:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90001e16:	d12b      	bne.n	90001e70 <wm8994_Init+0xc88>
    {
      /* Enable Microphone bias 1 generator, Enable VMID */
      power_mgnt_reg_1 |= 0x0013;
90001e18:	8b7b      	ldrh	r3, [r7, #26]
90001e1a:	f043 0313 	orr.w	r3, r3, #19
90001e1e:	837b      	strh	r3, [r7, #26]
      counter += CODEC_IO_Write(DeviceAddr, 0x01, power_mgnt_reg_1);
90001e20:	89fb      	ldrh	r3, [r7, #14]
90001e22:	b2db      	uxtb	r3, r3
90001e24:	8b7a      	ldrh	r2, [r7, #26]
90001e26:	2101      	movs	r1, #1
90001e28:	4618      	mov	r0, r3
90001e2a:	f000 fcf7 	bl	9000281c <CODEC_IO_Write>
90001e2e:	4603      	mov	r3, r0
90001e30:	461a      	mov	r2, r3
90001e32:	69fb      	ldr	r3, [r7, #28]
90001e34:	4413      	add	r3, r2
90001e36:	61fb      	str	r3, [r7, #28]

      /* ADC oversample enable */
      counter += CODEC_IO_Write(DeviceAddr, 0x620, 0x0002);
90001e38:	89fb      	ldrh	r3, [r7, #14]
90001e3a:	b2db      	uxtb	r3, r3
90001e3c:	2202      	movs	r2, #2
90001e3e:	f44f 61c4 	mov.w	r1, #1568	; 0x620
90001e42:	4618      	mov	r0, r3
90001e44:	f000 fcea 	bl	9000281c <CODEC_IO_Write>
90001e48:	4603      	mov	r3, r0
90001e4a:	461a      	mov	r2, r3
90001e4c:	69fb      	ldr	r3, [r7, #28]
90001e4e:	4413      	add	r3, r2
90001e50:	61fb      	str	r3, [r7, #28]

      /* AIF ADC2 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      counter += CODEC_IO_Write(DeviceAddr, 0x411, 0x3800);
90001e52:	89fb      	ldrh	r3, [r7, #14]
90001e54:	b2db      	uxtb	r3, r3
90001e56:	f44f 5260 	mov.w	r2, #14336	; 0x3800
90001e5a:	f240 4111 	movw	r1, #1041	; 0x411
90001e5e:	4618      	mov	r0, r3
90001e60:	f000 fcdc 	bl	9000281c <CODEC_IO_Write>
90001e64:	4603      	mov	r3, r0
90001e66:	461a      	mov	r2, r3
90001e68:	69fb      	ldr	r3, [r7, #28]
90001e6a:	4413      	add	r3, r2
90001e6c:	61fb      	str	r3, [r7, #28]
90001e6e:	e06b      	b.n	90001f48 <wm8994_Init+0xd60>
    }
    else if(input_device == INPUT_DEVICE_DIGITAL_MIC1_MIC2)
90001e70:	8afb      	ldrh	r3, [r7, #22]
90001e72:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
90001e76:	d139      	bne.n	90001eec <wm8994_Init+0xd04>
    {
      /* Enable Microphone bias 1 generator, Enable VMID */
      power_mgnt_reg_1 |= 0x0013;
90001e78:	8b7b      	ldrh	r3, [r7, #26]
90001e7a:	f043 0313 	orr.w	r3, r3, #19
90001e7e:	837b      	strh	r3, [r7, #26]
      counter += CODEC_IO_Write(DeviceAddr, 0x01, power_mgnt_reg_1);
90001e80:	89fb      	ldrh	r3, [r7, #14]
90001e82:	b2db      	uxtb	r3, r3
90001e84:	8b7a      	ldrh	r2, [r7, #26]
90001e86:	2101      	movs	r1, #1
90001e88:	4618      	mov	r0, r3
90001e8a:	f000 fcc7 	bl	9000281c <CODEC_IO_Write>
90001e8e:	4603      	mov	r3, r0
90001e90:	461a      	mov	r2, r3
90001e92:	69fb      	ldr	r3, [r7, #28]
90001e94:	4413      	add	r3, r2
90001e96:	61fb      	str	r3, [r7, #28]

      /* ADC oversample enable */
      counter += CODEC_IO_Write(DeviceAddr, 0x620, 0x0002);
90001e98:	89fb      	ldrh	r3, [r7, #14]
90001e9a:	b2db      	uxtb	r3, r3
90001e9c:	2202      	movs	r2, #2
90001e9e:	f44f 61c4 	mov.w	r1, #1568	; 0x620
90001ea2:	4618      	mov	r0, r3
90001ea4:	f000 fcba 	bl	9000281c <CODEC_IO_Write>
90001ea8:	4603      	mov	r3, r0
90001eaa:	461a      	mov	r2, r3
90001eac:	69fb      	ldr	r3, [r7, #28]
90001eae:	4413      	add	r3, r2
90001eb0:	61fb      	str	r3, [r7, #28]
    
      /* AIF ADC1 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      counter += CODEC_IO_Write(DeviceAddr, 0x410, 0x1800);
90001eb2:	89fb      	ldrh	r3, [r7, #14]
90001eb4:	b2db      	uxtb	r3, r3
90001eb6:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
90001eba:	f44f 6182 	mov.w	r1, #1040	; 0x410
90001ebe:	4618      	mov	r0, r3
90001ec0:	f000 fcac 	bl	9000281c <CODEC_IO_Write>
90001ec4:	4603      	mov	r3, r0
90001ec6:	461a      	mov	r2, r3
90001ec8:	69fb      	ldr	r3, [r7, #28]
90001eca:	4413      	add	r3, r2
90001ecc:	61fb      	str	r3, [r7, #28]
      
      /* AIF ADC2 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      counter += CODEC_IO_Write(DeviceAddr, 0x411, 0x1800);      
90001ece:	89fb      	ldrh	r3, [r7, #14]
90001ed0:	b2db      	uxtb	r3, r3
90001ed2:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
90001ed6:	f240 4111 	movw	r1, #1041	; 0x411
90001eda:	4618      	mov	r0, r3
90001edc:	f000 fc9e 	bl	9000281c <CODEC_IO_Write>
90001ee0:	4603      	mov	r3, r0
90001ee2:	461a      	mov	r2, r3
90001ee4:	69fb      	ldr	r3, [r7, #28]
90001ee6:	4413      	add	r3, r2
90001ee8:	61fb      	str	r3, [r7, #28]
90001eea:	e02d      	b.n	90001f48 <wm8994_Init+0xd60>
    }    
    else if ((input_device == INPUT_DEVICE_INPUT_LINE_1) || (input_device == INPUT_DEVICE_INPUT_LINE_2))
90001eec:	8afb      	ldrh	r3, [r7, #22]
90001eee:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
90001ef2:	d003      	beq.n	90001efc <wm8994_Init+0xd14>
90001ef4:	8afb      	ldrh	r3, [r7, #22]
90001ef6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
90001efa:	d125      	bne.n	90001f48 <wm8994_Init+0xd60>
    {

      /* Disable mute on IN1L, IN1L Volume = +0dB */
      counter += CODEC_IO_Write(DeviceAddr, 0x18, 0x000B);
90001efc:	89fb      	ldrh	r3, [r7, #14]
90001efe:	b2db      	uxtb	r3, r3
90001f00:	220b      	movs	r2, #11
90001f02:	2118      	movs	r1, #24
90001f04:	4618      	mov	r0, r3
90001f06:	f000 fc89 	bl	9000281c <CODEC_IO_Write>
90001f0a:	4603      	mov	r3, r0
90001f0c:	461a      	mov	r2, r3
90001f0e:	69fb      	ldr	r3, [r7, #28]
90001f10:	4413      	add	r3, r2
90001f12:	61fb      	str	r3, [r7, #28]

      /* Disable mute on IN1R, IN1R Volume = +0dB */
      counter += CODEC_IO_Write(DeviceAddr, 0x1A, 0x000B);
90001f14:	89fb      	ldrh	r3, [r7, #14]
90001f16:	b2db      	uxtb	r3, r3
90001f18:	220b      	movs	r2, #11
90001f1a:	211a      	movs	r1, #26
90001f1c:	4618      	mov	r0, r3
90001f1e:	f000 fc7d 	bl	9000281c <CODEC_IO_Write>
90001f22:	4603      	mov	r3, r0
90001f24:	461a      	mov	r2, r3
90001f26:	69fb      	ldr	r3, [r7, #28]
90001f28:	4413      	add	r3, r2
90001f2a:	61fb      	str	r3, [r7, #28]

      /* AIF ADC1 HPF enable, HPF cut = hifi mode fc=4Hz at fs=48kHz */
      counter += CODEC_IO_Write(DeviceAddr, 0x410, 0x1800);
90001f2c:	89fb      	ldrh	r3, [r7, #14]
90001f2e:	b2db      	uxtb	r3, r3
90001f30:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
90001f34:	f44f 6182 	mov.w	r1, #1040	; 0x410
90001f38:	4618      	mov	r0, r3
90001f3a:	f000 fc6f 	bl	9000281c <CODEC_IO_Write>
90001f3e:	4603      	mov	r3, r0
90001f40:	461a      	mov	r2, r3
90001f42:	69fb      	ldr	r3, [r7, #28]
90001f44:	4413      	add	r3, r2
90001f46:	61fb      	str	r3, [r7, #28]
    }
    /* Volume Control */
    wm8994_SetVolume(DeviceAddr, Volume);
90001f48:	7afa      	ldrb	r2, [r7, #11]
90001f4a:	89fb      	ldrh	r3, [r7, #14]
90001f4c:	4611      	mov	r1, r2
90001f4e:	4618      	mov	r0, r3
90001f50:	f000 f8da 	bl	90002108 <wm8994_SetVolume>
  }
  /* Return communication control value */
  return counter;  
90001f54:	69fb      	ldr	r3, [r7, #28]
}
90001f56:	4618      	mov	r0, r3
90001f58:	3720      	adds	r7, #32
90001f5a:	46bd      	mov	sp, r7
90001f5c:	bd80      	pop	{r7, pc}
90001f5e:	bf00      	nop

90001f60 <wm8994_DeInit>:
  * @brief  Deinitializes the audio codec.
  * @param  None
  * @retval  None
  */
void wm8994_DeInit(void)
{
90001f60:	b580      	push	{r7, lr}
90001f62:	af00      	add	r7, sp, #0
  /* Deinitialize Audio Codec interface */
  AUDIO_IO_DeInit();
90001f64:	f000 fdd2 	bl	90002b0c <AUDIO_IO_DeInit>
}
90001f68:	bf00      	nop
90001f6a:	bd80      	pop	{r7, pc}

90001f6c <wm8994_ReadID>:
  * @brief  Get the WM8994 ID.
  * @param DeviceAddr: Device address on communication Bus.
  * @retval The WM8994 ID 
  */
uint32_t wm8994_ReadID(uint16_t DeviceAddr)
{
90001f6c:	b580      	push	{r7, lr}
90001f6e:	b082      	sub	sp, #8
90001f70:	af00      	add	r7, sp, #0
90001f72:	4603      	mov	r3, r0
90001f74:	80fb      	strh	r3, [r7, #6]
  /* Initialize the Control interface of the Audio Codec */
  AUDIO_IO_Init();
90001f76:	f000 fdbf 	bl	90002af8 <AUDIO_IO_Init>

  return ((uint32_t)AUDIO_IO_Read(DeviceAddr, WM8994_CHIPID_ADDR));
90001f7a:	88fb      	ldrh	r3, [r7, #6]
90001f7c:	b2db      	uxtb	r3, r3
90001f7e:	2100      	movs	r1, #0
90001f80:	4618      	mov	r0, r3
90001f82:	f000 fdf5 	bl	90002b70 <AUDIO_IO_Read>
90001f86:	4603      	mov	r3, r0
}
90001f88:	4618      	mov	r0, r3
90001f8a:	3708      	adds	r7, #8
90001f8c:	46bd      	mov	sp, r7
90001f8e:	bd80      	pop	{r7, pc}

90001f90 <wm8994_Play>:
  * @note For this codec no Play options are required.
  * @param DeviceAddr: Device address on communication Bus.   
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_Play(uint16_t DeviceAddr, uint16_t* pBuffer, uint16_t Size)
{
90001f90:	b580      	push	{r7, lr}
90001f92:	b084      	sub	sp, #16
90001f94:	af00      	add	r7, sp, #0
90001f96:	4603      	mov	r3, r0
90001f98:	6039      	str	r1, [r7, #0]
90001f9a:	80fb      	strh	r3, [r7, #6]
90001f9c:	4613      	mov	r3, r2
90001f9e:	80bb      	strh	r3, [r7, #4]
  uint32_t counter = 0;
90001fa0:	2300      	movs	r3, #0
90001fa2:	60fb      	str	r3, [r7, #12]
 
  /* Resumes the audio file playing */  
  /* Unmute the output first */
  counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
90001fa4:	88fb      	ldrh	r3, [r7, #6]
90001fa6:	2100      	movs	r1, #0
90001fa8:	4618      	mov	r0, r3
90001faa:	f000 f9d1 	bl	90002350 <wm8994_SetMute>
90001fae:	4602      	mov	r2, r0
90001fb0:	68fb      	ldr	r3, [r7, #12]
90001fb2:	4413      	add	r3, r2
90001fb4:	60fb      	str	r3, [r7, #12]
  
  return counter;
90001fb6:	68fb      	ldr	r3, [r7, #12]
}
90001fb8:	4618      	mov	r0, r3
90001fba:	3710      	adds	r7, #16
90001fbc:	46bd      	mov	sp, r7
90001fbe:	bd80      	pop	{r7, pc}

90001fc0 <wm8994_Pause>:
  * @brief Pauses playing on the audio codec.
  * @param DeviceAddr: Device address on communication Bus. 
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_Pause(uint16_t DeviceAddr)
{  
90001fc0:	b580      	push	{r7, lr}
90001fc2:	b084      	sub	sp, #16
90001fc4:	af00      	add	r7, sp, #0
90001fc6:	4603      	mov	r3, r0
90001fc8:	80fb      	strh	r3, [r7, #6]
  uint32_t counter = 0;
90001fca:	2300      	movs	r3, #0
90001fcc:	60fb      	str	r3, [r7, #12]
 
  /* Pause the audio file playing */
  /* Mute the output first */
  counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_ON);
90001fce:	88fb      	ldrh	r3, [r7, #6]
90001fd0:	2101      	movs	r1, #1
90001fd2:	4618      	mov	r0, r3
90001fd4:	f000 f9bc 	bl	90002350 <wm8994_SetMute>
90001fd8:	4602      	mov	r2, r0
90001fda:	68fb      	ldr	r3, [r7, #12]
90001fdc:	4413      	add	r3, r2
90001fde:	60fb      	str	r3, [r7, #12]
  
  /* Put the Codec in Power save mode */
  counter += CODEC_IO_Write(DeviceAddr, 0x02, 0x01);
90001fe0:	88fb      	ldrh	r3, [r7, #6]
90001fe2:	b2db      	uxtb	r3, r3
90001fe4:	2201      	movs	r2, #1
90001fe6:	2102      	movs	r1, #2
90001fe8:	4618      	mov	r0, r3
90001fea:	f000 fc17 	bl	9000281c <CODEC_IO_Write>
90001fee:	4603      	mov	r3, r0
90001ff0:	461a      	mov	r2, r3
90001ff2:	68fb      	ldr	r3, [r7, #12]
90001ff4:	4413      	add	r3, r2
90001ff6:	60fb      	str	r3, [r7, #12]
 
  return counter;
90001ff8:	68fb      	ldr	r3, [r7, #12]
}
90001ffa:	4618      	mov	r0, r3
90001ffc:	3710      	adds	r7, #16
90001ffe:	46bd      	mov	sp, r7
90002000:	bd80      	pop	{r7, pc}

90002002 <wm8994_Resume>:
  * @brief Resumes playing on the audio codec.
  * @param DeviceAddr: Device address on communication Bus. 
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_Resume(uint16_t DeviceAddr)
{
90002002:	b580      	push	{r7, lr}
90002004:	b084      	sub	sp, #16
90002006:	af00      	add	r7, sp, #0
90002008:	4603      	mov	r3, r0
9000200a:	80fb      	strh	r3, [r7, #6]
  uint32_t counter = 0;
9000200c:	2300      	movs	r3, #0
9000200e:	60fb      	str	r3, [r7, #12]
 
  /* Resumes the audio file playing */  
  /* Unmute the output first */
  counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
90002010:	88fb      	ldrh	r3, [r7, #6]
90002012:	2100      	movs	r1, #0
90002014:	4618      	mov	r0, r3
90002016:	f000 f99b 	bl	90002350 <wm8994_SetMute>
9000201a:	4602      	mov	r2, r0
9000201c:	68fb      	ldr	r3, [r7, #12]
9000201e:	4413      	add	r3, r2
90002020:	60fb      	str	r3, [r7, #12]
  
  return counter;
90002022:	68fb      	ldr	r3, [r7, #12]
}
90002024:	4618      	mov	r0, r3
90002026:	3710      	adds	r7, #16
90002028:	46bd      	mov	sp, r7
9000202a:	bd80      	pop	{r7, pc}

9000202c <wm8994_Stop>:
  *                           (user should re-Initialize the codec in order to 
  *                            play again the audio stream).
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_Stop(uint16_t DeviceAddr, uint32_t CodecPdwnMode)
{
9000202c:	b580      	push	{r7, lr}
9000202e:	b084      	sub	sp, #16
90002030:	af00      	add	r7, sp, #0
90002032:	4603      	mov	r3, r0
90002034:	6039      	str	r1, [r7, #0]
90002036:	80fb      	strh	r3, [r7, #6]
  uint32_t counter = 0;
90002038:	2300      	movs	r3, #0
9000203a:	60fb      	str	r3, [r7, #12]

  if (outputEnabled != 0)
9000203c:	4b31      	ldr	r3, [pc, #196]	; (90002104 <wm8994_Stop+0xd8>)
9000203e:	681b      	ldr	r3, [r3, #0]
90002040:	2b00      	cmp	r3, #0
90002042:	d05a      	beq.n	900020fa <wm8994_Stop+0xce>
  {
    /* Mute the output first */
    counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_ON);
90002044:	88fb      	ldrh	r3, [r7, #6]
90002046:	2101      	movs	r1, #1
90002048:	4618      	mov	r0, r3
9000204a:	f000 f981 	bl	90002350 <wm8994_SetMute>
9000204e:	4602      	mov	r2, r0
90002050:	68fb      	ldr	r3, [r7, #12]
90002052:	4413      	add	r3, r2
90002054:	60fb      	str	r3, [r7, #12]

    if (CodecPdwnMode == CODEC_PDWN_SW)
90002056:	683b      	ldr	r3, [r7, #0]
90002058:	2b02      	cmp	r3, #2
9000205a:	d04e      	beq.n	900020fa <wm8994_Stop+0xce>
      /* Only output mute required*/
    }
    else /* CODEC_PDWN_HW */
    {
      /* Mute the AIF1 Timeslot 0 DAC1 path */
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
9000205c:	88fb      	ldrh	r3, [r7, #6]
9000205e:	b2db      	uxtb	r3, r3
90002060:	f44f 7200 	mov.w	r2, #512	; 0x200
90002064:	f44f 6184 	mov.w	r1, #1056	; 0x420
90002068:	4618      	mov	r0, r3
9000206a:	f000 fbd7 	bl	9000281c <CODEC_IO_Write>
9000206e:	4603      	mov	r3, r0
90002070:	461a      	mov	r2, r3
90002072:	68fb      	ldr	r3, [r7, #12]
90002074:	4413      	add	r3, r2
90002076:	60fb      	str	r3, [r7, #12]

      /* Mute the AIF1 Timeslot 1 DAC2 path */
      counter += CODEC_IO_Write(DeviceAddr, 0x422, 0x0200);
90002078:	88fb      	ldrh	r3, [r7, #6]
9000207a:	b2db      	uxtb	r3, r3
9000207c:	f44f 7200 	mov.w	r2, #512	; 0x200
90002080:	f240 4122 	movw	r1, #1058	; 0x422
90002084:	4618      	mov	r0, r3
90002086:	f000 fbc9 	bl	9000281c <CODEC_IO_Write>
9000208a:	4603      	mov	r3, r0
9000208c:	461a      	mov	r2, r3
9000208e:	68fb      	ldr	r3, [r7, #12]
90002090:	4413      	add	r3, r2
90002092:	60fb      	str	r3, [r7, #12]

      /* Disable DAC1L_TO_HPOUT1L */
      counter += CODEC_IO_Write(DeviceAddr, 0x2D, 0x0000);
90002094:	88fb      	ldrh	r3, [r7, #6]
90002096:	b2db      	uxtb	r3, r3
90002098:	2200      	movs	r2, #0
9000209a:	212d      	movs	r1, #45	; 0x2d
9000209c:	4618      	mov	r0, r3
9000209e:	f000 fbbd 	bl	9000281c <CODEC_IO_Write>
900020a2:	4603      	mov	r3, r0
900020a4:	461a      	mov	r2, r3
900020a6:	68fb      	ldr	r3, [r7, #12]
900020a8:	4413      	add	r3, r2
900020aa:	60fb      	str	r3, [r7, #12]

      /* Disable DAC1R_TO_HPOUT1R */
      counter += CODEC_IO_Write(DeviceAddr, 0x2E, 0x0000);
900020ac:	88fb      	ldrh	r3, [r7, #6]
900020ae:	b2db      	uxtb	r3, r3
900020b0:	2200      	movs	r2, #0
900020b2:	212e      	movs	r1, #46	; 0x2e
900020b4:	4618      	mov	r0, r3
900020b6:	f000 fbb1 	bl	9000281c <CODEC_IO_Write>
900020ba:	4603      	mov	r3, r0
900020bc:	461a      	mov	r2, r3
900020be:	68fb      	ldr	r3, [r7, #12]
900020c0:	4413      	add	r3, r2
900020c2:	60fb      	str	r3, [r7, #12]

      /* Disable DAC1 and DAC2 */
      counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0000);
900020c4:	88fb      	ldrh	r3, [r7, #6]
900020c6:	b2db      	uxtb	r3, r3
900020c8:	2200      	movs	r2, #0
900020ca:	2105      	movs	r1, #5
900020cc:	4618      	mov	r0, r3
900020ce:	f000 fba5 	bl	9000281c <CODEC_IO_Write>
900020d2:	4603      	mov	r3, r0
900020d4:	461a      	mov	r2, r3
900020d6:	68fb      	ldr	r3, [r7, #12]
900020d8:	4413      	add	r3, r2
900020da:	60fb      	str	r3, [r7, #12]

      /* Reset Codec by writing in 0x0000 address register */
      counter += CODEC_IO_Write(DeviceAddr, 0x0000, 0x0000);
900020dc:	88fb      	ldrh	r3, [r7, #6]
900020de:	b2db      	uxtb	r3, r3
900020e0:	2200      	movs	r2, #0
900020e2:	2100      	movs	r1, #0
900020e4:	4618      	mov	r0, r3
900020e6:	f000 fb99 	bl	9000281c <CODEC_IO_Write>
900020ea:	4603      	mov	r3, r0
900020ec:	461a      	mov	r2, r3
900020ee:	68fb      	ldr	r3, [r7, #12]
900020f0:	4413      	add	r3, r2
900020f2:	60fb      	str	r3, [r7, #12]

      outputEnabled = 0;
900020f4:	4b03      	ldr	r3, [pc, #12]	; (90002104 <wm8994_Stop+0xd8>)
900020f6:	2200      	movs	r2, #0
900020f8:	601a      	str	r2, [r3, #0]
    }
  }
  return counter;
900020fa:	68fb      	ldr	r3, [r7, #12]
}
900020fc:	4618      	mov	r0, r3
900020fe:	3710      	adds	r7, #16
90002100:	46bd      	mov	sp, r7
90002102:	bd80      	pop	{r7, pc}
90002104:	20000060 	.word	0x20000060

90002108 <wm8994_SetVolume>:
  * @param Volume: a byte value from 0 to 255 (refer to codec registers 
  *         description for more details).
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_SetVolume(uint16_t DeviceAddr, uint8_t Volume)
{
90002108:	b580      	push	{r7, lr}
9000210a:	b084      	sub	sp, #16
9000210c:	af00      	add	r7, sp, #0
9000210e:	4603      	mov	r3, r0
90002110:	460a      	mov	r2, r1
90002112:	80fb      	strh	r3, [r7, #6]
90002114:	4613      	mov	r3, r2
90002116:	717b      	strb	r3, [r7, #5]
  uint32_t counter = 0;
90002118:	2300      	movs	r3, #0
9000211a:	60fb      	str	r3, [r7, #12]
  uint8_t convertedvol = VOLUME_CONVERT(Volume);
9000211c:	797b      	ldrb	r3, [r7, #5]
9000211e:	2b64      	cmp	r3, #100	; 0x64
90002120:	d80b      	bhi.n	9000213a <wm8994_SetVolume+0x32>
90002122:	797a      	ldrb	r2, [r7, #5]
90002124:	4613      	mov	r3, r2
90002126:	019b      	lsls	r3, r3, #6
90002128:	1a9b      	subs	r3, r3, r2
9000212a:	4a86      	ldr	r2, [pc, #536]	; (90002344 <wm8994_SetVolume+0x23c>)
9000212c:	fb82 1203 	smull	r1, r2, r2, r3
90002130:	1152      	asrs	r2, r2, #5
90002132:	17db      	asrs	r3, r3, #31
90002134:	1ad3      	subs	r3, r2, r3
90002136:	b2db      	uxtb	r3, r3
90002138:	e000      	b.n	9000213c <wm8994_SetVolume+0x34>
9000213a:	2364      	movs	r3, #100	; 0x64
9000213c:	72fb      	strb	r3, [r7, #11]

  /* Output volume */
  if (outputEnabled != 0)
9000213e:	4b82      	ldr	r3, [pc, #520]	; (90002348 <wm8994_SetVolume+0x240>)
90002140:	681b      	ldr	r3, [r3, #0]
90002142:	2b00      	cmp	r3, #0
90002144:	f000 809b 	beq.w	9000227e <wm8994_SetVolume+0x176>
  {
    if(convertedvol > 0x3E)
90002148:	7afb      	ldrb	r3, [r7, #11]
9000214a:	2b3e      	cmp	r3, #62	; 0x3e
9000214c:	d93d      	bls.n	900021ca <wm8994_SetVolume+0xc2>
    {
      /* Unmute audio codec */
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
9000214e:	88fb      	ldrh	r3, [r7, #6]
90002150:	2100      	movs	r1, #0
90002152:	4618      	mov	r0, r3
90002154:	f000 f8fc 	bl	90002350 <wm8994_SetMute>
90002158:	4602      	mov	r2, r0
9000215a:	68fb      	ldr	r3, [r7, #12]
9000215c:	4413      	add	r3, r2
9000215e:	60fb      	str	r3, [r7, #12]

      /* Left Headphone Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x1C, 0x3F | 0x140);
90002160:	88fb      	ldrh	r3, [r7, #6]
90002162:	b2db      	uxtb	r3, r3
90002164:	f240 127f 	movw	r2, #383	; 0x17f
90002168:	211c      	movs	r1, #28
9000216a:	4618      	mov	r0, r3
9000216c:	f000 fb56 	bl	9000281c <CODEC_IO_Write>
90002170:	4603      	mov	r3, r0
90002172:	461a      	mov	r2, r3
90002174:	68fb      	ldr	r3, [r7, #12]
90002176:	4413      	add	r3, r2
90002178:	60fb      	str	r3, [r7, #12]

      /* Right Headphone Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x1D, 0x3F | 0x140);
9000217a:	88fb      	ldrh	r3, [r7, #6]
9000217c:	b2db      	uxtb	r3, r3
9000217e:	f240 127f 	movw	r2, #383	; 0x17f
90002182:	211d      	movs	r1, #29
90002184:	4618      	mov	r0, r3
90002186:	f000 fb49 	bl	9000281c <CODEC_IO_Write>
9000218a:	4603      	mov	r3, r0
9000218c:	461a      	mov	r2, r3
9000218e:	68fb      	ldr	r3, [r7, #12]
90002190:	4413      	add	r3, r2
90002192:	60fb      	str	r3, [r7, #12]

      /* Left Speaker Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x26, 0x3F | 0x140);
90002194:	88fb      	ldrh	r3, [r7, #6]
90002196:	b2db      	uxtb	r3, r3
90002198:	f240 127f 	movw	r2, #383	; 0x17f
9000219c:	2126      	movs	r1, #38	; 0x26
9000219e:	4618      	mov	r0, r3
900021a0:	f000 fb3c 	bl	9000281c <CODEC_IO_Write>
900021a4:	4603      	mov	r3, r0
900021a6:	461a      	mov	r2, r3
900021a8:	68fb      	ldr	r3, [r7, #12]
900021aa:	4413      	add	r3, r2
900021ac:	60fb      	str	r3, [r7, #12]

      /* Right Speaker Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x27, 0x3F | 0x140);
900021ae:	88fb      	ldrh	r3, [r7, #6]
900021b0:	b2db      	uxtb	r3, r3
900021b2:	f240 127f 	movw	r2, #383	; 0x17f
900021b6:	2127      	movs	r1, #39	; 0x27
900021b8:	4618      	mov	r0, r3
900021ba:	f000 fb2f 	bl	9000281c <CODEC_IO_Write>
900021be:	4603      	mov	r3, r0
900021c0:	461a      	mov	r2, r3
900021c2:	68fb      	ldr	r3, [r7, #12]
900021c4:	4413      	add	r3, r2
900021c6:	60fb      	str	r3, [r7, #12]
900021c8:	e059      	b.n	9000227e <wm8994_SetVolume+0x176>
    }
    else if (Volume == 0)
900021ca:	797b      	ldrb	r3, [r7, #5]
900021cc:	2b00      	cmp	r3, #0
900021ce:	d109      	bne.n	900021e4 <wm8994_SetVolume+0xdc>
    {
      /* Mute audio codec */
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_ON);
900021d0:	88fb      	ldrh	r3, [r7, #6]
900021d2:	2101      	movs	r1, #1
900021d4:	4618      	mov	r0, r3
900021d6:	f000 f8bb 	bl	90002350 <wm8994_SetMute>
900021da:	4602      	mov	r2, r0
900021dc:	68fb      	ldr	r3, [r7, #12]
900021de:	4413      	add	r3, r2
900021e0:	60fb      	str	r3, [r7, #12]
900021e2:	e04c      	b.n	9000227e <wm8994_SetVolume+0x176>
    }
    else
    {
      /* Unmute audio codec */
      counter += wm8994_SetMute(DeviceAddr, AUDIO_MUTE_OFF);
900021e4:	88fb      	ldrh	r3, [r7, #6]
900021e6:	2100      	movs	r1, #0
900021e8:	4618      	mov	r0, r3
900021ea:	f000 f8b1 	bl	90002350 <wm8994_SetMute>
900021ee:	4602      	mov	r2, r0
900021f0:	68fb      	ldr	r3, [r7, #12]
900021f2:	4413      	add	r3, r2
900021f4:	60fb      	str	r3, [r7, #12]

      /* Left Headphone Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x1C, convertedvol | 0x140);
900021f6:	88fb      	ldrh	r3, [r7, #6]
900021f8:	b2d8      	uxtb	r0, r3
900021fa:	7afb      	ldrb	r3, [r7, #11]
900021fc:	b21b      	sxth	r3, r3
900021fe:	f443 73a0 	orr.w	r3, r3, #320	; 0x140
90002202:	b21b      	sxth	r3, r3
90002204:	b29b      	uxth	r3, r3
90002206:	461a      	mov	r2, r3
90002208:	211c      	movs	r1, #28
9000220a:	f000 fb07 	bl	9000281c <CODEC_IO_Write>
9000220e:	4603      	mov	r3, r0
90002210:	461a      	mov	r2, r3
90002212:	68fb      	ldr	r3, [r7, #12]
90002214:	4413      	add	r3, r2
90002216:	60fb      	str	r3, [r7, #12]

      /* Right Headphone Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x1D, convertedvol | 0x140);
90002218:	88fb      	ldrh	r3, [r7, #6]
9000221a:	b2d8      	uxtb	r0, r3
9000221c:	7afb      	ldrb	r3, [r7, #11]
9000221e:	b21b      	sxth	r3, r3
90002220:	f443 73a0 	orr.w	r3, r3, #320	; 0x140
90002224:	b21b      	sxth	r3, r3
90002226:	b29b      	uxth	r3, r3
90002228:	461a      	mov	r2, r3
9000222a:	211d      	movs	r1, #29
9000222c:	f000 faf6 	bl	9000281c <CODEC_IO_Write>
90002230:	4603      	mov	r3, r0
90002232:	461a      	mov	r2, r3
90002234:	68fb      	ldr	r3, [r7, #12]
90002236:	4413      	add	r3, r2
90002238:	60fb      	str	r3, [r7, #12]

      /* Left Speaker Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x26, convertedvol | 0x140);
9000223a:	88fb      	ldrh	r3, [r7, #6]
9000223c:	b2d8      	uxtb	r0, r3
9000223e:	7afb      	ldrb	r3, [r7, #11]
90002240:	b21b      	sxth	r3, r3
90002242:	f443 73a0 	orr.w	r3, r3, #320	; 0x140
90002246:	b21b      	sxth	r3, r3
90002248:	b29b      	uxth	r3, r3
9000224a:	461a      	mov	r2, r3
9000224c:	2126      	movs	r1, #38	; 0x26
9000224e:	f000 fae5 	bl	9000281c <CODEC_IO_Write>
90002252:	4603      	mov	r3, r0
90002254:	461a      	mov	r2, r3
90002256:	68fb      	ldr	r3, [r7, #12]
90002258:	4413      	add	r3, r2
9000225a:	60fb      	str	r3, [r7, #12]

      /* Right Speaker Volume */
      counter += CODEC_IO_Write(DeviceAddr, 0x27, convertedvol | 0x140);
9000225c:	88fb      	ldrh	r3, [r7, #6]
9000225e:	b2d8      	uxtb	r0, r3
90002260:	7afb      	ldrb	r3, [r7, #11]
90002262:	b21b      	sxth	r3, r3
90002264:	f443 73a0 	orr.w	r3, r3, #320	; 0x140
90002268:	b21b      	sxth	r3, r3
9000226a:	b29b      	uxth	r3, r3
9000226c:	461a      	mov	r2, r3
9000226e:	2127      	movs	r1, #39	; 0x27
90002270:	f000 fad4 	bl	9000281c <CODEC_IO_Write>
90002274:	4603      	mov	r3, r0
90002276:	461a      	mov	r2, r3
90002278:	68fb      	ldr	r3, [r7, #12]
9000227a:	4413      	add	r3, r2
9000227c:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Input volume */
  if (inputEnabled != 0)
9000227e:	4b33      	ldr	r3, [pc, #204]	; (9000234c <wm8994_SetVolume+0x244>)
90002280:	681b      	ldr	r3, [r3, #0]
90002282:	2b00      	cmp	r3, #0
90002284:	d059      	beq.n	9000233a <wm8994_SetVolume+0x232>
  {
    convertedvol = VOLUME_IN_CONVERT(Volume);
90002286:	797b      	ldrb	r3, [r7, #5]
90002288:	2b63      	cmp	r3, #99	; 0x63
9000228a:	d80c      	bhi.n	900022a6 <wm8994_SetVolume+0x19e>
9000228c:	797a      	ldrb	r2, [r7, #5]
9000228e:	4613      	mov	r3, r2
90002290:	011b      	lsls	r3, r3, #4
90002292:	1a9b      	subs	r3, r3, r2
90002294:	011b      	lsls	r3, r3, #4
90002296:	4a2b      	ldr	r2, [pc, #172]	; (90002344 <wm8994_SetVolume+0x23c>)
90002298:	fb82 1203 	smull	r1, r2, r2, r3
9000229c:	1152      	asrs	r2, r2, #5
9000229e:	17db      	asrs	r3, r3, #31
900022a0:	1ad3      	subs	r3, r2, r3
900022a2:	b2db      	uxtb	r3, r3
900022a4:	e000      	b.n	900022a8 <wm8994_SetVolume+0x1a0>
900022a6:	23ef      	movs	r3, #239	; 0xef
900022a8:	72fb      	strb	r3, [r7, #11]

    /* Left AIF1 ADC1 volume */
    counter += CODEC_IO_Write(DeviceAddr, 0x400, convertedvol | 0x100);
900022aa:	88fb      	ldrh	r3, [r7, #6]
900022ac:	b2d8      	uxtb	r0, r3
900022ae:	7afb      	ldrb	r3, [r7, #11]
900022b0:	b21b      	sxth	r3, r3
900022b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900022b6:	b21b      	sxth	r3, r3
900022b8:	b29b      	uxth	r3, r3
900022ba:	461a      	mov	r2, r3
900022bc:	f44f 6180 	mov.w	r1, #1024	; 0x400
900022c0:	f000 faac 	bl	9000281c <CODEC_IO_Write>
900022c4:	4603      	mov	r3, r0
900022c6:	461a      	mov	r2, r3
900022c8:	68fb      	ldr	r3, [r7, #12]
900022ca:	4413      	add	r3, r2
900022cc:	60fb      	str	r3, [r7, #12]

    /* Right AIF1 ADC1 volume */
    counter += CODEC_IO_Write(DeviceAddr, 0x401, convertedvol | 0x100);
900022ce:	88fb      	ldrh	r3, [r7, #6]
900022d0:	b2d8      	uxtb	r0, r3
900022d2:	7afb      	ldrb	r3, [r7, #11]
900022d4:	b21b      	sxth	r3, r3
900022d6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900022da:	b21b      	sxth	r3, r3
900022dc:	b29b      	uxth	r3, r3
900022de:	461a      	mov	r2, r3
900022e0:	f240 4101 	movw	r1, #1025	; 0x401
900022e4:	f000 fa9a 	bl	9000281c <CODEC_IO_Write>
900022e8:	4603      	mov	r3, r0
900022ea:	461a      	mov	r2, r3
900022ec:	68fb      	ldr	r3, [r7, #12]
900022ee:	4413      	add	r3, r2
900022f0:	60fb      	str	r3, [r7, #12]

    /* Left AIF1 ADC2 volume */
    counter += CODEC_IO_Write(DeviceAddr, 0x404, convertedvol | 0x100);
900022f2:	88fb      	ldrh	r3, [r7, #6]
900022f4:	b2d8      	uxtb	r0, r3
900022f6:	7afb      	ldrb	r3, [r7, #11]
900022f8:	b21b      	sxth	r3, r3
900022fa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900022fe:	b21b      	sxth	r3, r3
90002300:	b29b      	uxth	r3, r3
90002302:	461a      	mov	r2, r3
90002304:	f240 4104 	movw	r1, #1028	; 0x404
90002308:	f000 fa88 	bl	9000281c <CODEC_IO_Write>
9000230c:	4603      	mov	r3, r0
9000230e:	461a      	mov	r2, r3
90002310:	68fb      	ldr	r3, [r7, #12]
90002312:	4413      	add	r3, r2
90002314:	60fb      	str	r3, [r7, #12]

    /* Right AIF1 ADC2 volume */
    counter += CODEC_IO_Write(DeviceAddr, 0x405, convertedvol | 0x100);
90002316:	88fb      	ldrh	r3, [r7, #6]
90002318:	b2d8      	uxtb	r0, r3
9000231a:	7afb      	ldrb	r3, [r7, #11]
9000231c:	b21b      	sxth	r3, r3
9000231e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90002322:	b21b      	sxth	r3, r3
90002324:	b29b      	uxth	r3, r3
90002326:	461a      	mov	r2, r3
90002328:	f240 4105 	movw	r1, #1029	; 0x405
9000232c:	f000 fa76 	bl	9000281c <CODEC_IO_Write>
90002330:	4603      	mov	r3, r0
90002332:	461a      	mov	r2, r3
90002334:	68fb      	ldr	r3, [r7, #12]
90002336:	4413      	add	r3, r2
90002338:	60fb      	str	r3, [r7, #12]
  }
  return counter;
9000233a:	68fb      	ldr	r3, [r7, #12]
}
9000233c:	4618      	mov	r0, r3
9000233e:	3710      	adds	r7, #16
90002340:	46bd      	mov	sp, r7
90002342:	bd80      	pop	{r7, pc}
90002344:	51eb851f 	.word	0x51eb851f
90002348:	20000060 	.word	0x20000060
9000234c:	20000064 	.word	0x20000064

90002350 <wm8994_SetMute>:
  * @param Cmd: AUDIO_MUTE_ON to enable the mute or AUDIO_MUTE_OFF to disable the
  *             mute mode.
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_SetMute(uint16_t DeviceAddr, uint32_t Cmd)
{
90002350:	b580      	push	{r7, lr}
90002352:	b084      	sub	sp, #16
90002354:	af00      	add	r7, sp, #0
90002356:	4603      	mov	r3, r0
90002358:	6039      	str	r1, [r7, #0]
9000235a:	80fb      	strh	r3, [r7, #6]
  uint32_t counter = 0;
9000235c:	2300      	movs	r3, #0
9000235e:	60fb      	str	r3, [r7, #12]
  
  if (outputEnabled != 0)
90002360:	4b21      	ldr	r3, [pc, #132]	; (900023e8 <wm8994_SetMute+0x98>)
90002362:	681b      	ldr	r3, [r3, #0]
90002364:	2b00      	cmp	r3, #0
90002366:	d039      	beq.n	900023dc <wm8994_SetMute+0x8c>
  {
    /* Set the Mute mode */
    if(Cmd == AUDIO_MUTE_ON)
90002368:	683b      	ldr	r3, [r7, #0]
9000236a:	2b01      	cmp	r3, #1
9000236c:	d11c      	bne.n	900023a8 <wm8994_SetMute+0x58>
    {
      /* Soft Mute the AIF1 Timeslot 0 DAC1 path L&R */
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0200);
9000236e:	88fb      	ldrh	r3, [r7, #6]
90002370:	b2db      	uxtb	r3, r3
90002372:	f44f 7200 	mov.w	r2, #512	; 0x200
90002376:	f44f 6184 	mov.w	r1, #1056	; 0x420
9000237a:	4618      	mov	r0, r3
9000237c:	f000 fa4e 	bl	9000281c <CODEC_IO_Write>
90002380:	4603      	mov	r3, r0
90002382:	461a      	mov	r2, r3
90002384:	68fb      	ldr	r3, [r7, #12]
90002386:	4413      	add	r3, r2
90002388:	60fb      	str	r3, [r7, #12]

      /* Soft Mute the AIF1 Timeslot 1 DAC2 path L&R */
      counter += CODEC_IO_Write(DeviceAddr, 0x422, 0x0200);
9000238a:	88fb      	ldrh	r3, [r7, #6]
9000238c:	b2db      	uxtb	r3, r3
9000238e:	f44f 7200 	mov.w	r2, #512	; 0x200
90002392:	f240 4122 	movw	r1, #1058	; 0x422
90002396:	4618      	mov	r0, r3
90002398:	f000 fa40 	bl	9000281c <CODEC_IO_Write>
9000239c:	4603      	mov	r3, r0
9000239e:	461a      	mov	r2, r3
900023a0:	68fb      	ldr	r3, [r7, #12]
900023a2:	4413      	add	r3, r2
900023a4:	60fb      	str	r3, [r7, #12]
900023a6:	e019      	b.n	900023dc <wm8994_SetMute+0x8c>
    }
    else /* AUDIO_MUTE_OFF Disable the Mute */
    {
      /* Unmute the AIF1 Timeslot 0 DAC1 path L&R */
      counter += CODEC_IO_Write(DeviceAddr, 0x420, 0x0010);
900023a8:	88fb      	ldrh	r3, [r7, #6]
900023aa:	b2db      	uxtb	r3, r3
900023ac:	2210      	movs	r2, #16
900023ae:	f44f 6184 	mov.w	r1, #1056	; 0x420
900023b2:	4618      	mov	r0, r3
900023b4:	f000 fa32 	bl	9000281c <CODEC_IO_Write>
900023b8:	4603      	mov	r3, r0
900023ba:	461a      	mov	r2, r3
900023bc:	68fb      	ldr	r3, [r7, #12]
900023be:	4413      	add	r3, r2
900023c0:	60fb      	str	r3, [r7, #12]

      /* Unmute the AIF1 Timeslot 1 DAC2 path L&R */
      counter += CODEC_IO_Write(DeviceAddr, 0x422, 0x0010);
900023c2:	88fb      	ldrh	r3, [r7, #6]
900023c4:	b2db      	uxtb	r3, r3
900023c6:	2210      	movs	r2, #16
900023c8:	f240 4122 	movw	r1, #1058	; 0x422
900023cc:	4618      	mov	r0, r3
900023ce:	f000 fa25 	bl	9000281c <CODEC_IO_Write>
900023d2:	4603      	mov	r3, r0
900023d4:	461a      	mov	r2, r3
900023d6:	68fb      	ldr	r3, [r7, #12]
900023d8:	4413      	add	r3, r2
900023da:	60fb      	str	r3, [r7, #12]
    }
  }
  return counter;
900023dc:	68fb      	ldr	r3, [r7, #12]
}
900023de:	4618      	mov	r0, r3
900023e0:	3710      	adds	r7, #16
900023e2:	46bd      	mov	sp, r7
900023e4:	bd80      	pop	{r7, pc}
900023e6:	bf00      	nop
900023e8:	20000060 	.word	0x20000060

900023ec <wm8994_SetOutputMode>:
  * @param Output: specifies the audio output target: OUTPUT_DEVICE_SPEAKER,
  *         OUTPUT_DEVICE_HEADPHONE, OUTPUT_DEVICE_BOTH or OUTPUT_DEVICE_AUTO 
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_SetOutputMode(uint16_t DeviceAddr, uint8_t Output)
{
900023ec:	b580      	push	{r7, lr}
900023ee:	b084      	sub	sp, #16
900023f0:	af00      	add	r7, sp, #0
900023f2:	4603      	mov	r3, r0
900023f4:	460a      	mov	r2, r1
900023f6:	80fb      	strh	r3, [r7, #6]
900023f8:	4613      	mov	r3, r2
900023fa:	717b      	strb	r3, [r7, #5]
  uint32_t counter = 0; 
900023fc:	2300      	movs	r3, #0
900023fe:	60fb      	str	r3, [r7, #12]
  
  switch (Output) 
90002400:	797b      	ldrb	r3, [r7, #5]
90002402:	2b03      	cmp	r3, #3
90002404:	f000 808c 	beq.w	90002520 <wm8994_SetOutputMode+0x134>
90002408:	2b03      	cmp	r3, #3
9000240a:	f300 80cb 	bgt.w	900025a4 <wm8994_SetOutputMode+0x1b8>
9000240e:	2b01      	cmp	r3, #1
90002410:	d002      	beq.n	90002418 <wm8994_SetOutputMode+0x2c>
90002412:	2b02      	cmp	r3, #2
90002414:	d042      	beq.n	9000249c <wm8994_SetOutputMode+0xb0>
90002416:	e0c5      	b.n	900025a4 <wm8994_SetOutputMode+0x1b8>
  {
  case OUTPUT_DEVICE_SPEAKER:
    /* Enable DAC1 (Left), Enable DAC1 (Right), 
    Disable DAC2 (Left), Disable DAC2 (Right)*/
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0C0C);
90002418:	88fb      	ldrh	r3, [r7, #6]
9000241a:	b2db      	uxtb	r3, r3
9000241c:	f640 420c 	movw	r2, #3084	; 0xc0c
90002420:	2105      	movs	r1, #5
90002422:	4618      	mov	r0, r3
90002424:	f000 f9fa 	bl	9000281c <CODEC_IO_Write>
90002428:	4603      	mov	r3, r0
9000242a:	461a      	mov	r2, r3
9000242c:	68fb      	ldr	r3, [r7, #12]
9000242e:	4413      	add	r3, r2
90002430:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0000);
90002432:	88fb      	ldrh	r3, [r7, #6]
90002434:	b2db      	uxtb	r3, r3
90002436:	2200      	movs	r2, #0
90002438:	f240 6101 	movw	r1, #1537	; 0x601
9000243c:	4618      	mov	r0, r3
9000243e:	f000 f9ed 	bl	9000281c <CODEC_IO_Write>
90002442:	4603      	mov	r3, r0
90002444:	461a      	mov	r2, r3
90002446:	68fb      	ldr	r3, [r7, #12]
90002448:	4413      	add	r3, r2
9000244a:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0000);
9000244c:	88fb      	ldrh	r3, [r7, #6]
9000244e:	b2db      	uxtb	r3, r3
90002450:	2200      	movs	r2, #0
90002452:	f240 6102 	movw	r1, #1538	; 0x602
90002456:	4618      	mov	r0, r3
90002458:	f000 f9e0 	bl	9000281c <CODEC_IO_Write>
9000245c:	4603      	mov	r3, r0
9000245e:	461a      	mov	r2, r3
90002460:	68fb      	ldr	r3, [r7, #12]
90002462:	4413      	add	r3, r2
90002464:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0002);
90002466:	88fb      	ldrh	r3, [r7, #6]
90002468:	b2db      	uxtb	r3, r3
9000246a:	2202      	movs	r2, #2
9000246c:	f240 6104 	movw	r1, #1540	; 0x604
90002470:	4618      	mov	r0, r3
90002472:	f000 f9d3 	bl	9000281c <CODEC_IO_Write>
90002476:	4603      	mov	r3, r0
90002478:	461a      	mov	r2, r3
9000247a:	68fb      	ldr	r3, [r7, #12]
9000247c:	4413      	add	r3, r2
9000247e:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0002);
90002480:	88fb      	ldrh	r3, [r7, #6]
90002482:	b2db      	uxtb	r3, r3
90002484:	2202      	movs	r2, #2
90002486:	f240 6105 	movw	r1, #1541	; 0x605
9000248a:	4618      	mov	r0, r3
9000248c:	f000 f9c6 	bl	9000281c <CODEC_IO_Write>
90002490:	4603      	mov	r3, r0
90002492:	461a      	mov	r2, r3
90002494:	68fb      	ldr	r3, [r7, #12]
90002496:	4413      	add	r3, r2
90002498:	60fb      	str	r3, [r7, #12]
    break;
9000249a:	e0c5      	b.n	90002628 <wm8994_SetOutputMode+0x23c>
    
  case OUTPUT_DEVICE_HEADPHONE:
    /* Disable DAC1 (Left), Disable DAC1 (Right), 
    Enable DAC2 (Left), Enable DAC2 (Right)*/
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303);
9000249c:	88fb      	ldrh	r3, [r7, #6]
9000249e:	b2db      	uxtb	r3, r3
900024a0:	f240 3203 	movw	r2, #771	; 0x303
900024a4:	2105      	movs	r1, #5
900024a6:	4618      	mov	r0, r3
900024a8:	f000 f9b8 	bl	9000281c <CODEC_IO_Write>
900024ac:	4603      	mov	r3, r0
900024ae:	461a      	mov	r2, r3
900024b0:	68fb      	ldr	r3, [r7, #12]
900024b2:	4413      	add	r3, r2
900024b4:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0001);
900024b6:	88fb      	ldrh	r3, [r7, #6]
900024b8:	b2db      	uxtb	r3, r3
900024ba:	2201      	movs	r2, #1
900024bc:	f240 6101 	movw	r1, #1537	; 0x601
900024c0:	4618      	mov	r0, r3
900024c2:	f000 f9ab 	bl	9000281c <CODEC_IO_Write>
900024c6:	4603      	mov	r3, r0
900024c8:	461a      	mov	r2, r3
900024ca:	68fb      	ldr	r3, [r7, #12]
900024cc:	4413      	add	r3, r2
900024ce:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0001);
900024d0:	88fb      	ldrh	r3, [r7, #6]
900024d2:	b2db      	uxtb	r3, r3
900024d4:	2201      	movs	r2, #1
900024d6:	f240 6102 	movw	r1, #1538	; 0x602
900024da:	4618      	mov	r0, r3
900024dc:	f000 f99e 	bl	9000281c <CODEC_IO_Write>
900024e0:	4603      	mov	r3, r0
900024e2:	461a      	mov	r2, r3
900024e4:	68fb      	ldr	r3, [r7, #12]
900024e6:	4413      	add	r3, r2
900024e8:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0000);
900024ea:	88fb      	ldrh	r3, [r7, #6]
900024ec:	b2db      	uxtb	r3, r3
900024ee:	2200      	movs	r2, #0
900024f0:	f240 6104 	movw	r1, #1540	; 0x604
900024f4:	4618      	mov	r0, r3
900024f6:	f000 f991 	bl	9000281c <CODEC_IO_Write>
900024fa:	4603      	mov	r3, r0
900024fc:	461a      	mov	r2, r3
900024fe:	68fb      	ldr	r3, [r7, #12]
90002500:	4413      	add	r3, r2
90002502:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0000);
90002504:	88fb      	ldrh	r3, [r7, #6]
90002506:	b2db      	uxtb	r3, r3
90002508:	2200      	movs	r2, #0
9000250a:	f240 6105 	movw	r1, #1541	; 0x605
9000250e:	4618      	mov	r0, r3
90002510:	f000 f984 	bl	9000281c <CODEC_IO_Write>
90002514:	4603      	mov	r3, r0
90002516:	461a      	mov	r2, r3
90002518:	68fb      	ldr	r3, [r7, #12]
9000251a:	4413      	add	r3, r2
9000251c:	60fb      	str	r3, [r7, #12]
    break;
9000251e:	e083      	b.n	90002628 <wm8994_SetOutputMode+0x23c>
    
  case OUTPUT_DEVICE_BOTH:
    /* Enable DAC1 (Left), Enable DAC1 (Right), 
    also Enable DAC2 (Left), Enable DAC2 (Right)*/
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303 | 0x0C0C);
90002520:	88fb      	ldrh	r3, [r7, #6]
90002522:	b2db      	uxtb	r3, r3
90002524:	f640 720f 	movw	r2, #3855	; 0xf0f
90002528:	2105      	movs	r1, #5
9000252a:	4618      	mov	r0, r3
9000252c:	f000 f976 	bl	9000281c <CODEC_IO_Write>
90002530:	4603      	mov	r3, r0
90002532:	461a      	mov	r2, r3
90002534:	68fb      	ldr	r3, [r7, #12]
90002536:	4413      	add	r3, r2
90002538:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0001);
9000253a:	88fb      	ldrh	r3, [r7, #6]
9000253c:	b2db      	uxtb	r3, r3
9000253e:	2201      	movs	r2, #1
90002540:	f240 6101 	movw	r1, #1537	; 0x601
90002544:	4618      	mov	r0, r3
90002546:	f000 f969 	bl	9000281c <CODEC_IO_Write>
9000254a:	4603      	mov	r3, r0
9000254c:	461a      	mov	r2, r3
9000254e:	68fb      	ldr	r3, [r7, #12]
90002550:	4413      	add	r3, r2
90002552:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0001);
90002554:	88fb      	ldrh	r3, [r7, #6]
90002556:	b2db      	uxtb	r3, r3
90002558:	2201      	movs	r2, #1
9000255a:	f240 6102 	movw	r1, #1538	; 0x602
9000255e:	4618      	mov	r0, r3
90002560:	f000 f95c 	bl	9000281c <CODEC_IO_Write>
90002564:	4603      	mov	r3, r0
90002566:	461a      	mov	r2, r3
90002568:	68fb      	ldr	r3, [r7, #12]
9000256a:	4413      	add	r3, r2
9000256c:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0002);
9000256e:	88fb      	ldrh	r3, [r7, #6]
90002570:	b2db      	uxtb	r3, r3
90002572:	2202      	movs	r2, #2
90002574:	f240 6104 	movw	r1, #1540	; 0x604
90002578:	4618      	mov	r0, r3
9000257a:	f000 f94f 	bl	9000281c <CODEC_IO_Write>
9000257e:	4603      	mov	r3, r0
90002580:	461a      	mov	r2, r3
90002582:	68fb      	ldr	r3, [r7, #12]
90002584:	4413      	add	r3, r2
90002586:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0002);
90002588:	88fb      	ldrh	r3, [r7, #6]
9000258a:	b2db      	uxtb	r3, r3
9000258c:	2202      	movs	r2, #2
9000258e:	f240 6105 	movw	r1, #1541	; 0x605
90002592:	4618      	mov	r0, r3
90002594:	f000 f942 	bl	9000281c <CODEC_IO_Write>
90002598:	4603      	mov	r3, r0
9000259a:	461a      	mov	r2, r3
9000259c:	68fb      	ldr	r3, [r7, #12]
9000259e:	4413      	add	r3, r2
900025a0:	60fb      	str	r3, [r7, #12]
    break;
900025a2:	e041      	b.n	90002628 <wm8994_SetOutputMode+0x23c>
    
  default:
    /* Disable DAC1 (Left), Disable DAC1 (Right), 
    Enable DAC2 (Left), Enable DAC2 (Right)*/
    counter += CODEC_IO_Write(DeviceAddr, 0x05, 0x0303);
900025a4:	88fb      	ldrh	r3, [r7, #6]
900025a6:	b2db      	uxtb	r3, r3
900025a8:	f240 3203 	movw	r2, #771	; 0x303
900025ac:	2105      	movs	r1, #5
900025ae:	4618      	mov	r0, r3
900025b0:	f000 f934 	bl	9000281c <CODEC_IO_Write>
900025b4:	4603      	mov	r3, r0
900025b6:	461a      	mov	r2, r3
900025b8:	68fb      	ldr	r3, [r7, #12]
900025ba:	4413      	add	r3, r2
900025bc:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x601, 0x0001);
900025be:	88fb      	ldrh	r3, [r7, #6]
900025c0:	b2db      	uxtb	r3, r3
900025c2:	2201      	movs	r2, #1
900025c4:	f240 6101 	movw	r1, #1537	; 0x601
900025c8:	4618      	mov	r0, r3
900025ca:	f000 f927 	bl	9000281c <CODEC_IO_Write>
900025ce:	4603      	mov	r3, r0
900025d0:	461a      	mov	r2, r3
900025d2:	68fb      	ldr	r3, [r7, #12]
900025d4:	4413      	add	r3, r2
900025d6:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x602, 0x0001);
900025d8:	88fb      	ldrh	r3, [r7, #6]
900025da:	b2db      	uxtb	r3, r3
900025dc:	2201      	movs	r2, #1
900025de:	f240 6102 	movw	r1, #1538	; 0x602
900025e2:	4618      	mov	r0, r3
900025e4:	f000 f91a 	bl	9000281c <CODEC_IO_Write>
900025e8:	4603      	mov	r3, r0
900025ea:	461a      	mov	r2, r3
900025ec:	68fb      	ldr	r3, [r7, #12]
900025ee:	4413      	add	r3, r2
900025f0:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x604, 0x0000);
900025f2:	88fb      	ldrh	r3, [r7, #6]
900025f4:	b2db      	uxtb	r3, r3
900025f6:	2200      	movs	r2, #0
900025f8:	f240 6104 	movw	r1, #1540	; 0x604
900025fc:	4618      	mov	r0, r3
900025fe:	f000 f90d 	bl	9000281c <CODEC_IO_Write>
90002602:	4603      	mov	r3, r0
90002604:	461a      	mov	r2, r3
90002606:	68fb      	ldr	r3, [r7, #12]
90002608:	4413      	add	r3, r2
9000260a:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    counter += CODEC_IO_Write(DeviceAddr, 0x605, 0x0000);
9000260c:	88fb      	ldrh	r3, [r7, #6]
9000260e:	b2db      	uxtb	r3, r3
90002610:	2200      	movs	r2, #0
90002612:	f240 6105 	movw	r1, #1541	; 0x605
90002616:	4618      	mov	r0, r3
90002618:	f000 f900 	bl	9000281c <CODEC_IO_Write>
9000261c:	4603      	mov	r3, r0
9000261e:	461a      	mov	r2, r3
90002620:	68fb      	ldr	r3, [r7, #12]
90002622:	4413      	add	r3, r2
90002624:	60fb      	str	r3, [r7, #12]
    break;    
90002626:	bf00      	nop
  }  
  return counter;
90002628:	68fb      	ldr	r3, [r7, #12]
}
9000262a:	4618      	mov	r0, r3
9000262c:	3710      	adds	r7, #16
9000262e:	46bd      	mov	sp, r7
90002630:	bd80      	pop	{r7, pc}
	...

90002634 <wm8994_SetFrequency>:
  * @param DeviceAddr: Device address on communication Bus.
  * @param AudioFreq: Audio frequency used to play the audio stream.
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_SetFrequency(uint16_t DeviceAddr, uint32_t AudioFreq)
{
90002634:	b580      	push	{r7, lr}
90002636:	b084      	sub	sp, #16
90002638:	af00      	add	r7, sp, #0
9000263a:	4603      	mov	r3, r0
9000263c:	6039      	str	r1, [r7, #0]
9000263e:	80fb      	strh	r3, [r7, #6]
  uint32_t counter = 0;
90002640:	2300      	movs	r3, #0
90002642:	60fb      	str	r3, [r7, #12]
 
  /*  Clock Configurations */
  switch (AudioFreq)
90002644:	683b      	ldr	r3, [r7, #0]
90002646:	4a64      	ldr	r2, [pc, #400]	; (900027d8 <wm8994_SetFrequency+0x1a4>)
90002648:	4293      	cmp	r3, r2
9000264a:	d079      	beq.n	90002740 <wm8994_SetFrequency+0x10c>
9000264c:	683b      	ldr	r3, [r7, #0]
9000264e:	4a62      	ldr	r2, [pc, #392]	; (900027d8 <wm8994_SetFrequency+0x1a4>)
90002650:	4293      	cmp	r3, r2
90002652:	f200 80ad 	bhi.w	900027b0 <wm8994_SetFrequency+0x17c>
90002656:	683b      	ldr	r3, [r7, #0]
90002658:	f64b 3280 	movw	r2, #48000	; 0xbb80
9000265c:	4293      	cmp	r3, r2
9000265e:	d061      	beq.n	90002724 <wm8994_SetFrequency+0xf0>
90002660:	683b      	ldr	r3, [r7, #0]
90002662:	f64b 3280 	movw	r2, #48000	; 0xbb80
90002666:	4293      	cmp	r3, r2
90002668:	f200 80a2 	bhi.w	900027b0 <wm8994_SetFrequency+0x17c>
9000266c:	683b      	ldr	r3, [r7, #0]
9000266e:	f64a 4244 	movw	r2, #44100	; 0xac44
90002672:	4293      	cmp	r3, r2
90002674:	f000 808e 	beq.w	90002794 <wm8994_SetFrequency+0x160>
90002678:	683b      	ldr	r3, [r7, #0]
9000267a:	f64a 4244 	movw	r2, #44100	; 0xac44
9000267e:	4293      	cmp	r3, r2
90002680:	f200 8096 	bhi.w	900027b0 <wm8994_SetFrequency+0x17c>
90002684:	683b      	ldr	r3, [r7, #0]
90002686:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
9000268a:	d03d      	beq.n	90002708 <wm8994_SetFrequency+0xd4>
9000268c:	683b      	ldr	r3, [r7, #0]
9000268e:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
90002692:	f200 808d 	bhi.w	900027b0 <wm8994_SetFrequency+0x17c>
90002696:	683b      	ldr	r3, [r7, #0]
90002698:	f245 6222 	movw	r2, #22050	; 0x5622
9000269c:	4293      	cmp	r3, r2
9000269e:	d06b      	beq.n	90002778 <wm8994_SetFrequency+0x144>
900026a0:	683b      	ldr	r3, [r7, #0]
900026a2:	f245 6222 	movw	r2, #22050	; 0x5622
900026a6:	4293      	cmp	r3, r2
900026a8:	f200 8082 	bhi.w	900027b0 <wm8994_SetFrequency+0x17c>
900026ac:	683b      	ldr	r3, [r7, #0]
900026ae:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
900026b2:	d01b      	beq.n	900026ec <wm8994_SetFrequency+0xb8>
900026b4:	683b      	ldr	r3, [r7, #0]
900026b6:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
900026ba:	d879      	bhi.n	900027b0 <wm8994_SetFrequency+0x17c>
900026bc:	683b      	ldr	r3, [r7, #0]
900026be:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
900026c2:	d005      	beq.n	900026d0 <wm8994_SetFrequency+0x9c>
900026c4:	683b      	ldr	r3, [r7, #0]
900026c6:	f642 3211 	movw	r2, #11025	; 0x2b11
900026ca:	4293      	cmp	r3, r2
900026cc:	d046      	beq.n	9000275c <wm8994_SetFrequency+0x128>
900026ce:	e06f      	b.n	900027b0 <wm8994_SetFrequency+0x17c>
  {
  case  AUDIO_FREQUENCY_8K:
    /* AIF1 Sample Rate = 8 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0003);
900026d0:	88fb      	ldrh	r3, [r7, #6]
900026d2:	b2db      	uxtb	r3, r3
900026d4:	2203      	movs	r2, #3
900026d6:	f44f 7104 	mov.w	r1, #528	; 0x210
900026da:	4618      	mov	r0, r3
900026dc:	f000 f89e 	bl	9000281c <CODEC_IO_Write>
900026e0:	4603      	mov	r3, r0
900026e2:	461a      	mov	r2, r3
900026e4:	68fb      	ldr	r3, [r7, #12]
900026e6:	4413      	add	r3, r2
900026e8:	60fb      	str	r3, [r7, #12]
    break;
900026ea:	e06f      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  case  AUDIO_FREQUENCY_16K:
    /* AIF1 Sample Rate = 16 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0033);
900026ec:	88fb      	ldrh	r3, [r7, #6]
900026ee:	b2db      	uxtb	r3, r3
900026f0:	2233      	movs	r2, #51	; 0x33
900026f2:	f44f 7104 	mov.w	r1, #528	; 0x210
900026f6:	4618      	mov	r0, r3
900026f8:	f000 f890 	bl	9000281c <CODEC_IO_Write>
900026fc:	4603      	mov	r3, r0
900026fe:	461a      	mov	r2, r3
90002700:	68fb      	ldr	r3, [r7, #12]
90002702:	4413      	add	r3, r2
90002704:	60fb      	str	r3, [r7, #12]
    break;
90002706:	e061      	b.n	900027cc <wm8994_SetFrequency+0x198>

  case  AUDIO_FREQUENCY_32K:
    /* AIF1 Sample Rate = 32 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0063);
90002708:	88fb      	ldrh	r3, [r7, #6]
9000270a:	b2db      	uxtb	r3, r3
9000270c:	2263      	movs	r2, #99	; 0x63
9000270e:	f44f 7104 	mov.w	r1, #528	; 0x210
90002712:	4618      	mov	r0, r3
90002714:	f000 f882 	bl	9000281c <CODEC_IO_Write>
90002718:	4603      	mov	r3, r0
9000271a:	461a      	mov	r2, r3
9000271c:	68fb      	ldr	r3, [r7, #12]
9000271e:	4413      	add	r3, r2
90002720:	60fb      	str	r3, [r7, #12]
    break;
90002722:	e053      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  case  AUDIO_FREQUENCY_48K:
    /* AIF1 Sample Rate = 48 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0083);
90002724:	88fb      	ldrh	r3, [r7, #6]
90002726:	b2db      	uxtb	r3, r3
90002728:	2283      	movs	r2, #131	; 0x83
9000272a:	f44f 7104 	mov.w	r1, #528	; 0x210
9000272e:	4618      	mov	r0, r3
90002730:	f000 f874 	bl	9000281c <CODEC_IO_Write>
90002734:	4603      	mov	r3, r0
90002736:	461a      	mov	r2, r3
90002738:	68fb      	ldr	r3, [r7, #12]
9000273a:	4413      	add	r3, r2
9000273c:	60fb      	str	r3, [r7, #12]
    break;
9000273e:	e045      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  case  AUDIO_FREQUENCY_96K:
    /* AIF1 Sample Rate = 96 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x00A3);
90002740:	88fb      	ldrh	r3, [r7, #6]
90002742:	b2db      	uxtb	r3, r3
90002744:	22a3      	movs	r2, #163	; 0xa3
90002746:	f44f 7104 	mov.w	r1, #528	; 0x210
9000274a:	4618      	mov	r0, r3
9000274c:	f000 f866 	bl	9000281c <CODEC_IO_Write>
90002750:	4603      	mov	r3, r0
90002752:	461a      	mov	r2, r3
90002754:	68fb      	ldr	r3, [r7, #12]
90002756:	4413      	add	r3, r2
90002758:	60fb      	str	r3, [r7, #12]
    break;
9000275a:	e037      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  case  AUDIO_FREQUENCY_11K:
    /* AIF1 Sample Rate = 11.025 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0013);
9000275c:	88fb      	ldrh	r3, [r7, #6]
9000275e:	b2db      	uxtb	r3, r3
90002760:	2213      	movs	r2, #19
90002762:	f44f 7104 	mov.w	r1, #528	; 0x210
90002766:	4618      	mov	r0, r3
90002768:	f000 f858 	bl	9000281c <CODEC_IO_Write>
9000276c:	4603      	mov	r3, r0
9000276e:	461a      	mov	r2, r3
90002770:	68fb      	ldr	r3, [r7, #12]
90002772:	4413      	add	r3, r2
90002774:	60fb      	str	r3, [r7, #12]
    break;
90002776:	e029      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  case  AUDIO_FREQUENCY_22K:
    /* AIF1 Sample Rate = 22.050 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0043);
90002778:	88fb      	ldrh	r3, [r7, #6]
9000277a:	b2db      	uxtb	r3, r3
9000277c:	2243      	movs	r2, #67	; 0x43
9000277e:	f44f 7104 	mov.w	r1, #528	; 0x210
90002782:	4618      	mov	r0, r3
90002784:	f000 f84a 	bl	9000281c <CODEC_IO_Write>
90002788:	4603      	mov	r3, r0
9000278a:	461a      	mov	r2, r3
9000278c:	68fb      	ldr	r3, [r7, #12]
9000278e:	4413      	add	r3, r2
90002790:	60fb      	str	r3, [r7, #12]
    break;
90002792:	e01b      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  case  AUDIO_FREQUENCY_44K:
    /* AIF1 Sample Rate = 44.1 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0073);
90002794:	88fb      	ldrh	r3, [r7, #6]
90002796:	b2db      	uxtb	r3, r3
90002798:	2273      	movs	r2, #115	; 0x73
9000279a:	f44f 7104 	mov.w	r1, #528	; 0x210
9000279e:	4618      	mov	r0, r3
900027a0:	f000 f83c 	bl	9000281c <CODEC_IO_Write>
900027a4:	4603      	mov	r3, r0
900027a6:	461a      	mov	r2, r3
900027a8:	68fb      	ldr	r3, [r7, #12]
900027aa:	4413      	add	r3, r2
900027ac:	60fb      	str	r3, [r7, #12]
    break; 
900027ae:	e00d      	b.n	900027cc <wm8994_SetFrequency+0x198>
    
  default:
    /* AIF1 Sample Rate = 48 (KHz), ratio=256 */ 
    counter += CODEC_IO_Write(DeviceAddr, 0x210, 0x0083);
900027b0:	88fb      	ldrh	r3, [r7, #6]
900027b2:	b2db      	uxtb	r3, r3
900027b4:	2283      	movs	r2, #131	; 0x83
900027b6:	f44f 7104 	mov.w	r1, #528	; 0x210
900027ba:	4618      	mov	r0, r3
900027bc:	f000 f82e 	bl	9000281c <CODEC_IO_Write>
900027c0:	4603      	mov	r3, r0
900027c2:	461a      	mov	r2, r3
900027c4:	68fb      	ldr	r3, [r7, #12]
900027c6:	4413      	add	r3, r2
900027c8:	60fb      	str	r3, [r7, #12]
    break; 
900027ca:	bf00      	nop
  }
  return counter;
900027cc:	68fb      	ldr	r3, [r7, #12]
}
900027ce:	4618      	mov	r0, r3
900027d0:	3710      	adds	r7, #16
900027d2:	46bd      	mov	sp, r7
900027d4:	bd80      	pop	{r7, pc}
900027d6:	bf00      	nop
900027d8:	00017700 	.word	0x00017700

900027dc <wm8994_Reset>:
  * @brief Resets wm8994 registers.
  * @param DeviceAddr: Device address on communication Bus. 
  * @retval 0 if correct communication, else wrong communication
  */
uint32_t wm8994_Reset(uint16_t DeviceAddr)
{
900027dc:	b580      	push	{r7, lr}
900027de:	b084      	sub	sp, #16
900027e0:	af00      	add	r7, sp, #0
900027e2:	4603      	mov	r3, r0
900027e4:	80fb      	strh	r3, [r7, #6]
  uint32_t counter = 0;
900027e6:	2300      	movs	r3, #0
900027e8:	60fb      	str	r3, [r7, #12]
  
  /* Reset Codec by writing in 0x0000 address register */
  counter = CODEC_IO_Write(DeviceAddr, 0x0000, 0x0000);
900027ea:	88fb      	ldrh	r3, [r7, #6]
900027ec:	b2db      	uxtb	r3, r3
900027ee:	2200      	movs	r2, #0
900027f0:	2100      	movs	r1, #0
900027f2:	4618      	mov	r0, r3
900027f4:	f000 f812 	bl	9000281c <CODEC_IO_Write>
900027f8:	4603      	mov	r3, r0
900027fa:	60fb      	str	r3, [r7, #12]
  outputEnabled = 0;
900027fc:	4b05      	ldr	r3, [pc, #20]	; (90002814 <wm8994_Reset+0x38>)
900027fe:	2200      	movs	r2, #0
90002800:	601a      	str	r2, [r3, #0]
  inputEnabled=0;
90002802:	4b05      	ldr	r3, [pc, #20]	; (90002818 <wm8994_Reset+0x3c>)
90002804:	2200      	movs	r2, #0
90002806:	601a      	str	r2, [r3, #0]

  return counter;
90002808:	68fb      	ldr	r3, [r7, #12]
}
9000280a:	4618      	mov	r0, r3
9000280c:	3710      	adds	r7, #16
9000280e:	46bd      	mov	sp, r7
90002810:	bd80      	pop	{r7, pc}
90002812:	bf00      	nop
90002814:	20000060 	.word	0x20000060
90002818:	20000064 	.word	0x20000064

9000281c <CODEC_IO_Write>:
  * @param  Reg: Reg address 
  * @param  Value: Data to be written
  * @retval None
  */
static uint8_t CODEC_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
{
9000281c:	b580      	push	{r7, lr}
9000281e:	b084      	sub	sp, #16
90002820:	af00      	add	r7, sp, #0
90002822:	4603      	mov	r3, r0
90002824:	71fb      	strb	r3, [r7, #7]
90002826:	460b      	mov	r3, r1
90002828:	80bb      	strh	r3, [r7, #4]
9000282a:	4613      	mov	r3, r2
9000282c:	807b      	strh	r3, [r7, #2]
  uint32_t result = 0;
9000282e:	2300      	movs	r3, #0
90002830:	60fb      	str	r3, [r7, #12]
  
 AUDIO_IO_Write(Addr, Reg, Value);
90002832:	887a      	ldrh	r2, [r7, #2]
90002834:	88b9      	ldrh	r1, [r7, #4]
90002836:	79fb      	ldrb	r3, [r7, #7]
90002838:	4618      	mov	r0, r3
9000283a:	f000 f96f 	bl	90002b1c <AUDIO_IO_Write>
#ifdef VERIFY_WRITTENDATA
  /* Verify that the data has been correctly written */
  result = (AUDIO_IO_Read(Addr, Reg) == Value)? 0:1;
#endif /* VERIFY_WRITTENDATA */
  
  return result;
9000283e:	68fb      	ldr	r3, [r7, #12]
90002840:	b2db      	uxtb	r3, r3
}
90002842:	4618      	mov	r0, r3
90002844:	3710      	adds	r7, #16
90002846:	46bd      	mov	sp, r7
90002848:	bd80      	pop	{r7, pc}
	...

9000284c <I2Cx_MspInit>:
  * @brief  Initializes I2C MSP.
  * @param  i2c_handler : I2C handler
  * @retval None
  */
static void I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler)
{
9000284c:	b580      	push	{r7, lr}
9000284e:	b08c      	sub	sp, #48	; 0x30
90002850:	af00      	add	r7, sp, #0
90002852:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure;
  
  if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
90002854:	687b      	ldr	r3, [r7, #4]
90002856:	4a51      	ldr	r2, [pc, #324]	; (9000299c <I2Cx_MspInit+0x150>)
90002858:	4293      	cmp	r3, r2
9000285a:	d14d      	bne.n	900028f8 <I2Cx_MspInit+0xac>
  {
    /* AUDIO and LCD I2C MSP init */

    /*** Configure the GPIOs ***/
    /* Enable GPIO clock */
    DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
9000285c:	4b50      	ldr	r3, [pc, #320]	; (900029a0 <I2Cx_MspInit+0x154>)
9000285e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002860:	4a4f      	ldr	r2, [pc, #316]	; (900029a0 <I2Cx_MspInit+0x154>)
90002862:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90002866:	6313      	str	r3, [r2, #48]	; 0x30
90002868:	4b4d      	ldr	r3, [pc, #308]	; (900029a0 <I2Cx_MspInit+0x154>)
9000286a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000286c:	f003 0380 	and.w	r3, r3, #128	; 0x80
90002870:	61bb      	str	r3, [r7, #24]
90002872:	69bb      	ldr	r3, [r7, #24]

    /* Configure I2C Tx as alternate function */
    gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SCL_PIN;
90002874:	2380      	movs	r3, #128	; 0x80
90002876:	61fb      	str	r3, [r7, #28]
    gpio_init_structure.Mode = GPIO_MODE_AF_OD;
90002878:	2312      	movs	r3, #18
9000287a:	623b      	str	r3, [r7, #32]
    gpio_init_structure.Pull = GPIO_NOPULL;
9000287c:	2300      	movs	r3, #0
9000287e:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Speed = GPIO_SPEED_FAST;
90002880:	2302      	movs	r3, #2
90002882:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
90002884:	2304      	movs	r3, #4
90002886:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
90002888:	f107 031c 	add.w	r3, r7, #28
9000288c:	4619      	mov	r1, r3
9000288e:	4845      	ldr	r0, [pc, #276]	; (900029a4 <I2Cx_MspInit+0x158>)
90002890:	f001 fb3a 	bl	90003f08 <HAL_GPIO_Init>

    /* Configure I2C Rx as alternate function */
    gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
90002894:	f44f 7380 	mov.w	r3, #256	; 0x100
90002898:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
9000289a:	f107 031c 	add.w	r3, r7, #28
9000289e:	4619      	mov	r1, r3
900028a0:	4840      	ldr	r0, [pc, #256]	; (900029a4 <I2Cx_MspInit+0x158>)
900028a2:	f001 fb31 	bl	90003f08 <HAL_GPIO_Init>

    /*** Configure the I2C peripheral ***/
    /* Enable I2C clock */
    DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
900028a6:	4b3e      	ldr	r3, [pc, #248]	; (900029a0 <I2Cx_MspInit+0x154>)
900028a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900028aa:	4a3d      	ldr	r2, [pc, #244]	; (900029a0 <I2Cx_MspInit+0x154>)
900028ac:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
900028b0:	6413      	str	r3, [r2, #64]	; 0x40
900028b2:	4b3b      	ldr	r3, [pc, #236]	; (900029a0 <I2Cx_MspInit+0x154>)
900028b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900028b6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
900028ba:	617b      	str	r3, [r7, #20]
900028bc:	697b      	ldr	r3, [r7, #20]

    /* Force the I2C peripheral clock reset */
    DISCOVERY_AUDIO_I2Cx_FORCE_RESET();
900028be:	4b38      	ldr	r3, [pc, #224]	; (900029a0 <I2Cx_MspInit+0x154>)
900028c0:	6a1b      	ldr	r3, [r3, #32]
900028c2:	4a37      	ldr	r2, [pc, #220]	; (900029a0 <I2Cx_MspInit+0x154>)
900028c4:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
900028c8:	6213      	str	r3, [r2, #32]

    /* Release the I2C peripheral clock reset */
    DISCOVERY_AUDIO_I2Cx_RELEASE_RESET();
900028ca:	4b35      	ldr	r3, [pc, #212]	; (900029a0 <I2Cx_MspInit+0x154>)
900028cc:	6a1b      	ldr	r3, [r3, #32]
900028ce:	4a34      	ldr	r2, [pc, #208]	; (900029a0 <I2Cx_MspInit+0x154>)
900028d0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
900028d4:	6213      	str	r3, [r2, #32]

    /* Enable and set I2Cx Interrupt to a lower priority */
    HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x0F, 0);
900028d6:	2200      	movs	r2, #0
900028d8:	210f      	movs	r1, #15
900028da:	2048      	movs	r0, #72	; 0x48
900028dc:	f001 f891 	bl	90003a02 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_EV_IRQn);
900028e0:	2048      	movs	r0, #72	; 0x48
900028e2:	f001 f8aa 	bl	90003a3a <HAL_NVIC_EnableIRQ>

    /* Enable and set I2Cx Interrupt to a lower priority */
    HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_ER_IRQn, 0x0F, 0);
900028e6:	2200      	movs	r2, #0
900028e8:	210f      	movs	r1, #15
900028ea:	2049      	movs	r0, #73	; 0x49
900028ec:	f001 f889 	bl	90003a02 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_ER_IRQn);
900028f0:	2049      	movs	r0, #73	; 0x49
900028f2:	f001 f8a2 	bl	90003a3a <HAL_NVIC_EnableIRQ>

    /* Enable and set I2Cx Interrupt to a lower priority */
    HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
    HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
  }
}
900028f6:	e04d      	b.n	90002994 <I2Cx_MspInit+0x148>
    DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
900028f8:	4b29      	ldr	r3, [pc, #164]	; (900029a0 <I2Cx_MspInit+0x154>)
900028fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900028fc:	4a28      	ldr	r2, [pc, #160]	; (900029a0 <I2Cx_MspInit+0x154>)
900028fe:	f043 0302 	orr.w	r3, r3, #2
90002902:	6313      	str	r3, [r2, #48]	; 0x30
90002904:	4b26      	ldr	r3, [pc, #152]	; (900029a0 <I2Cx_MspInit+0x154>)
90002906:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002908:	f003 0302 	and.w	r3, r3, #2
9000290c:	613b      	str	r3, [r7, #16]
9000290e:	693b      	ldr	r3, [r7, #16]
    gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
90002910:	f44f 7380 	mov.w	r3, #256	; 0x100
90002914:	61fb      	str	r3, [r7, #28]
    gpio_init_structure.Mode = GPIO_MODE_AF_OD;
90002916:	2312      	movs	r3, #18
90002918:	623b      	str	r3, [r7, #32]
    gpio_init_structure.Pull = GPIO_NOPULL;
9000291a:	2300      	movs	r3, #0
9000291c:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Speed = GPIO_SPEED_FAST;
9000291e:	2302      	movs	r3, #2
90002920:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
90002922:	2304      	movs	r3, #4
90002924:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
90002926:	f107 031c 	add.w	r3, r7, #28
9000292a:	4619      	mov	r1, r3
9000292c:	481e      	ldr	r0, [pc, #120]	; (900029a8 <I2Cx_MspInit+0x15c>)
9000292e:	f001 faeb 	bl	90003f08 <HAL_GPIO_Init>
    gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
90002932:	f44f 7300 	mov.w	r3, #512	; 0x200
90002936:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
90002938:	f107 031c 	add.w	r3, r7, #28
9000293c:	4619      	mov	r1, r3
9000293e:	481a      	ldr	r0, [pc, #104]	; (900029a8 <I2Cx_MspInit+0x15c>)
90002940:	f001 fae2 	bl	90003f08 <HAL_GPIO_Init>
    DISCOVERY_EXT_I2Cx_CLK_ENABLE();
90002944:	4b16      	ldr	r3, [pc, #88]	; (900029a0 <I2Cx_MspInit+0x154>)
90002946:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90002948:	4a15      	ldr	r2, [pc, #84]	; (900029a0 <I2Cx_MspInit+0x154>)
9000294a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
9000294e:	6413      	str	r3, [r2, #64]	; 0x40
90002950:	4b13      	ldr	r3, [pc, #76]	; (900029a0 <I2Cx_MspInit+0x154>)
90002952:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90002954:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
90002958:	60fb      	str	r3, [r7, #12]
9000295a:	68fb      	ldr	r3, [r7, #12]
    DISCOVERY_EXT_I2Cx_FORCE_RESET();
9000295c:	4b10      	ldr	r3, [pc, #64]	; (900029a0 <I2Cx_MspInit+0x154>)
9000295e:	6a1b      	ldr	r3, [r3, #32]
90002960:	4a0f      	ldr	r2, [pc, #60]	; (900029a0 <I2Cx_MspInit+0x154>)
90002962:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
90002966:	6213      	str	r3, [r2, #32]
    DISCOVERY_EXT_I2Cx_RELEASE_RESET();
90002968:	4b0d      	ldr	r3, [pc, #52]	; (900029a0 <I2Cx_MspInit+0x154>)
9000296a:	6a1b      	ldr	r3, [r3, #32]
9000296c:	4a0c      	ldr	r2, [pc, #48]	; (900029a0 <I2Cx_MspInit+0x154>)
9000296e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
90002972:	6213      	str	r3, [r2, #32]
    HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
90002974:	2200      	movs	r2, #0
90002976:	210f      	movs	r1, #15
90002978:	201f      	movs	r0, #31
9000297a:	f001 f842 	bl	90003a02 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
9000297e:	201f      	movs	r0, #31
90002980:	f001 f85b 	bl	90003a3a <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
90002984:	2200      	movs	r2, #0
90002986:	210f      	movs	r1, #15
90002988:	2020      	movs	r0, #32
9000298a:	f001 f83a 	bl	90003a02 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
9000298e:	2020      	movs	r0, #32
90002990:	f001 f853 	bl	90003a3a <HAL_NVIC_EnableIRQ>
}
90002994:	bf00      	nop
90002996:	3730      	adds	r7, #48	; 0x30
90002998:	46bd      	mov	sp, r7
9000299a:	bd80      	pop	{r7, pc}
9000299c:	20000068 	.word	0x20000068
900029a0:	40023800 	.word	0x40023800
900029a4:	40021c00 	.word	0x40021c00
900029a8:	40020400 	.word	0x40020400

900029ac <I2Cx_Init>:
  * @brief  Initializes I2C HAL.
  * @param  i2c_handler : I2C handler
  * @retval None
  */
static void I2Cx_Init(I2C_HandleTypeDef *i2c_handler)
{
900029ac:	b580      	push	{r7, lr}
900029ae:	b082      	sub	sp, #8
900029b0:	af00      	add	r7, sp, #0
900029b2:	6078      	str	r0, [r7, #4]
  if(HAL_I2C_GetState(i2c_handler) == HAL_I2C_STATE_RESET)
900029b4:	6878      	ldr	r0, [r7, #4]
900029b6:	f001 ff89 	bl	900048cc <HAL_I2C_GetState>
900029ba:	4603      	mov	r3, r0
900029bc:	2b00      	cmp	r3, #0
900029be:	d125      	bne.n	90002a0c <I2Cx_Init+0x60>
  {
    if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
900029c0:	687b      	ldr	r3, [r7, #4]
900029c2:	4a14      	ldr	r2, [pc, #80]	; (90002a14 <I2Cx_Init+0x68>)
900029c4:	4293      	cmp	r3, r2
900029c6:	d103      	bne.n	900029d0 <I2Cx_Init+0x24>
    {
      /* Audio and LCD I2C configuration */
      i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
900029c8:	687b      	ldr	r3, [r7, #4]
900029ca:	4a13      	ldr	r2, [pc, #76]	; (90002a18 <I2Cx_Init+0x6c>)
900029cc:	601a      	str	r2, [r3, #0]
900029ce:	e002      	b.n	900029d6 <I2Cx_Init+0x2a>
    }
    else
    {
      /* External, camera and Arduino connector  I2C configuration */
      i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
900029d0:	687b      	ldr	r3, [r7, #4]
900029d2:	4a12      	ldr	r2, [pc, #72]	; (90002a1c <I2Cx_Init+0x70>)
900029d4:	601a      	str	r2, [r3, #0]
    }
    i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
900029d6:	687b      	ldr	r3, [r7, #4]
900029d8:	4a11      	ldr	r2, [pc, #68]	; (90002a20 <I2Cx_Init+0x74>)
900029da:	605a      	str	r2, [r3, #4]
    i2c_handler->Init.OwnAddress1      = 0;
900029dc:	687b      	ldr	r3, [r7, #4]
900029de:	2200      	movs	r2, #0
900029e0:	609a      	str	r2, [r3, #8]
    i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
900029e2:	687b      	ldr	r3, [r7, #4]
900029e4:	2201      	movs	r2, #1
900029e6:	60da      	str	r2, [r3, #12]
    i2c_handler->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
900029e8:	687b      	ldr	r3, [r7, #4]
900029ea:	2200      	movs	r2, #0
900029ec:	611a      	str	r2, [r3, #16]
    i2c_handler->Init.OwnAddress2      = 0;
900029ee:	687b      	ldr	r3, [r7, #4]
900029f0:	2200      	movs	r2, #0
900029f2:	615a      	str	r2, [r3, #20]
    i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
900029f4:	687b      	ldr	r3, [r7, #4]
900029f6:	2200      	movs	r2, #0
900029f8:	61da      	str	r2, [r3, #28]
    i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
900029fa:	687b      	ldr	r3, [r7, #4]
900029fc:	2200      	movs	r2, #0
900029fe:	621a      	str	r2, [r3, #32]

    /* Init the I2C */
    I2Cx_MspInit(i2c_handler);
90002a00:	6878      	ldr	r0, [r7, #4]
90002a02:	f7ff ff23 	bl	9000284c <I2Cx_MspInit>
    HAL_I2C_Init(i2c_handler);
90002a06:	6878      	ldr	r0, [r7, #4]
90002a08:	f001 fc5e 	bl	900042c8 <HAL_I2C_Init>
  }
}
90002a0c:	bf00      	nop
90002a0e:	3708      	adds	r7, #8
90002a10:	46bd      	mov	sp, r7
90002a12:	bd80      	pop	{r7, pc}
90002a14:	20000068 	.word	0x20000068
90002a18:	40005c00 	.word	0x40005c00
90002a1c:	40005400 	.word	0x40005400
90002a20:	40912732 	.word	0x40912732

90002a24 <I2Cx_ReadMultiple>:
                                           uint8_t Addr,
                                           uint16_t Reg,
                                           uint16_t MemAddress,
                                           uint8_t *Buffer,
                                           uint16_t Length)
{
90002a24:	b580      	push	{r7, lr}
90002a26:	b08a      	sub	sp, #40	; 0x28
90002a28:	af04      	add	r7, sp, #16
90002a2a:	60f8      	str	r0, [r7, #12]
90002a2c:	4608      	mov	r0, r1
90002a2e:	4611      	mov	r1, r2
90002a30:	461a      	mov	r2, r3
90002a32:	4603      	mov	r3, r0
90002a34:	72fb      	strb	r3, [r7, #11]
90002a36:	460b      	mov	r3, r1
90002a38:	813b      	strh	r3, [r7, #8]
90002a3a:	4613      	mov	r3, r2
90002a3c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef status = HAL_OK;
90002a3e:	2300      	movs	r3, #0
90002a40:	75fb      	strb	r3, [r7, #23]

  status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
90002a42:	7afb      	ldrb	r3, [r7, #11]
90002a44:	b299      	uxth	r1, r3
90002a46:	88f8      	ldrh	r0, [r7, #6]
90002a48:	893a      	ldrh	r2, [r7, #8]
90002a4a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90002a4e:	9302      	str	r3, [sp, #8]
90002a50:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
90002a52:	9301      	str	r3, [sp, #4]
90002a54:	6a3b      	ldr	r3, [r7, #32]
90002a56:	9300      	str	r3, [sp, #0]
90002a58:	4603      	mov	r3, r0
90002a5a:	68f8      	ldr	r0, [r7, #12]
90002a5c:	f001 fe1c 	bl	90004698 <HAL_I2C_Mem_Read>
90002a60:	4603      	mov	r3, r0
90002a62:	75fb      	strb	r3, [r7, #23]

  /* Check the communication status */
  if(status != HAL_OK)
90002a64:	7dfb      	ldrb	r3, [r7, #23]
90002a66:	2b00      	cmp	r3, #0
90002a68:	d004      	beq.n	90002a74 <I2Cx_ReadMultiple+0x50>
  {
    /* I2C error occurred */
    I2Cx_Error(i2c_handler, Addr);
90002a6a:	7afb      	ldrb	r3, [r7, #11]
90002a6c:	4619      	mov	r1, r3
90002a6e:	68f8      	ldr	r0, [r7, #12]
90002a70:	f000 f832 	bl	90002ad8 <I2Cx_Error>
  }
  return status;    
90002a74:	7dfb      	ldrb	r3, [r7, #23]
}
90002a76:	4618      	mov	r0, r3
90002a78:	3718      	adds	r7, #24
90002a7a:	46bd      	mov	sp, r7
90002a7c:	bd80      	pop	{r7, pc}

90002a7e <I2Cx_WriteMultiple>:
                                            uint8_t Addr,
                                            uint16_t Reg,
                                            uint16_t MemAddress,
                                            uint8_t *Buffer,
                                            uint16_t Length)
{
90002a7e:	b580      	push	{r7, lr}
90002a80:	b08a      	sub	sp, #40	; 0x28
90002a82:	af04      	add	r7, sp, #16
90002a84:	60f8      	str	r0, [r7, #12]
90002a86:	4608      	mov	r0, r1
90002a88:	4611      	mov	r1, r2
90002a8a:	461a      	mov	r2, r3
90002a8c:	4603      	mov	r3, r0
90002a8e:	72fb      	strb	r3, [r7, #11]
90002a90:	460b      	mov	r3, r1
90002a92:	813b      	strh	r3, [r7, #8]
90002a94:	4613      	mov	r3, r2
90002a96:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef status = HAL_OK;
90002a98:	2300      	movs	r3, #0
90002a9a:	75fb      	strb	r3, [r7, #23]
  
  status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
90002a9c:	7afb      	ldrb	r3, [r7, #11]
90002a9e:	b299      	uxth	r1, r3
90002aa0:	88f8      	ldrh	r0, [r7, #6]
90002aa2:	893a      	ldrh	r2, [r7, #8]
90002aa4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90002aa8:	9302      	str	r3, [sp, #8]
90002aaa:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
90002aac:	9301      	str	r3, [sp, #4]
90002aae:	6a3b      	ldr	r3, [r7, #32]
90002ab0:	9300      	str	r3, [sp, #0]
90002ab2:	4603      	mov	r3, r0
90002ab4:	68f8      	ldr	r0, [r7, #12]
90002ab6:	f001 fcdb 	bl	90004470 <HAL_I2C_Mem_Write>
90002aba:	4603      	mov	r3, r0
90002abc:	75fb      	strb	r3, [r7, #23]
  
  /* Check the communication status */
  if(status != HAL_OK)
90002abe:	7dfb      	ldrb	r3, [r7, #23]
90002ac0:	2b00      	cmp	r3, #0
90002ac2:	d004      	beq.n	90002ace <I2Cx_WriteMultiple+0x50>
  {
    /* Re-Initiaize the I2C Bus */
    I2Cx_Error(i2c_handler, Addr);
90002ac4:	7afb      	ldrb	r3, [r7, #11]
90002ac6:	4619      	mov	r1, r3
90002ac8:	68f8      	ldr	r0, [r7, #12]
90002aca:	f000 f805 	bl	90002ad8 <I2Cx_Error>
  }
  return status;
90002ace:	7dfb      	ldrb	r3, [r7, #23]
}
90002ad0:	4618      	mov	r0, r3
90002ad2:	3718      	adds	r7, #24
90002ad4:	46bd      	mov	sp, r7
90002ad6:	bd80      	pop	{r7, pc}

90002ad8 <I2Cx_Error>:
  * @param  i2c_handler : I2C handler
  * @param  Addr: I2C Address
  * @retval None
  */
static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
{
90002ad8:	b580      	push	{r7, lr}
90002ada:	b082      	sub	sp, #8
90002adc:	af00      	add	r7, sp, #0
90002ade:	6078      	str	r0, [r7, #4]
90002ae0:	460b      	mov	r3, r1
90002ae2:	70fb      	strb	r3, [r7, #3]
  /* De-initialize the I2C communication bus */
  HAL_I2C_DeInit(i2c_handler);
90002ae4:	6878      	ldr	r0, [r7, #4]
90002ae6:	f001 fc7f 	bl	900043e8 <HAL_I2C_DeInit>
  
  /* Re-Initialize the I2C communication bus */
  I2Cx_Init(i2c_handler);
90002aea:	6878      	ldr	r0, [r7, #4]
90002aec:	f7ff ff5e 	bl	900029ac <I2Cx_Init>
}
90002af0:	bf00      	nop
90002af2:	3708      	adds	r7, #8
90002af4:	46bd      	mov	sp, r7
90002af6:	bd80      	pop	{r7, pc}

90002af8 <AUDIO_IO_Init>:
/**
  * @brief  Initializes Audio low level.
  * @retval None
  */
void AUDIO_IO_Init(void) 
{
90002af8:	b580      	push	{r7, lr}
90002afa:	af00      	add	r7, sp, #0
  I2Cx_Init(&hI2cAudioHandler);
90002afc:	4802      	ldr	r0, [pc, #8]	; (90002b08 <AUDIO_IO_Init+0x10>)
90002afe:	f7ff ff55 	bl	900029ac <I2Cx_Init>
}
90002b02:	bf00      	nop
90002b04:	bd80      	pop	{r7, pc}
90002b06:	bf00      	nop
90002b08:	20000068 	.word	0x20000068

90002b0c <AUDIO_IO_DeInit>:
/**
  * @brief  Deinitializes Audio low level.
  * @retval None
  */
void AUDIO_IO_DeInit(void)
{
90002b0c:	b480      	push	{r7}
90002b0e:	af00      	add	r7, sp, #0
}
90002b10:	bf00      	nop
90002b12:	46bd      	mov	sp, r7
90002b14:	f85d 7b04 	ldr.w	r7, [sp], #4
90002b18:	4770      	bx	lr
	...

90002b1c <AUDIO_IO_Write>:
  * @param  Reg: Reg address 
  * @param  Value: Data to be written
  * @retval None
  */
void AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
{
90002b1c:	b580      	push	{r7, lr}
90002b1e:	b086      	sub	sp, #24
90002b20:	af02      	add	r7, sp, #8
90002b22:	4603      	mov	r3, r0
90002b24:	71fb      	strb	r3, [r7, #7]
90002b26:	460b      	mov	r3, r1
90002b28:	80bb      	strh	r3, [r7, #4]
90002b2a:	4613      	mov	r3, r2
90002b2c:	807b      	strh	r3, [r7, #2]
  uint16_t tmp = Value;
90002b2e:	887b      	ldrh	r3, [r7, #2]
90002b30:	81fb      	strh	r3, [r7, #14]
  
  Value = ((uint16_t)(tmp >> 8) & 0x00FF);
90002b32:	89fb      	ldrh	r3, [r7, #14]
90002b34:	0a1b      	lsrs	r3, r3, #8
90002b36:	b29b      	uxth	r3, r3
90002b38:	807b      	strh	r3, [r7, #2]
  
  Value |= ((uint16_t)(tmp << 8)& 0xFF00);
90002b3a:	89fb      	ldrh	r3, [r7, #14]
90002b3c:	021b      	lsls	r3, r3, #8
90002b3e:	b29b      	uxth	r3, r3
90002b40:	b21a      	sxth	r2, r3
90002b42:	887b      	ldrh	r3, [r7, #2]
90002b44:	b21b      	sxth	r3, r3
90002b46:	4313      	orrs	r3, r2
90002b48:	b21b      	sxth	r3, r3
90002b4a:	b29b      	uxth	r3, r3
90002b4c:	807b      	strh	r3, [r7, #2]
  
  I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
90002b4e:	88ba      	ldrh	r2, [r7, #4]
90002b50:	79f9      	ldrb	r1, [r7, #7]
90002b52:	2302      	movs	r3, #2
90002b54:	9301      	str	r3, [sp, #4]
90002b56:	1cbb      	adds	r3, r7, #2
90002b58:	9300      	str	r3, [sp, #0]
90002b5a:	2302      	movs	r3, #2
90002b5c:	4803      	ldr	r0, [pc, #12]	; (90002b6c <AUDIO_IO_Write+0x50>)
90002b5e:	f7ff ff8e 	bl	90002a7e <I2Cx_WriteMultiple>
}
90002b62:	bf00      	nop
90002b64:	3710      	adds	r7, #16
90002b66:	46bd      	mov	sp, r7
90002b68:	bd80      	pop	{r7, pc}
90002b6a:	bf00      	nop
90002b6c:	20000068 	.word	0x20000068

90002b70 <AUDIO_IO_Read>:
  * @param  Addr: I2C address
  * @param  Reg: Reg address 
  * @retval Data to be read
  */
uint16_t AUDIO_IO_Read(uint8_t Addr, uint16_t Reg)
{
90002b70:	b580      	push	{r7, lr}
90002b72:	b086      	sub	sp, #24
90002b74:	af02      	add	r7, sp, #8
90002b76:	4603      	mov	r3, r0
90002b78:	460a      	mov	r2, r1
90002b7a:	71fb      	strb	r3, [r7, #7]
90002b7c:	4613      	mov	r3, r2
90002b7e:	80bb      	strh	r3, [r7, #4]
  uint16_t read_value = 0, tmp = 0;
90002b80:	2300      	movs	r3, #0
90002b82:	81bb      	strh	r3, [r7, #12]
90002b84:	2300      	movs	r3, #0
90002b86:	81fb      	strh	r3, [r7, #14]
  
  I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
90002b88:	88ba      	ldrh	r2, [r7, #4]
90002b8a:	79f9      	ldrb	r1, [r7, #7]
90002b8c:	2302      	movs	r3, #2
90002b8e:	9301      	str	r3, [sp, #4]
90002b90:	f107 030c 	add.w	r3, r7, #12
90002b94:	9300      	str	r3, [sp, #0]
90002b96:	2302      	movs	r3, #2
90002b98:	480a      	ldr	r0, [pc, #40]	; (90002bc4 <AUDIO_IO_Read+0x54>)
90002b9a:	f7ff ff43 	bl	90002a24 <I2Cx_ReadMultiple>
  
  tmp = ((uint16_t)(read_value >> 8) & 0x00FF);
90002b9e:	89bb      	ldrh	r3, [r7, #12]
90002ba0:	0a1b      	lsrs	r3, r3, #8
90002ba2:	81fb      	strh	r3, [r7, #14]
  
  tmp |= ((uint16_t)(read_value << 8)& 0xFF00);
90002ba4:	89bb      	ldrh	r3, [r7, #12]
90002ba6:	021b      	lsls	r3, r3, #8
90002ba8:	b29b      	uxth	r3, r3
90002baa:	b21a      	sxth	r2, r3
90002bac:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
90002bb0:	4313      	orrs	r3, r2
90002bb2:	b21b      	sxth	r3, r3
90002bb4:	81fb      	strh	r3, [r7, #14]
  
  read_value = tmp;
90002bb6:	89fb      	ldrh	r3, [r7, #14]
90002bb8:	81bb      	strh	r3, [r7, #12]
  
  return read_value;
90002bba:	89bb      	ldrh	r3, [r7, #12]
}
90002bbc:	4618      	mov	r0, r3
90002bbe:	3710      	adds	r7, #16
90002bc0:	46bd      	mov	sp, r7
90002bc2:	bd80      	pop	{r7, pc}
90002bc4:	20000068 	.word	0x20000068

90002bc8 <AUDIO_IO_Delay>:
  * @brief  AUDIO Codec delay 
  * @param  Delay: Delay in ms
  * @retval None
  */
void AUDIO_IO_Delay(uint32_t Delay)
{
90002bc8:	b580      	push	{r7, lr}
90002bca:	b082      	sub	sp, #8
90002bcc:	af00      	add	r7, sp, #0
90002bce:	6078      	str	r0, [r7, #4]
  HAL_Delay(Delay);
90002bd0:	6878      	ldr	r0, [r7, #4]
90002bd2:	f000 fe17 	bl	90003804 <HAL_Delay>
}
90002bd6:	bf00      	nop
90002bd8:	3708      	adds	r7, #8
90002bda:	46bd      	mov	sp, r7
90002bdc:	bd80      	pop	{r7, pc}
	...

90002be0 <BSP_AUDIO_OUT_Play>:
  * @param  Size: Number of audio data in BYTES unit.
  *         In memory, first element is for left channel, second element is for right channel
  * @retval AUDIO_OK if correct communication, else wrong communication
  */
uint8_t BSP_AUDIO_OUT_Play(uint16_t* pBuffer, uint32_t Size)
{
90002be0:	b580      	push	{r7, lr}
90002be2:	b082      	sub	sp, #8
90002be4:	af00      	add	r7, sp, #0
90002be6:	6078      	str	r0, [r7, #4]
90002be8:	6039      	str	r1, [r7, #0]
  /* Call the audio Codec Play function */
  if(audio_drv->Play(AUDIO_I2C_ADDRESS, pBuffer, Size) != 0)
90002bea:	4b10      	ldr	r3, [pc, #64]	; (90002c2c <BSP_AUDIO_OUT_Play+0x4c>)
90002bec:	681b      	ldr	r3, [r3, #0]
90002bee:	68db      	ldr	r3, [r3, #12]
90002bf0:	683a      	ldr	r2, [r7, #0]
90002bf2:	b292      	uxth	r2, r2
90002bf4:	6879      	ldr	r1, [r7, #4]
90002bf6:	2034      	movs	r0, #52	; 0x34
90002bf8:	4798      	blx	r3
90002bfa:	4603      	mov	r3, r0
90002bfc:	2b00      	cmp	r3, #0
90002bfe:	d001      	beq.n	90002c04 <BSP_AUDIO_OUT_Play+0x24>
  {  
    return AUDIO_ERROR;
90002c00:	2301      	movs	r3, #1
90002c02:	e00f      	b.n	90002c24 <BSP_AUDIO_OUT_Play+0x44>
  }
  else
  {
    /* Update the Media layer and enable it for play */  
    HAL_SAI_Transmit_DMA(&haudio_out_sai, (uint8_t*) pBuffer, DMA_MAX(Size / AUDIODATA_SIZE));
90002c04:	683b      	ldr	r3, [r7, #0]
90002c06:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90002c0a:	d203      	bcs.n	90002c14 <BSP_AUDIO_OUT_Play+0x34>
90002c0c:	683b      	ldr	r3, [r7, #0]
90002c0e:	085b      	lsrs	r3, r3, #1
90002c10:	b29b      	uxth	r3, r3
90002c12:	e001      	b.n	90002c18 <BSP_AUDIO_OUT_Play+0x38>
90002c14:	f64f 73ff 	movw	r3, #65535	; 0xffff
90002c18:	461a      	mov	r2, r3
90002c1a:	6879      	ldr	r1, [r7, #4]
90002c1c:	4804      	ldr	r0, [pc, #16]	; (90002c30 <BSP_AUDIO_OUT_Play+0x50>)
90002c1e:	f003 fd1d 	bl	9000665c <HAL_SAI_Transmit_DMA>
    
    return AUDIO_OK;
90002c22:	2300      	movs	r3, #0
  }
}
90002c24:	4618      	mov	r0, r3
90002c26:	3708      	adds	r7, #8
90002c28:	46bd      	mov	sp, r7
90002c2a:	bd80      	pop	{r7, pc}
90002c2c:	20000354 	.word	0x20000354
90002c30:	200000b4 	.word	0x200000b4

90002c34 <BSP_AUDIO_OUT_SetAudioFrameSlot>:
  * @note   This API should be called after the BSP_AUDIO_OUT_Init() to adjust the
  *         audio frame slot.
  * @retval None
  */
void BSP_AUDIO_OUT_SetAudioFrameSlot(uint32_t AudioFrameSlot)
{ 
90002c34:	b580      	push	{r7, lr}
90002c36:	b082      	sub	sp, #8
90002c38:	af00      	add	r7, sp, #0
90002c3a:	6078      	str	r0, [r7, #4]
  /* Disable SAI peripheral to allow access to SAI internal registers */
  __HAL_SAI_DISABLE(&haudio_out_sai);
90002c3c:	4b0c      	ldr	r3, [pc, #48]	; (90002c70 <BSP_AUDIO_OUT_SetAudioFrameSlot+0x3c>)
90002c3e:	681b      	ldr	r3, [r3, #0]
90002c40:	681a      	ldr	r2, [r3, #0]
90002c42:	4b0b      	ldr	r3, [pc, #44]	; (90002c70 <BSP_AUDIO_OUT_SetAudioFrameSlot+0x3c>)
90002c44:	681b      	ldr	r3, [r3, #0]
90002c46:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
90002c4a:	601a      	str	r2, [r3, #0]
  
  /* Update the SAI audio frame slot configuration */
  haudio_out_sai.SlotInit.SlotActive = AudioFrameSlot;
90002c4c:	4a08      	ldr	r2, [pc, #32]	; (90002c70 <BSP_AUDIO_OUT_SetAudioFrameSlot+0x3c>)
90002c4e:	687b      	ldr	r3, [r7, #4]
90002c50:	6613      	str	r3, [r2, #96]	; 0x60
  HAL_SAI_Init(&haudio_out_sai);
90002c52:	4807      	ldr	r0, [pc, #28]	; (90002c70 <BSP_AUDIO_OUT_SetAudioFrameSlot+0x3c>)
90002c54:	f003 fb3a 	bl	900062cc <HAL_SAI_Init>
  
  /* Enable SAI peripheral to generate MCLK */
  __HAL_SAI_ENABLE(&haudio_out_sai);
90002c58:	4b05      	ldr	r3, [pc, #20]	; (90002c70 <BSP_AUDIO_OUT_SetAudioFrameSlot+0x3c>)
90002c5a:	681b      	ldr	r3, [r3, #0]
90002c5c:	681a      	ldr	r2, [r3, #0]
90002c5e:	4b04      	ldr	r3, [pc, #16]	; (90002c70 <BSP_AUDIO_OUT_SetAudioFrameSlot+0x3c>)
90002c60:	681b      	ldr	r3, [r3, #0]
90002c62:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90002c66:	601a      	str	r2, [r3, #0]
}
90002c68:	bf00      	nop
90002c6a:	3708      	adds	r7, #8
90002c6c:	46bd      	mov	sp, r7
90002c6e:	bd80      	pop	{r7, pc}
90002c70:	200000b4 	.word	0x200000b4

90002c74 <HAL_SAI_TxCpltCallback>:
  * @brief  Tx Transfer completed callbacks.
  * @param  hsai: SAI handle
  * @retval None
  */
void HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
{
90002c74:	b580      	push	{r7, lr}
90002c76:	b082      	sub	sp, #8
90002c78:	af00      	add	r7, sp, #0
90002c7a:	6078      	str	r0, [r7, #4]
  /* Manage the remaining file size and new address offset: This function 
     should be coded by user (its prototype is already declared in stm32f7508_discovery_audio.h) */
  BSP_AUDIO_OUT_TransferComplete_CallBack();
90002c7c:	f000 f834 	bl	90002ce8 <BSP_AUDIO_OUT_TransferComplete_CallBack>
}
90002c80:	bf00      	nop
90002c82:	3708      	adds	r7, #8
90002c84:	46bd      	mov	sp, r7
90002c86:	bd80      	pop	{r7, pc}

90002c88 <HAL_SAI_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callbacks.
  * @param  hsai: SAI handle
  * @retval None
  */
void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
90002c88:	b580      	push	{r7, lr}
90002c8a:	b082      	sub	sp, #8
90002c8c:	af00      	add	r7, sp, #0
90002c8e:	6078      	str	r0, [r7, #4]
  /* Manage the remaining file size and new address offset: This function 
     should be coded by user (its prototype is already declared in stm32f7508_discovery_audio.h) */
  BSP_AUDIO_OUT_HalfTransfer_CallBack();
90002c90:	f000 f831 	bl	90002cf6 <BSP_AUDIO_OUT_HalfTransfer_CallBack>
}
90002c94:	bf00      	nop
90002c96:	3708      	adds	r7, #8
90002c98:	46bd      	mov	sp, r7
90002c9a:	bd80      	pop	{r7, pc}

90002c9c <HAL_SAI_ErrorCallback>:
  * @brief  SAI error callbacks.
  * @param  hsai: SAI handle
  * @retval None
  */
void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
90002c9c:	b580      	push	{r7, lr}
90002c9e:	b084      	sub	sp, #16
90002ca0:	af00      	add	r7, sp, #0
90002ca2:	6078      	str	r0, [r7, #4]
  HAL_SAI_StateTypeDef audio_out_state;
  HAL_SAI_StateTypeDef audio_in_state;

  audio_out_state = HAL_SAI_GetState(&haudio_out_sai);
90002ca4:	480e      	ldr	r0, [pc, #56]	; (90002ce0 <HAL_SAI_ErrorCallback+0x44>)
90002ca6:	f003 fe17 	bl	900068d8 <HAL_SAI_GetState>
90002caa:	4603      	mov	r3, r0
90002cac:	73fb      	strb	r3, [r7, #15]
  audio_in_state = HAL_SAI_GetState(&haudio_in_sai);
90002cae:	480d      	ldr	r0, [pc, #52]	; (90002ce4 <HAL_SAI_ErrorCallback+0x48>)
90002cb0:	f003 fe12 	bl	900068d8 <HAL_SAI_GetState>
90002cb4:	4603      	mov	r3, r0
90002cb6:	73bb      	strb	r3, [r7, #14]

  /* Determines if it is an audio out or audio in error */
  if ((audio_out_state == HAL_SAI_STATE_BUSY) || (audio_out_state == HAL_SAI_STATE_BUSY_TX))
90002cb8:	7bfb      	ldrb	r3, [r7, #15]
90002cba:	2b02      	cmp	r3, #2
90002cbc:	d002      	beq.n	90002cc4 <HAL_SAI_ErrorCallback+0x28>
90002cbe:	7bfb      	ldrb	r3, [r7, #15]
90002cc0:	2b12      	cmp	r3, #18
90002cc2:	d101      	bne.n	90002cc8 <HAL_SAI_ErrorCallback+0x2c>
  {
    BSP_AUDIO_OUT_Error_CallBack();
90002cc4:	f000 f81e 	bl	90002d04 <BSP_AUDIO_OUT_Error_CallBack>
  }

  if ((audio_in_state == HAL_SAI_STATE_BUSY) || (audio_in_state == HAL_SAI_STATE_BUSY_RX))
90002cc8:	7bbb      	ldrb	r3, [r7, #14]
90002cca:	2b02      	cmp	r3, #2
90002ccc:	d002      	beq.n	90002cd4 <HAL_SAI_ErrorCallback+0x38>
90002cce:	7bbb      	ldrb	r3, [r7, #14]
90002cd0:	2b22      	cmp	r3, #34	; 0x22
90002cd2:	d101      	bne.n	90002cd8 <HAL_SAI_ErrorCallback+0x3c>
  {
    BSP_AUDIO_IN_Error_CallBack();
90002cd4:	f000 f9f4 	bl	900030c0 <BSP_AUDIO_IN_Error_CallBack>
  }
}
90002cd8:	bf00      	nop
90002cda:	3710      	adds	r7, #16
90002cdc:	46bd      	mov	sp, r7
90002cde:	bd80      	pop	{r7, pc}
90002ce0:	200000b4 	.word	0x200000b4
90002ce4:	20000138 	.word	0x20000138

90002ce8 <BSP_AUDIO_OUT_TransferComplete_CallBack>:
/**
  * @brief  Manages the DMA full Transfer complete event.
  * @retval None
  */
__weak void BSP_AUDIO_OUT_TransferComplete_CallBack(void)
{
90002ce8:	b480      	push	{r7}
90002cea:	af00      	add	r7, sp, #0
}
90002cec:	bf00      	nop
90002cee:	46bd      	mov	sp, r7
90002cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
90002cf4:	4770      	bx	lr

90002cf6 <BSP_AUDIO_OUT_HalfTransfer_CallBack>:
/**
  * @brief  Manages the DMA Half Transfer complete event.
  * @retval None
  */
__weak void BSP_AUDIO_OUT_HalfTransfer_CallBack(void)
{ 
90002cf6:	b480      	push	{r7}
90002cf8:	af00      	add	r7, sp, #0
}
90002cfa:	bf00      	nop
90002cfc:	46bd      	mov	sp, r7
90002cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
90002d02:	4770      	bx	lr

90002d04 <BSP_AUDIO_OUT_Error_CallBack>:
/**
  * @brief  Manages the DMA FIFO error event.
  * @retval None
  */
__weak void BSP_AUDIO_OUT_Error_CallBack(void)
{
90002d04:	b480      	push	{r7}
90002d06:	af00      	add	r7, sp, #0
}
90002d08:	bf00      	nop
90002d0a:	46bd      	mov	sp, r7
90002d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
90002d10:	4770      	bx	lr
	...

90002d14 <BSP_AUDIO_OUT_MspInit>:
  * @param  hsai: SAI handle
  * @param  Params
  * @retval None
  */
__weak void BSP_AUDIO_OUT_MspInit(SAI_HandleTypeDef *hsai, void *Params)
{ 
90002d14:	b580      	push	{r7, lr}
90002d16:	b08c      	sub	sp, #48	; 0x30
90002d18:	af00      	add	r7, sp, #0
90002d1a:	6078      	str	r0, [r7, #4]
90002d1c:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef hdma_sai_tx;
  GPIO_InitTypeDef  gpio_init_structure;  

  /* Enable SAI clock */
  AUDIO_OUT_SAIx_CLK_ENABLE();
90002d1e:	4b63      	ldr	r3, [pc, #396]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d20:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90002d22:	4a62      	ldr	r2, [pc, #392]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d24:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
90002d28:	6453      	str	r3, [r2, #68]	; 0x44
90002d2a:	4b60      	ldr	r3, [pc, #384]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d2c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90002d2e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
90002d32:	61bb      	str	r3, [r7, #24]
90002d34:	69bb      	ldr	r3, [r7, #24]
  
  /* Enable GPIO clock */
  AUDIO_OUT_SAIx_MCLK_ENABLE();
90002d36:	4b5d      	ldr	r3, [pc, #372]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002d3a:	4a5c      	ldr	r2, [pc, #368]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d3c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90002d40:	6313      	str	r3, [r2, #48]	; 0x30
90002d42:	4b5a      	ldr	r3, [pc, #360]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002d46:	f403 7380 	and.w	r3, r3, #256	; 0x100
90002d4a:	617b      	str	r3, [r7, #20]
90002d4c:	697b      	ldr	r3, [r7, #20]
  AUDIO_OUT_SAIx_SCK_SD_ENABLE();
90002d4e:	4b57      	ldr	r3, [pc, #348]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002d52:	4a56      	ldr	r2, [pc, #344]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d54:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90002d58:	6313      	str	r3, [r2, #48]	; 0x30
90002d5a:	4b54      	ldr	r3, [pc, #336]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002d5e:	f403 7380 	and.w	r3, r3, #256	; 0x100
90002d62:	613b      	str	r3, [r7, #16]
90002d64:	693b      	ldr	r3, [r7, #16]
  AUDIO_OUT_SAIx_FS_ENABLE();
90002d66:	4b51      	ldr	r3, [pc, #324]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002d6a:	4a50      	ldr	r2, [pc, #320]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d6c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90002d70:	6313      	str	r3, [r2, #48]	; 0x30
90002d72:	4b4e      	ldr	r3, [pc, #312]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002d74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002d76:	f403 7380 	and.w	r3, r3, #256	; 0x100
90002d7a:	60fb      	str	r3, [r7, #12]
90002d7c:	68fb      	ldr	r3, [r7, #12]
  /* CODEC_SAI pins configuration: FS, SCK, MCK and SD pins ------------------*/
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_FS_PIN;
90002d7e:	2380      	movs	r3, #128	; 0x80
90002d80:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
90002d82:	2302      	movs	r3, #2
90002d84:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
90002d86:	2300      	movs	r3, #0
90002d88:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
90002d8a:	2303      	movs	r3, #3
90002d8c:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
90002d8e:	230a      	movs	r3, #10
90002d90:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_FS_GPIO_PORT, &gpio_init_structure);
90002d92:	f107 031c 	add.w	r3, r7, #28
90002d96:	4619      	mov	r1, r3
90002d98:	4845      	ldr	r0, [pc, #276]	; (90002eb0 <BSP_AUDIO_OUT_MspInit+0x19c>)
90002d9a:	f001 f8b5 	bl	90003f08 <HAL_GPIO_Init>

  gpio_init_structure.Pin = AUDIO_OUT_SAIx_SCK_PIN;
90002d9e:	2320      	movs	r3, #32
90002da0:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
90002da2:	2302      	movs	r3, #2
90002da4:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
90002da6:	2300      	movs	r3, #0
90002da8:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
90002daa:	2303      	movs	r3, #3
90002dac:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_SCK_AF;
90002dae:	230a      	movs	r3, #10
90002db0:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
90002db2:	f107 031c 	add.w	r3, r7, #28
90002db6:	4619      	mov	r1, r3
90002db8:	483d      	ldr	r0, [pc, #244]	; (90002eb0 <BSP_AUDIO_OUT_MspInit+0x19c>)
90002dba:	f001 f8a5 	bl	90003f08 <HAL_GPIO_Init>

  gpio_init_structure.Pin =  AUDIO_OUT_SAIx_SD_PIN;
90002dbe:	2340      	movs	r3, #64	; 0x40
90002dc0:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
90002dc2:	2302      	movs	r3, #2
90002dc4:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
90002dc6:	2300      	movs	r3, #0
90002dc8:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
90002dca:	2303      	movs	r3, #3
90002dcc:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
90002dce:	230a      	movs	r3, #10
90002dd0:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_SD_GPIO_PORT, &gpio_init_structure);
90002dd2:	f107 031c 	add.w	r3, r7, #28
90002dd6:	4619      	mov	r1, r3
90002dd8:	4835      	ldr	r0, [pc, #212]	; (90002eb0 <BSP_AUDIO_OUT_MspInit+0x19c>)
90002dda:	f001 f895 	bl	90003f08 <HAL_GPIO_Init>

  gpio_init_structure.Pin = AUDIO_OUT_SAIx_MCLK_PIN;
90002dde:	2310      	movs	r3, #16
90002de0:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
90002de2:	2302      	movs	r3, #2
90002de4:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
90002de6:	2300      	movs	r3, #0
90002de8:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
90002dea:	2303      	movs	r3, #3
90002dec:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_SD_MCLK_AF;
90002dee:	230a      	movs	r3, #10
90002df0:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, &gpio_init_structure);
90002df2:	f107 031c 	add.w	r3, r7, #28
90002df6:	4619      	mov	r1, r3
90002df8:	482d      	ldr	r0, [pc, #180]	; (90002eb0 <BSP_AUDIO_OUT_MspInit+0x19c>)
90002dfa:	f001 f885 	bl	90003f08 <HAL_GPIO_Init>

  /* Enable the DMA clock */
  AUDIO_OUT_SAIx_DMAx_CLK_ENABLE();
90002dfe:	4b2b      	ldr	r3, [pc, #172]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002e00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002e02:	4a2a      	ldr	r2, [pc, #168]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002e04:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
90002e08:	6313      	str	r3, [r2, #48]	; 0x30
90002e0a:	4b28      	ldr	r3, [pc, #160]	; (90002eac <BSP_AUDIO_OUT_MspInit+0x198>)
90002e0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90002e0e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90002e12:	60bb      	str	r3, [r7, #8]
90002e14:	68bb      	ldr	r3, [r7, #8]
    
  if(hsai->Instance == AUDIO_OUT_SAIx)
90002e16:	687b      	ldr	r3, [r7, #4]
90002e18:	681b      	ldr	r3, [r3, #0]
90002e1a:	4a26      	ldr	r2, [pc, #152]	; (90002eb4 <BSP_AUDIO_OUT_MspInit+0x1a0>)
90002e1c:	4293      	cmp	r3, r2
90002e1e:	d138      	bne.n	90002e92 <BSP_AUDIO_OUT_MspInit+0x17e>
  {
    /* Configure the hdma_saiTx handle parameters */   
    hdma_sai_tx.Init.Channel             = AUDIO_OUT_SAIx_DMAx_CHANNEL;
90002e20:	4b25      	ldr	r3, [pc, #148]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e22:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
90002e26:	605a      	str	r2, [r3, #4]
    hdma_sai_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
90002e28:	4b23      	ldr	r3, [pc, #140]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e2a:	2240      	movs	r2, #64	; 0x40
90002e2c:	609a      	str	r2, [r3, #8]
    hdma_sai_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
90002e2e:	4b22      	ldr	r3, [pc, #136]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e30:	2200      	movs	r2, #0
90002e32:	60da      	str	r2, [r3, #12]
    hdma_sai_tx.Init.MemInc              = DMA_MINC_ENABLE;
90002e34:	4b20      	ldr	r3, [pc, #128]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e36:	f44f 6280 	mov.w	r2, #1024	; 0x400
90002e3a:	611a      	str	r2, [r3, #16]
    hdma_sai_tx.Init.PeriphDataAlignment = AUDIO_OUT_SAIx_DMAx_PERIPH_DATA_SIZE;
90002e3c:	4b1e      	ldr	r3, [pc, #120]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e3e:	f44f 6200 	mov.w	r2, #2048	; 0x800
90002e42:	615a      	str	r2, [r3, #20]
    hdma_sai_tx.Init.MemDataAlignment    = AUDIO_OUT_SAIx_DMAx_MEM_DATA_SIZE;
90002e44:	4b1c      	ldr	r3, [pc, #112]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e46:	f44f 5200 	mov.w	r2, #8192	; 0x2000
90002e4a:	619a      	str	r2, [r3, #24]
    hdma_sai_tx.Init.Mode                = DMA_CIRCULAR;
90002e4c:	4b1a      	ldr	r3, [pc, #104]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e4e:	f44f 7280 	mov.w	r2, #256	; 0x100
90002e52:	61da      	str	r2, [r3, #28]
    hdma_sai_tx.Init.Priority            = DMA_PRIORITY_HIGH;
90002e54:	4b18      	ldr	r3, [pc, #96]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e56:	f44f 3200 	mov.w	r2, #131072	; 0x20000
90002e5a:	621a      	str	r2, [r3, #32]
    hdma_sai_tx.Init.FIFOMode            = DMA_FIFOMODE_ENABLE;         
90002e5c:	4b16      	ldr	r3, [pc, #88]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e5e:	2204      	movs	r2, #4
90002e60:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sai_tx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
90002e62:	4b15      	ldr	r3, [pc, #84]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e64:	2203      	movs	r2, #3
90002e66:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sai_tx.Init.MemBurst            = DMA_MBURST_SINGLE;
90002e68:	4b13      	ldr	r3, [pc, #76]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e6a:	2200      	movs	r2, #0
90002e6c:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sai_tx.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
90002e6e:	4b12      	ldr	r3, [pc, #72]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e70:	2200      	movs	r2, #0
90002e72:	631a      	str	r2, [r3, #48]	; 0x30
    
    hdma_sai_tx.Instance = AUDIO_OUT_SAIx_DMAx_STREAM;
90002e74:	4b10      	ldr	r3, [pc, #64]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e76:	4a11      	ldr	r2, [pc, #68]	; (90002ebc <BSP_AUDIO_OUT_MspInit+0x1a8>)
90002e78:	601a      	str	r2, [r3, #0]
    
    /* Associate the DMA handle */
    __HAL_LINKDMA(hsai, hdmatx, hdma_sai_tx);
90002e7a:	687b      	ldr	r3, [r7, #4]
90002e7c:	4a0e      	ldr	r2, [pc, #56]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e7e:	66da      	str	r2, [r3, #108]	; 0x6c
90002e80:	4a0d      	ldr	r2, [pc, #52]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e82:	687b      	ldr	r3, [r7, #4]
90002e84:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Deinitialize the Stream for new transfer */
    HAL_DMA_DeInit(&hdma_sai_tx);
90002e86:	480c      	ldr	r0, [pc, #48]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e88:	f000 fea0 	bl	90003bcc <HAL_DMA_DeInit>
    
    /* Configure the DMA Stream */
    HAL_DMA_Init(&hdma_sai_tx);      
90002e8c:	480a      	ldr	r0, [pc, #40]	; (90002eb8 <BSP_AUDIO_OUT_MspInit+0x1a4>)
90002e8e:	f000 fdef 	bl	90003a70 <HAL_DMA_Init>
  }
  
  /* SAI DMA IRQ Channel configuration */
  HAL_NVIC_SetPriority(AUDIO_OUT_SAIx_DMAx_IRQ, AUDIO_OUT_IRQ_PREPRIO, 0);
90002e92:	2200      	movs	r2, #0
90002e94:	210e      	movs	r1, #14
90002e96:	203c      	movs	r0, #60	; 0x3c
90002e98:	f000 fdb3 	bl	90003a02 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_OUT_SAIx_DMAx_IRQ); 
90002e9c:	203c      	movs	r0, #60	; 0x3c
90002e9e:	f000 fdcc 	bl	90003a3a <HAL_NVIC_EnableIRQ>
}
90002ea2:	bf00      	nop
90002ea4:	3730      	adds	r7, #48	; 0x30
90002ea6:	46bd      	mov	sp, r7
90002ea8:	bd80      	pop	{r7, pc}
90002eaa:	bf00      	nop
90002eac:	40023800 	.word	0x40023800
90002eb0:	40022000 	.word	0x40022000
90002eb4:	40015c04 	.word	0x40015c04
90002eb8:	200001bc 	.word	0x200001bc
90002ebc:	40026470 	.word	0x40026470

90002ec0 <BSP_AUDIO_OUT_ClockConfig>:
  * @note   This API is called by BSP_AUDIO_OUT_Init() and BSP_AUDIO_OUT_SetFrequency()
  *         Being __weak it can be overwritten by the application     
  * @retval None
  */
__weak void BSP_AUDIO_OUT_ClockConfig(SAI_HandleTypeDef *hsai, uint32_t AudioFreq, void *Params)
{ 
90002ec0:	b580      	push	{r7, lr}
90002ec2:	b0a6      	sub	sp, #152	; 0x98
90002ec4:	af00      	add	r7, sp, #0
90002ec6:	60f8      	str	r0, [r7, #12]
90002ec8:	60b9      	str	r1, [r7, #8]
90002eca:	607a      	str	r2, [r7, #4]
  RCC_PeriphCLKInitTypeDef rcc_ex_clk_init_struct;

  HAL_RCCEx_GetPeriphCLKConfig(&rcc_ex_clk_init_struct);
90002ecc:	f107 0314 	add.w	r3, r7, #20
90002ed0:	4618      	mov	r0, r3
90002ed2:	f002 ffab 	bl	90005e2c <HAL_RCCEx_GetPeriphCLKConfig>
  
  /* Set the PLL configuration according to the audio frequency */
  if((AudioFreq == AUDIO_FREQUENCY_11K) || (AudioFreq == AUDIO_FREQUENCY_22K) || (AudioFreq == AUDIO_FREQUENCY_44K))
90002ed6:	68bb      	ldr	r3, [r7, #8]
90002ed8:	f642 3211 	movw	r2, #11025	; 0x2b11
90002edc:	4293      	cmp	r3, r2
90002ede:	d009      	beq.n	90002ef4 <BSP_AUDIO_OUT_ClockConfig+0x34>
90002ee0:	68bb      	ldr	r3, [r7, #8]
90002ee2:	f245 6222 	movw	r2, #22050	; 0x5622
90002ee6:	4293      	cmp	r3, r2
90002ee8:	d004      	beq.n	90002ef4 <BSP_AUDIO_OUT_ClockConfig+0x34>
90002eea:	68bb      	ldr	r3, [r7, #8]
90002eec:	f64a 4244 	movw	r2, #44100	; 0xac44
90002ef0:	4293      	cmp	r3, r2
90002ef2:	d112      	bne.n	90002f1a <BSP_AUDIO_OUT_ClockConfig+0x5a>
  {
    /* Configure PLLI2S prescalers */
    /* PLLI2S_VCO: VCO_429M
    I2S_CLK(first level) = PLLI2S_VCO/PLLI2SQ = 429/2 = 214.5 Mhz
    I2S_CLK_x = I2S_CLK(first level)/PLLI2SDIVQ = 214.5/19 = 11.289 Mhz */
    rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
90002ef4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
90002ef8:	617b      	str	r3, [r7, #20]
    rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
90002efa:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
90002efe:	657b      	str	r3, [r7, #84]	; 0x54
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = 429;
90002f00:	f240 13ad 	movw	r3, #429	; 0x1ad
90002f04:	61bb      	str	r3, [r7, #24]
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 2;
90002f06:	2302      	movs	r3, #2
90002f08:	623b      	str	r3, [r7, #32]
    rcc_ex_clk_init_struct.PLLI2SDivQ = 19;
90002f0a:	2313      	movs	r3, #19
90002f0c:	63bb      	str	r3, [r7, #56]	; 0x38
    
    HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
90002f0e:	f107 0314 	add.w	r3, r7, #20
90002f12:	4618      	mov	r0, r3
90002f14:	f002 fb9a 	bl	9000564c <HAL_RCCEx_PeriphCLKConfig>
90002f18:	e012      	b.n	90002f40 <BSP_AUDIO_OUT_ClockConfig+0x80>
  {
    /* I2S clock config
    PLLI2S_VCO: VCO_344M
    I2S_CLK(first level) = PLLI2S_VCO/PLLI2SQ = 344/7 = 49.142 Mhz
    I2S_CLK_x = I2S_CLK(first level)/PLLI2SDIVQ = 49.142/1 = 49.142 Mhz */
    rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
90002f1a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
90002f1e:	617b      	str	r3, [r7, #20]
    rcc_ex_clk_init_struct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
90002f20:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
90002f24:	657b      	str	r3, [r7, #84]	; 0x54
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SN = 344;
90002f26:	f44f 73ac 	mov.w	r3, #344	; 0x158
90002f2a:	61bb      	str	r3, [r7, #24]
    rcc_ex_clk_init_struct.PLLI2S.PLLI2SQ = 7;
90002f2c:	2307      	movs	r3, #7
90002f2e:	623b      	str	r3, [r7, #32]
    rcc_ex_clk_init_struct.PLLI2SDivQ = 1;
90002f30:	2301      	movs	r3, #1
90002f32:	63bb      	str	r3, [r7, #56]	; 0x38
    
    HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
90002f34:	f107 0314 	add.w	r3, r7, #20
90002f38:	4618      	mov	r0, r3
90002f3a:	f002 fb87 	bl	9000564c <HAL_RCCEx_PeriphCLKConfig>
  }
}
90002f3e:	bf00      	nop
90002f40:	bf00      	nop
90002f42:	3798      	adds	r7, #152	; 0x98
90002f44:	46bd      	mov	sp, r7
90002f46:	bd80      	pop	{r7, pc}

90002f48 <SAIx_Out_DeInit>:
/**
  * @brief  Deinitializes the output Audio Codec audio interface (SAI).
  * @retval None
  */
static void SAIx_Out_DeInit(void)
{
90002f48:	b580      	push	{r7, lr}
90002f4a:	af00      	add	r7, sp, #0
  /* Initialize the haudio_out_sai Instance parameter */
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90002f4c:	4b07      	ldr	r3, [pc, #28]	; (90002f6c <SAIx_Out_DeInit+0x24>)
90002f4e:	4a08      	ldr	r2, [pc, #32]	; (90002f70 <SAIx_Out_DeInit+0x28>)
90002f50:	601a      	str	r2, [r3, #0]

  /* Disable SAI peripheral */
  __HAL_SAI_DISABLE(&haudio_out_sai);
90002f52:	4b06      	ldr	r3, [pc, #24]	; (90002f6c <SAIx_Out_DeInit+0x24>)
90002f54:	681b      	ldr	r3, [r3, #0]
90002f56:	681a      	ldr	r2, [r3, #0]
90002f58:	4b04      	ldr	r3, [pc, #16]	; (90002f6c <SAIx_Out_DeInit+0x24>)
90002f5a:	681b      	ldr	r3, [r3, #0]
90002f5c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
90002f60:	601a      	str	r2, [r3, #0]

  HAL_SAI_DeInit(&haudio_out_sai);
90002f62:	4802      	ldr	r0, [pc, #8]	; (90002f6c <SAIx_Out_DeInit+0x24>)
90002f64:	f003 fb30 	bl	900065c8 <HAL_SAI_DeInit>
}
90002f68:	bf00      	nop
90002f6a:	bd80      	pop	{r7, pc}
90002f6c:	200000b4 	.word	0x200000b4
90002f70:	40015c04 	.word	0x40015c04

90002f74 <BSP_AUDIO_IN_OUT_Init>:
  * @param  BitRes: Audio frequency to be configured.
  * @param  ChnlNbr: Channel number.
  * @retval AUDIO_OK if correct communication, else wrong communication
  */
uint8_t BSP_AUDIO_IN_OUT_Init(uint16_t InputDevice, uint16_t OutputDevice, uint32_t AudioFreq, uint32_t BitRes, uint32_t ChnlNbr)
{
90002f74:	b590      	push	{r4, r7, lr}
90002f76:	b089      	sub	sp, #36	; 0x24
90002f78:	af00      	add	r7, sp, #0
90002f7a:	60ba      	str	r2, [r7, #8]
90002f7c:	607b      	str	r3, [r7, #4]
90002f7e:	4603      	mov	r3, r0
90002f80:	81fb      	strh	r3, [r7, #14]
90002f82:	460b      	mov	r3, r1
90002f84:	81bb      	strh	r3, [r7, #12]
  uint8_t ret = AUDIO_ERROR;
90002f86:	2301      	movs	r3, #1
90002f88:	77fb      	strb	r3, [r7, #31]
  uint32_t deviceid = 0x00;
90002f8a:	2300      	movs	r3, #0
90002f8c:	617b      	str	r3, [r7, #20]
  uint32_t slot_active;

  if (InputDevice != INPUT_DEVICE_DIGITAL_MICROPHONE_2)  /* Only MICROPHONE_2 input supported */
90002f8e:	89fb      	ldrh	r3, [r7, #14]
90002f90:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90002f94:	d002      	beq.n	90002f9c <BSP_AUDIO_IN_OUT_Init+0x28>
  {
    ret = AUDIO_ERROR;
90002f96:	2301      	movs	r3, #1
90002f98:	77fb      	strb	r3, [r7, #31]
90002f9a:	e054      	b.n	90003046 <BSP_AUDIO_IN_OUT_Init+0xd2>
  }
  else
  {
    /* Disable SAI */
    SAIx_In_DeInit();
90002f9c:	f000 fa00 	bl	900033a0 <SAIx_In_DeInit>
    SAIx_Out_DeInit();
90002fa0:	f7ff ffd2 	bl	90002f48 <SAIx_Out_DeInit>

    /* PLL clock is set depending on the AudioFreq (44.1khz vs 48khz groups) */
    BSP_AUDIO_OUT_ClockConfig(&haudio_in_sai, AudioFreq, NULL); /* Clock config is shared between AUDIO IN and OUT */
90002fa4:	2200      	movs	r2, #0
90002fa6:	68b9      	ldr	r1, [r7, #8]
90002fa8:	4829      	ldr	r0, [pc, #164]	; (90003050 <BSP_AUDIO_IN_OUT_Init+0xdc>)
90002faa:	f7ff ff89 	bl	90002ec0 <BSP_AUDIO_OUT_ClockConfig>

    /* SAI data transfer preparation:
    Prepare the Media to be used for the audio transfer from SAI peripheral to memory */
    haudio_in_sai.Instance = AUDIO_IN_SAIx;
90002fae:	4b28      	ldr	r3, [pc, #160]	; (90003050 <BSP_AUDIO_IN_OUT_Init+0xdc>)
90002fb0:	4a28      	ldr	r2, [pc, #160]	; (90003054 <BSP_AUDIO_IN_OUT_Init+0xe0>)
90002fb2:	601a      	str	r2, [r3, #0]
    if(HAL_SAI_GetState(&haudio_in_sai) == HAL_SAI_STATE_RESET)
90002fb4:	4826      	ldr	r0, [pc, #152]	; (90003050 <BSP_AUDIO_IN_OUT_Init+0xdc>)
90002fb6:	f003 fc8f 	bl	900068d8 <HAL_SAI_GetState>
90002fba:	4603      	mov	r3, r0
90002fbc:	2b00      	cmp	r3, #0
90002fbe:	d103      	bne.n	90002fc8 <BSP_AUDIO_IN_OUT_Init+0x54>
    {
      /* Init the SAI MSP: this __weak function can be redefined by the application*/
      BSP_AUDIO_IN_MspInit(&haudio_in_sai, NULL);
90002fc0:	2100      	movs	r1, #0
90002fc2:	4823      	ldr	r0, [pc, #140]	; (90003050 <BSP_AUDIO_IN_OUT_Init+0xdc>)
90002fc4:	f000 f884 	bl	900030d0 <BSP_AUDIO_IN_MspInit>
    }

    /* SAI data transfer preparation:
    Prepare the Media to be used for the audio transfer from memory to SAI peripheral */
    haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90002fc8:	4b23      	ldr	r3, [pc, #140]	; (90003058 <BSP_AUDIO_IN_OUT_Init+0xe4>)
90002fca:	4a24      	ldr	r2, [pc, #144]	; (9000305c <BSP_AUDIO_IN_OUT_Init+0xe8>)
90002fcc:	601a      	str	r2, [r3, #0]
    if(HAL_SAI_GetState(&haudio_out_sai) == HAL_SAI_STATE_RESET)
90002fce:	4822      	ldr	r0, [pc, #136]	; (90003058 <BSP_AUDIO_IN_OUT_Init+0xe4>)
90002fd0:	f003 fc82 	bl	900068d8 <HAL_SAI_GetState>
90002fd4:	4603      	mov	r3, r0
90002fd6:	2b00      	cmp	r3, #0
90002fd8:	d103      	bne.n	90002fe2 <BSP_AUDIO_IN_OUT_Init+0x6e>
    {
      /* Init the SAI MSP: this __weak function can be redefined by the application*/
      BSP_AUDIO_OUT_MspInit(&haudio_out_sai, NULL);
90002fda:	2100      	movs	r1, #0
90002fdc:	481e      	ldr	r0, [pc, #120]	; (90003058 <BSP_AUDIO_IN_OUT_Init+0xe4>)
90002fde:	f7ff fe99 	bl	90002d14 <BSP_AUDIO_OUT_MspInit>

    /* Configure SAI in master mode :
     *   - SAI2_block_A in master TX mode
     *   - SAI2_block_B in slave RX mode synchronous from SAI2_block_A
     */
    if (InputDevice == INPUT_DEVICE_DIGITAL_MICROPHONE_2)
90002fe2:	89fb      	ldrh	r3, [r7, #14]
90002fe4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90002fe8:	d102      	bne.n	90002ff0 <BSP_AUDIO_IN_OUT_Init+0x7c>
    {
      slot_active = CODEC_AUDIOFRAME_SLOT_13;
90002fea:	230a      	movs	r3, #10
90002fec:	61bb      	str	r3, [r7, #24]
90002fee:	e001      	b.n	90002ff4 <BSP_AUDIO_IN_OUT_Init+0x80>
    }
    else
    {
      slot_active = CODEC_AUDIOFRAME_SLOT_02;
90002ff0:	2305      	movs	r3, #5
90002ff2:	61bb      	str	r3, [r7, #24]
    }
    SAIx_In_Init(SAI_MODEMASTER_TX, slot_active, AudioFreq);
90002ff4:	68ba      	ldr	r2, [r7, #8]
90002ff6:	69b9      	ldr	r1, [r7, #24]
90002ff8:	2000      	movs	r0, #0
90002ffa:	f000 f91b 	bl	90003234 <SAIx_In_Init>

    /* wm8994 codec initialization */
    deviceid = wm8994_drv.ReadID(AUDIO_I2C_ADDRESS);
90002ffe:	4b18      	ldr	r3, [pc, #96]	; (90003060 <BSP_AUDIO_IN_OUT_Init+0xec>)
90003000:	689b      	ldr	r3, [r3, #8]
90003002:	2034      	movs	r0, #52	; 0x34
90003004:	4798      	blx	r3
90003006:	6178      	str	r0, [r7, #20]

    if((deviceid) == WM8994_ID)
90003008:	697b      	ldr	r3, [r7, #20]
9000300a:	f648 1294 	movw	r2, #35220	; 0x8994
9000300e:	4293      	cmp	r3, r2
90003010:	d109      	bne.n	90003026 <BSP_AUDIO_IN_OUT_Init+0xb2>
    {
      /* Reset the Codec Registers */
      wm8994_drv.Reset(AUDIO_I2C_ADDRESS);
90003012:	4b13      	ldr	r3, [pc, #76]	; (90003060 <BSP_AUDIO_IN_OUT_Init+0xec>)
90003014:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003016:	2034      	movs	r0, #52	; 0x34
90003018:	4798      	blx	r3
      /* Initialize the audio driver structure */
      audio_drv = &wm8994_drv;
9000301a:	4b12      	ldr	r3, [pc, #72]	; (90003064 <BSP_AUDIO_IN_OUT_Init+0xf0>)
9000301c:	4a10      	ldr	r2, [pc, #64]	; (90003060 <BSP_AUDIO_IN_OUT_Init+0xec>)
9000301e:	601a      	str	r2, [r3, #0]
      ret = AUDIO_OK;
90003020:	2300      	movs	r3, #0
90003022:	77fb      	strb	r3, [r7, #31]
90003024:	e001      	b.n	9000302a <BSP_AUDIO_IN_OUT_Init+0xb6>
    }
    else
    {
      ret = AUDIO_ERROR;
90003026:	2301      	movs	r3, #1
90003028:	77fb      	strb	r3, [r7, #31]
    }

    if(ret == AUDIO_OK)
9000302a:	7ffb      	ldrb	r3, [r7, #31]
9000302c:	2b00      	cmp	r3, #0
9000302e:	d10a      	bne.n	90003046 <BSP_AUDIO_IN_OUT_Init+0xd2>
    {
      /* Initialize the codec internal registers */
      audio_drv->Init(AUDIO_I2C_ADDRESS, InputDevice | OutputDevice, 100, AudioFreq);
90003030:	4b0c      	ldr	r3, [pc, #48]	; (90003064 <BSP_AUDIO_IN_OUT_Init+0xf0>)
90003032:	681b      	ldr	r3, [r3, #0]
90003034:	681c      	ldr	r4, [r3, #0]
90003036:	89fa      	ldrh	r2, [r7, #14]
90003038:	89bb      	ldrh	r3, [r7, #12]
9000303a:	4313      	orrs	r3, r2
9000303c:	b299      	uxth	r1, r3
9000303e:	68bb      	ldr	r3, [r7, #8]
90003040:	2264      	movs	r2, #100	; 0x64
90003042:	2034      	movs	r0, #52	; 0x34
90003044:	47a0      	blx	r4
    }
  }
  return ret;
90003046:	7ffb      	ldrb	r3, [r7, #31]
}
90003048:	4618      	mov	r0, r3
9000304a:	3724      	adds	r7, #36	; 0x24
9000304c:	46bd      	mov	sp, r7
9000304e:	bd90      	pop	{r4, r7, pc}
90003050:	20000138 	.word	0x20000138
90003054:	40015c24 	.word	0x40015c24
90003058:	200000b4 	.word	0x200000b4
9000305c:	40015c04 	.word	0x40015c04
90003060:	20000004 	.word	0x20000004
90003064:	20000354 	.word	0x20000354

90003068 <BSP_AUDIO_IN_Record>:
  * @param  size: size of the recorded buffer in number of elements (typically number of half-words)
  *               Be careful that it is not the same unit than BSP_AUDIO_OUT_Play function
  * @retval AUDIO_OK if correct communication, else wrong communication
  */
uint8_t  BSP_AUDIO_IN_Record(uint16_t* pbuf, uint32_t size)
{
90003068:	b580      	push	{r7, lr}
9000306a:	b084      	sub	sp, #16
9000306c:	af00      	add	r7, sp, #0
9000306e:	6078      	str	r0, [r7, #4]
90003070:	6039      	str	r1, [r7, #0]
  uint32_t ret = AUDIO_ERROR;
90003072:	2301      	movs	r3, #1
90003074:	60fb      	str	r3, [r7, #12]
  
  /* Start the process receive DMA */
  HAL_SAI_Receive_DMA(&haudio_in_sai, (uint8_t*)pbuf, size);
90003076:	683b      	ldr	r3, [r7, #0]
90003078:	b29b      	uxth	r3, r3
9000307a:	461a      	mov	r2, r3
9000307c:	6879      	ldr	r1, [r7, #4]
9000307e:	4805      	ldr	r0, [pc, #20]	; (90003094 <BSP_AUDIO_IN_Record+0x2c>)
90003080:	f003 fb9c 	bl	900067bc <HAL_SAI_Receive_DMA>
  
  /* Return AUDIO_OK when all operations are correctly done */
  ret = AUDIO_OK;
90003084:	2300      	movs	r3, #0
90003086:	60fb      	str	r3, [r7, #12]
  
  return ret;
90003088:	68fb      	ldr	r3, [r7, #12]
9000308a:	b2db      	uxtb	r3, r3
}
9000308c:	4618      	mov	r0, r3
9000308e:	3710      	adds	r7, #16
90003090:	46bd      	mov	sp, r7
90003092:	bd80      	pop	{r7, pc}
90003094:	20000138 	.word	0x20000138

90003098 <HAL_SAI_RxCpltCallback>:
  * @brief  Rx Transfer completed callbacks.
  * @param  hsai: SAI handle
  * @retval None
  */
void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
90003098:	b580      	push	{r7, lr}
9000309a:	b082      	sub	sp, #8
9000309c:	af00      	add	r7, sp, #0
9000309e:	6078      	str	r0, [r7, #4]
  /* Call the record update function to get the next buffer to fill and its size (size is ignored) */
  BSP_AUDIO_IN_TransferComplete_CallBack();
900030a0:	f7fd fad2 	bl	90000648 <BSP_AUDIO_IN_TransferComplete_CallBack>
}
900030a4:	bf00      	nop
900030a6:	3708      	adds	r7, #8
900030a8:	46bd      	mov	sp, r7
900030aa:	bd80      	pop	{r7, pc}

900030ac <HAL_SAI_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callbacks.
  * @param  hsai: SAI handle
  * @retval None
  */
void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
900030ac:	b580      	push	{r7, lr}
900030ae:	b082      	sub	sp, #8
900030b0:	af00      	add	r7, sp, #0
900030b2:	6078      	str	r0, [r7, #4]
  /* Manage the remaining file size and new address offset: This function 
     should be coded by user (its prototype is already declared in stm32f7508_discovery_audio.h) */
  BSP_AUDIO_IN_HalfTransfer_CallBack();
900030b4:	f7fd fad4 	bl	90000660 <BSP_AUDIO_IN_HalfTransfer_CallBack>
}
900030b8:	bf00      	nop
900030ba:	3708      	adds	r7, #8
900030bc:	46bd      	mov	sp, r7
900030be:	bd80      	pop	{r7, pc}

900030c0 <BSP_AUDIO_IN_Error_CallBack>:
/**
  * @brief  Audio IN Error callback function.
  * @retval None
  */
__weak void BSP_AUDIO_IN_Error_CallBack(void)
{   
900030c0:	b480      	push	{r7}
900030c2:	af00      	add	r7, sp, #0
  /* This function is called when an Interrupt due to transfer error on or peripheral
     error occurs. */
}
900030c4:	bf00      	nop
900030c6:	46bd      	mov	sp, r7
900030c8:	f85d 7b04 	ldr.w	r7, [sp], #4
900030cc:	4770      	bx	lr
	...

900030d0 <BSP_AUDIO_IN_MspInit>:
  * @param  hsai: SAI handle
  * @param  Params
  * @retval None
  */
__weak void BSP_AUDIO_IN_MspInit(SAI_HandleTypeDef *hsai, void *Params)
{
900030d0:	b580      	push	{r7, lr}
900030d2:	b08c      	sub	sp, #48	; 0x30
900030d4:	af00      	add	r7, sp, #0
900030d6:	6078      	str	r0, [r7, #4]
900030d8:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef hdma_sai_rx;
  GPIO_InitTypeDef  gpio_init_structure;  

  /* Enable SAI clock */
  AUDIO_IN_SAIx_CLK_ENABLE();
900030da:	4b50      	ldr	r3, [pc, #320]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
900030dc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
900030de:	4a4f      	ldr	r2, [pc, #316]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
900030e0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
900030e4:	6453      	str	r3, [r2, #68]	; 0x44
900030e6:	4b4d      	ldr	r3, [pc, #308]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
900030e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
900030ea:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
900030ee:	61bb      	str	r3, [r7, #24]
900030f0:	69bb      	ldr	r3, [r7, #24]
  
  /* Enable SD GPIO clock */
  AUDIO_IN_SAIx_SD_ENABLE();
900030f2:	4b4a      	ldr	r3, [pc, #296]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
900030f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900030f6:	4a49      	ldr	r2, [pc, #292]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
900030f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
900030fc:	6313      	str	r3, [r2, #48]	; 0x30
900030fe:	4b47      	ldr	r3, [pc, #284]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
90003100:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003102:	f003 0340 	and.w	r3, r3, #64	; 0x40
90003106:	617b      	str	r3, [r7, #20]
90003108:	697b      	ldr	r3, [r7, #20]
  /* CODEC_SAI pin configuration: SD pin */
  gpio_init_structure.Pin = AUDIO_IN_SAIx_SD_PIN;
9000310a:	f44f 6380 	mov.w	r3, #1024	; 0x400
9000310e:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
90003110:	2302      	movs	r3, #2
90003112:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
90003114:	2300      	movs	r3, #0
90003116:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
90003118:	2302      	movs	r3, #2
9000311a:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Alternate = AUDIO_IN_SAIx_SD_AF;
9000311c:	230a      	movs	r3, #10
9000311e:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(AUDIO_IN_SAIx_SD_GPIO_PORT, &gpio_init_structure);
90003120:	f107 031c 	add.w	r3, r7, #28
90003124:	4619      	mov	r1, r3
90003126:	483e      	ldr	r0, [pc, #248]	; (90003220 <BSP_AUDIO_IN_MspInit+0x150>)
90003128:	f000 feee 	bl	90003f08 <HAL_GPIO_Init>

  /* Enable Audio INT GPIO clock */
  AUDIO_IN_INT_GPIO_ENABLE();
9000312c:	4b3b      	ldr	r3, [pc, #236]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
9000312e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003130:	4a3a      	ldr	r2, [pc, #232]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
90003132:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90003136:	6313      	str	r3, [r2, #48]	; 0x30
90003138:	4b38      	ldr	r3, [pc, #224]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
9000313a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000313c:	f003 0380 	and.w	r3, r3, #128	; 0x80
90003140:	613b      	str	r3, [r7, #16]
90003142:	693b      	ldr	r3, [r7, #16]
  /* Audio INT pin configuration: input */
  gpio_init_structure.Pin = AUDIO_IN_INT_GPIO_PIN;
90003144:	f44f 4300 	mov.w	r3, #32768	; 0x8000
90003148:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Mode = GPIO_MODE_INPUT;
9000314a:	2300      	movs	r3, #0
9000314c:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull = GPIO_NOPULL;
9000314e:	2300      	movs	r3, #0
90003150:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
90003152:	2302      	movs	r3, #2
90003154:	62bb      	str	r3, [r7, #40]	; 0x28
  HAL_GPIO_Init(AUDIO_IN_INT_GPIO_PORT, &gpio_init_structure);
90003156:	f107 031c 	add.w	r3, r7, #28
9000315a:	4619      	mov	r1, r3
9000315c:	4831      	ldr	r0, [pc, #196]	; (90003224 <BSP_AUDIO_IN_MspInit+0x154>)
9000315e:	f000 fed3 	bl	90003f08 <HAL_GPIO_Init>

  /* Enable the DMA clock */
  AUDIO_IN_SAIx_DMAx_CLK_ENABLE();
90003162:	4b2e      	ldr	r3, [pc, #184]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
90003164:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003166:	4a2d      	ldr	r2, [pc, #180]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
90003168:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
9000316c:	6313      	str	r3, [r2, #48]	; 0x30
9000316e:	4b2b      	ldr	r3, [pc, #172]	; (9000321c <BSP_AUDIO_IN_MspInit+0x14c>)
90003170:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003172:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90003176:	60fb      	str	r3, [r7, #12]
90003178:	68fb      	ldr	r3, [r7, #12]
    
  if(hsai->Instance == AUDIO_IN_SAIx)
9000317a:	687b      	ldr	r3, [r7, #4]
9000317c:	681b      	ldr	r3, [r3, #0]
9000317e:	4a2a      	ldr	r2, [pc, #168]	; (90003228 <BSP_AUDIO_IN_MspInit+0x158>)
90003180:	4293      	cmp	r3, r2
90003182:	d137      	bne.n	900031f4 <BSP_AUDIO_IN_MspInit+0x124>
  {
    /* Configure the hdma_sai_rx handle parameters */
    hdma_sai_rx.Init.Channel             = AUDIO_IN_SAIx_DMAx_CHANNEL;
90003184:	4b29      	ldr	r3, [pc, #164]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
90003186:	2200      	movs	r2, #0
90003188:	605a      	str	r2, [r3, #4]
    hdma_sai_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
9000318a:	4b28      	ldr	r3, [pc, #160]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
9000318c:	2200      	movs	r2, #0
9000318e:	609a      	str	r2, [r3, #8]
    hdma_sai_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
90003190:	4b26      	ldr	r3, [pc, #152]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
90003192:	2200      	movs	r2, #0
90003194:	60da      	str	r2, [r3, #12]
    hdma_sai_rx.Init.MemInc              = DMA_MINC_ENABLE;
90003196:	4b25      	ldr	r3, [pc, #148]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
90003198:	f44f 6280 	mov.w	r2, #1024	; 0x400
9000319c:	611a      	str	r2, [r3, #16]
    hdma_sai_rx.Init.PeriphDataAlignment = AUDIO_IN_SAIx_DMAx_PERIPH_DATA_SIZE;
9000319e:	4b23      	ldr	r3, [pc, #140]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031a0:	f44f 6200 	mov.w	r2, #2048	; 0x800
900031a4:	615a      	str	r2, [r3, #20]
    hdma_sai_rx.Init.MemDataAlignment    = AUDIO_IN_SAIx_DMAx_MEM_DATA_SIZE;
900031a6:	4b21      	ldr	r3, [pc, #132]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031a8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
900031ac:	619a      	str	r2, [r3, #24]
    hdma_sai_rx.Init.Mode                = DMA_CIRCULAR;
900031ae:	4b1f      	ldr	r3, [pc, #124]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031b0:	f44f 7280 	mov.w	r2, #256	; 0x100
900031b4:	61da      	str	r2, [r3, #28]
    hdma_sai_rx.Init.Priority            = DMA_PRIORITY_HIGH;
900031b6:	4b1d      	ldr	r3, [pc, #116]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031b8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
900031bc:	621a      	str	r2, [r3, #32]
    hdma_sai_rx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
900031be:	4b1b      	ldr	r3, [pc, #108]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031c0:	2200      	movs	r2, #0
900031c2:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sai_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
900031c4:	4b19      	ldr	r3, [pc, #100]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031c6:	2203      	movs	r2, #3
900031c8:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sai_rx.Init.MemBurst            = DMA_MBURST_SINGLE;
900031ca:	4b18      	ldr	r3, [pc, #96]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031cc:	2200      	movs	r2, #0
900031ce:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sai_rx.Init.PeriphBurst         = DMA_MBURST_SINGLE;
900031d0:	4b16      	ldr	r3, [pc, #88]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031d2:	2200      	movs	r2, #0
900031d4:	631a      	str	r2, [r3, #48]	; 0x30
    
    hdma_sai_rx.Instance = AUDIO_IN_SAIx_DMAx_STREAM;
900031d6:	4b15      	ldr	r3, [pc, #84]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031d8:	4a15      	ldr	r2, [pc, #84]	; (90003230 <BSP_AUDIO_IN_MspInit+0x160>)
900031da:	601a      	str	r2, [r3, #0]
    
    /* Associate the DMA handle */
    __HAL_LINKDMA(hsai, hdmarx, hdma_sai_rx);
900031dc:	687b      	ldr	r3, [r7, #4]
900031de:	4a13      	ldr	r2, [pc, #76]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031e0:	671a      	str	r2, [r3, #112]	; 0x70
900031e2:	4a12      	ldr	r2, [pc, #72]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031e4:	687b      	ldr	r3, [r7, #4]
900031e6:	6393      	str	r3, [r2, #56]	; 0x38
    
    /* Deinitialize the Stream for new transfer */
    HAL_DMA_DeInit(&hdma_sai_rx);
900031e8:	4810      	ldr	r0, [pc, #64]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031ea:	f000 fcef 	bl	90003bcc <HAL_DMA_DeInit>
    
    /* Configure the DMA Stream */
    HAL_DMA_Init(&hdma_sai_rx);
900031ee:	480f      	ldr	r0, [pc, #60]	; (9000322c <BSP_AUDIO_IN_MspInit+0x15c>)
900031f0:	f000 fc3e 	bl	90003a70 <HAL_DMA_Init>
  }
  
  /* SAI DMA IRQ Channel configuration */
  HAL_NVIC_SetPriority(AUDIO_IN_SAIx_DMAx_IRQ, AUDIO_IN_IRQ_PREPRIO, 0);
900031f4:	2200      	movs	r2, #0
900031f6:	210f      	movs	r1, #15
900031f8:	2046      	movs	r0, #70	; 0x46
900031fa:	f000 fc02 	bl	90003a02 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_IN_SAIx_DMAx_IRQ);
900031fe:	2046      	movs	r0, #70	; 0x46
90003200:	f000 fc1b 	bl	90003a3a <HAL_NVIC_EnableIRQ>

  /* Audio INT IRQ Channel configuration */
  HAL_NVIC_SetPriority(AUDIO_IN_INT_IRQ, AUDIO_IN_IRQ_PREPRIO, 0);
90003204:	2200      	movs	r2, #0
90003206:	210f      	movs	r1, #15
90003208:	2028      	movs	r0, #40	; 0x28
9000320a:	f000 fbfa 	bl	90003a02 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(AUDIO_IN_INT_IRQ);
9000320e:	2028      	movs	r0, #40	; 0x28
90003210:	f000 fc13 	bl	90003a3a <HAL_NVIC_EnableIRQ>
}
90003214:	bf00      	nop
90003216:	3730      	adds	r7, #48	; 0x30
90003218:	46bd      	mov	sp, r7
9000321a:	bd80      	pop	{r7, pc}
9000321c:	40023800 	.word	0x40023800
90003220:	40021800 	.word	0x40021800
90003224:	40021c00 	.word	0x40021c00
90003228:	40015c24 	.word	0x40015c24
9000322c:	2000021c 	.word	0x2000021c
90003230:	400264b8 	.word	0x400264b8

90003234 <SAIx_In_Init>:
  * @param  SlotActive: CODEC_AUDIOFRAME_SLOT_02 or CODEC_AUDIOFRAME_SLOT_13
  * @param  AudioFreq: Audio frequency to be configured for the SAI peripheral.
  * @retval None
  */
static void SAIx_In_Init(uint32_t SaiOutMode, uint32_t SlotActive, uint32_t AudioFreq)
{
90003234:	b580      	push	{r7, lr}
90003236:	b084      	sub	sp, #16
90003238:	af00      	add	r7, sp, #0
9000323a:	60f8      	str	r0, [r7, #12]
9000323c:	60b9      	str	r1, [r7, #8]
9000323e:	607a      	str	r2, [r7, #4]
  /* Initialize SAI2 block A in MASTER RX */
  /* Initialize the haudio_out_sai Instance parameter */
  haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90003240:	4b53      	ldr	r3, [pc, #332]	; (90003390 <SAIx_In_Init+0x15c>)
90003242:	4a54      	ldr	r2, [pc, #336]	; (90003394 <SAIx_In_Init+0x160>)
90003244:	601a      	str	r2, [r3, #0]

  /* Disable SAI peripheral to allow access to SAI internal registers */
  __HAL_SAI_DISABLE(&haudio_out_sai);
90003246:	4b52      	ldr	r3, [pc, #328]	; (90003390 <SAIx_In_Init+0x15c>)
90003248:	681b      	ldr	r3, [r3, #0]
9000324a:	681a      	ldr	r2, [r3, #0]
9000324c:	4b50      	ldr	r3, [pc, #320]	; (90003390 <SAIx_In_Init+0x15c>)
9000324e:	681b      	ldr	r3, [r3, #0]
90003250:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
90003254:	601a      	str	r2, [r3, #0]

  /* Configure SAI_Block_x
  LSBFirst: Disabled
  DataSize: 16 */
  haudio_out_sai.Init.AudioFrequency = AudioFreq;
90003256:	4a4e      	ldr	r2, [pc, #312]	; (90003390 <SAIx_In_Init+0x15c>)
90003258:	687b      	ldr	r3, [r7, #4]
9000325a:	61d3      	str	r3, [r2, #28]
  haudio_out_sai.Init.AudioMode = SaiOutMode;
9000325c:	4a4c      	ldr	r2, [pc, #304]	; (90003390 <SAIx_In_Init+0x15c>)
9000325e:	68fb      	ldr	r3, [r7, #12]
90003260:	6053      	str	r3, [r2, #4]
  haudio_out_sai.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
90003262:	4b4b      	ldr	r3, [pc, #300]	; (90003390 <SAIx_In_Init+0x15c>)
90003264:	2200      	movs	r2, #0
90003266:	615a      	str	r2, [r3, #20]
  haudio_out_sai.Init.Protocol = SAI_FREE_PROTOCOL;
90003268:	4b49      	ldr	r3, [pc, #292]	; (90003390 <SAIx_In_Init+0x15c>)
9000326a:	2200      	movs	r2, #0
9000326c:	631a      	str	r2, [r3, #48]	; 0x30
  haudio_out_sai.Init.DataSize = SAI_DATASIZE_16;
9000326e:	4b48      	ldr	r3, [pc, #288]	; (90003390 <SAIx_In_Init+0x15c>)
90003270:	2280      	movs	r2, #128	; 0x80
90003272:	635a      	str	r2, [r3, #52]	; 0x34
  haudio_out_sai.Init.FirstBit = SAI_FIRSTBIT_MSB;
90003274:	4b46      	ldr	r3, [pc, #280]	; (90003390 <SAIx_In_Init+0x15c>)
90003276:	2200      	movs	r2, #0
90003278:	639a      	str	r2, [r3, #56]	; 0x38
  haudio_out_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
9000327a:	4b45      	ldr	r3, [pc, #276]	; (90003390 <SAIx_In_Init+0x15c>)
9000327c:	2201      	movs	r2, #1
9000327e:	63da      	str	r2, [r3, #60]	; 0x3c
  haudio_out_sai.Init.Synchro = SAI_ASYNCHRONOUS;
90003280:	4b43      	ldr	r3, [pc, #268]	; (90003390 <SAIx_In_Init+0x15c>)
90003282:	2200      	movs	r2, #0
90003284:	609a      	str	r2, [r3, #8]
  haudio_out_sai.Init.OutputDrive = SAI_OUTPUTDRIVE_ENABLED;
90003286:	4b42      	ldr	r3, [pc, #264]	; (90003390 <SAIx_In_Init+0x15c>)
90003288:	f44f 5200 	mov.w	r2, #8192	; 0x2000
9000328c:	611a      	str	r2, [r3, #16]
  haudio_out_sai.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
9000328e:	4b40      	ldr	r3, [pc, #256]	; (90003390 <SAIx_In_Init+0x15c>)
90003290:	2201      	movs	r2, #1
90003292:	619a      	str	r2, [r3, #24]
  Frame Length: 64
  Frame active Length: 32
  FS Definition: Start frame + Channel Side identification
  FS Polarity: FS active Low
  FS Offset: FS asserted one bit before the first bit of slot 0 */
  haudio_out_sai.FrameInit.FrameLength = 64;
90003294:	4b3e      	ldr	r3, [pc, #248]	; (90003390 <SAIx_In_Init+0x15c>)
90003296:	2240      	movs	r2, #64	; 0x40
90003298:	641a      	str	r2, [r3, #64]	; 0x40
  haudio_out_sai.FrameInit.ActiveFrameLength = 32;
9000329a:	4b3d      	ldr	r3, [pc, #244]	; (90003390 <SAIx_In_Init+0x15c>)
9000329c:	2220      	movs	r2, #32
9000329e:	645a      	str	r2, [r3, #68]	; 0x44
  haudio_out_sai.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
900032a0:	4b3b      	ldr	r3, [pc, #236]	; (90003390 <SAIx_In_Init+0x15c>)
900032a2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
900032a6:	649a      	str	r2, [r3, #72]	; 0x48
  haudio_out_sai.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
900032a8:	4b39      	ldr	r3, [pc, #228]	; (90003390 <SAIx_In_Init+0x15c>)
900032aa:	2200      	movs	r2, #0
900032ac:	64da      	str	r2, [r3, #76]	; 0x4c
  haudio_out_sai.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
900032ae:	4b38      	ldr	r3, [pc, #224]	; (90003390 <SAIx_In_Init+0x15c>)
900032b0:	f44f 2280 	mov.w	r2, #262144	; 0x40000
900032b4:	651a      	str	r2, [r3, #80]	; 0x50
  /* Configure SAI Block_x Slot
  Slot First Bit Offset: 0
  Slot Size  : 16
  Slot Number: 4
  Slot Active: All slot actives */
  haudio_out_sai.SlotInit.FirstBitOffset = 0;
900032b6:	4b36      	ldr	r3, [pc, #216]	; (90003390 <SAIx_In_Init+0x15c>)
900032b8:	2200      	movs	r2, #0
900032ba:	655a      	str	r2, [r3, #84]	; 0x54
  haudio_out_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
900032bc:	4b34      	ldr	r3, [pc, #208]	; (90003390 <SAIx_In_Init+0x15c>)
900032be:	2200      	movs	r2, #0
900032c0:	659a      	str	r2, [r3, #88]	; 0x58
  haudio_out_sai.SlotInit.SlotNumber = 4;
900032c2:	4b33      	ldr	r3, [pc, #204]	; (90003390 <SAIx_In_Init+0x15c>)
900032c4:	2204      	movs	r2, #4
900032c6:	65da      	str	r2, [r3, #92]	; 0x5c
  haudio_out_sai.SlotInit.SlotActive = SlotActive;
900032c8:	4a31      	ldr	r2, [pc, #196]	; (90003390 <SAIx_In_Init+0x15c>)
900032ca:	68bb      	ldr	r3, [r7, #8]
900032cc:	6613      	str	r3, [r2, #96]	; 0x60

  HAL_SAI_Init(&haudio_out_sai);
900032ce:	4830      	ldr	r0, [pc, #192]	; (90003390 <SAIx_In_Init+0x15c>)
900032d0:	f002 fffc 	bl	900062cc <HAL_SAI_Init>

  /* Initialize SAI2 block B in SLAVE RX synchronous from SAI2 block A */
  /* Initialize the haudio_in_sai Instance parameter */
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
900032d4:	4b30      	ldr	r3, [pc, #192]	; (90003398 <SAIx_In_Init+0x164>)
900032d6:	4a31      	ldr	r2, [pc, #196]	; (9000339c <SAIx_In_Init+0x168>)
900032d8:	601a      	str	r2, [r3, #0]
  
  /* Disable SAI peripheral to allow access to SAI internal registers */
  __HAL_SAI_DISABLE(&haudio_in_sai);
900032da:	4b2f      	ldr	r3, [pc, #188]	; (90003398 <SAIx_In_Init+0x164>)
900032dc:	681b      	ldr	r3, [r3, #0]
900032de:	681a      	ldr	r2, [r3, #0]
900032e0:	4b2d      	ldr	r3, [pc, #180]	; (90003398 <SAIx_In_Init+0x164>)
900032e2:	681b      	ldr	r3, [r3, #0]
900032e4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
900032e8:	601a      	str	r2, [r3, #0]
  
  /* Configure SAI_Block_x
  LSBFirst: Disabled
  DataSize: 16 */
  haudio_in_sai.Init.AudioFrequency = AudioFreq;
900032ea:	4a2b      	ldr	r2, [pc, #172]	; (90003398 <SAIx_In_Init+0x164>)
900032ec:	687b      	ldr	r3, [r7, #4]
900032ee:	61d3      	str	r3, [r2, #28]
  haudio_in_sai.Init.AudioMode = SAI_MODESLAVE_RX;
900032f0:	4b29      	ldr	r3, [pc, #164]	; (90003398 <SAIx_In_Init+0x164>)
900032f2:	2203      	movs	r2, #3
900032f4:	605a      	str	r2, [r3, #4]
  haudio_in_sai.Init.NoDivider = SAI_MASTERDIVIDER_ENABLED;
900032f6:	4b28      	ldr	r3, [pc, #160]	; (90003398 <SAIx_In_Init+0x164>)
900032f8:	2200      	movs	r2, #0
900032fa:	615a      	str	r2, [r3, #20]
  haudio_in_sai.Init.Protocol = SAI_FREE_PROTOCOL;
900032fc:	4b26      	ldr	r3, [pc, #152]	; (90003398 <SAIx_In_Init+0x164>)
900032fe:	2200      	movs	r2, #0
90003300:	631a      	str	r2, [r3, #48]	; 0x30
  haudio_in_sai.Init.DataSize = SAI_DATASIZE_16;
90003302:	4b25      	ldr	r3, [pc, #148]	; (90003398 <SAIx_In_Init+0x164>)
90003304:	2280      	movs	r2, #128	; 0x80
90003306:	635a      	str	r2, [r3, #52]	; 0x34
  haudio_in_sai.Init.FirstBit = SAI_FIRSTBIT_MSB;
90003308:	4b23      	ldr	r3, [pc, #140]	; (90003398 <SAIx_In_Init+0x164>)
9000330a:	2200      	movs	r2, #0
9000330c:	639a      	str	r2, [r3, #56]	; 0x38
  haudio_in_sai.Init.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
9000330e:	4b22      	ldr	r3, [pc, #136]	; (90003398 <SAIx_In_Init+0x164>)
90003310:	2201      	movs	r2, #1
90003312:	63da      	str	r2, [r3, #60]	; 0x3c
  haudio_in_sai.Init.Synchro = SAI_SYNCHRONOUS;
90003314:	4b20      	ldr	r3, [pc, #128]	; (90003398 <SAIx_In_Init+0x164>)
90003316:	2201      	movs	r2, #1
90003318:	609a      	str	r2, [r3, #8]
  haudio_in_sai.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLED;
9000331a:	4b1f      	ldr	r3, [pc, #124]	; (90003398 <SAIx_In_Init+0x164>)
9000331c:	2200      	movs	r2, #0
9000331e:	611a      	str	r2, [r3, #16]
  haudio_in_sai.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
90003320:	4b1d      	ldr	r3, [pc, #116]	; (90003398 <SAIx_In_Init+0x164>)
90003322:	2201      	movs	r2, #1
90003324:	619a      	str	r2, [r3, #24]
  Frame Length: 64
  Frame active Length: 32
  FS Definition: Start frame + Channel Side identification
  FS Polarity: FS active Low
  FS Offset: FS asserted one bit before the first bit of slot 0 */
  haudio_in_sai.FrameInit.FrameLength = 64;
90003326:	4b1c      	ldr	r3, [pc, #112]	; (90003398 <SAIx_In_Init+0x164>)
90003328:	2240      	movs	r2, #64	; 0x40
9000332a:	641a      	str	r2, [r3, #64]	; 0x40
  haudio_in_sai.FrameInit.ActiveFrameLength = 32;
9000332c:	4b1a      	ldr	r3, [pc, #104]	; (90003398 <SAIx_In_Init+0x164>)
9000332e:	2220      	movs	r2, #32
90003330:	645a      	str	r2, [r3, #68]	; 0x44
  haudio_in_sai.FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
90003332:	4b19      	ldr	r3, [pc, #100]	; (90003398 <SAIx_In_Init+0x164>)
90003334:	f44f 3280 	mov.w	r2, #65536	; 0x10000
90003338:	649a      	str	r2, [r3, #72]	; 0x48
  haudio_in_sai.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
9000333a:	4b17      	ldr	r3, [pc, #92]	; (90003398 <SAIx_In_Init+0x164>)
9000333c:	2200      	movs	r2, #0
9000333e:	64da      	str	r2, [r3, #76]	; 0x4c
  haudio_in_sai.FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
90003340:	4b15      	ldr	r3, [pc, #84]	; (90003398 <SAIx_In_Init+0x164>)
90003342:	f44f 2280 	mov.w	r2, #262144	; 0x40000
90003346:	651a      	str	r2, [r3, #80]	; 0x50
  /* Configure SAI Block_x Slot
  Slot First Bit Offset: 0
  Slot Size  : 16
  Slot Number: 4
  Slot Active: All slot active */
  haudio_in_sai.SlotInit.FirstBitOffset = 0;
90003348:	4b13      	ldr	r3, [pc, #76]	; (90003398 <SAIx_In_Init+0x164>)
9000334a:	2200      	movs	r2, #0
9000334c:	655a      	str	r2, [r3, #84]	; 0x54
  haudio_in_sai.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
9000334e:	4b12      	ldr	r3, [pc, #72]	; (90003398 <SAIx_In_Init+0x164>)
90003350:	2200      	movs	r2, #0
90003352:	659a      	str	r2, [r3, #88]	; 0x58
  haudio_in_sai.SlotInit.SlotNumber = 4;
90003354:	4b10      	ldr	r3, [pc, #64]	; (90003398 <SAIx_In_Init+0x164>)
90003356:	2204      	movs	r2, #4
90003358:	65da      	str	r2, [r3, #92]	; 0x5c
  haudio_in_sai.SlotInit.SlotActive = SlotActive;
9000335a:	4a0f      	ldr	r2, [pc, #60]	; (90003398 <SAIx_In_Init+0x164>)
9000335c:	68bb      	ldr	r3, [r7, #8]
9000335e:	6613      	str	r3, [r2, #96]	; 0x60

  HAL_SAI_Init(&haudio_in_sai);
90003360:	480d      	ldr	r0, [pc, #52]	; (90003398 <SAIx_In_Init+0x164>)
90003362:	f002 ffb3 	bl	900062cc <HAL_SAI_Init>

  /* Enable SAI peripheral to generate MCLK */
  __HAL_SAI_ENABLE(&haudio_out_sai);
90003366:	4b0a      	ldr	r3, [pc, #40]	; (90003390 <SAIx_In_Init+0x15c>)
90003368:	681b      	ldr	r3, [r3, #0]
9000336a:	681a      	ldr	r2, [r3, #0]
9000336c:	4b08      	ldr	r3, [pc, #32]	; (90003390 <SAIx_In_Init+0x15c>)
9000336e:	681b      	ldr	r3, [r3, #0]
90003370:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90003374:	601a      	str	r2, [r3, #0]

  /* Enable SAI peripheral */
  __HAL_SAI_ENABLE(&haudio_in_sai);
90003376:	4b08      	ldr	r3, [pc, #32]	; (90003398 <SAIx_In_Init+0x164>)
90003378:	681b      	ldr	r3, [r3, #0]
9000337a:	681a      	ldr	r2, [r3, #0]
9000337c:	4b06      	ldr	r3, [pc, #24]	; (90003398 <SAIx_In_Init+0x164>)
9000337e:	681b      	ldr	r3, [r3, #0]
90003380:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90003384:	601a      	str	r2, [r3, #0]
}
90003386:	bf00      	nop
90003388:	3710      	adds	r7, #16
9000338a:	46bd      	mov	sp, r7
9000338c:	bd80      	pop	{r7, pc}
9000338e:	bf00      	nop
90003390:	200000b4 	.word	0x200000b4
90003394:	40015c04 	.word	0x40015c04
90003398:	20000138 	.word	0x20000138
9000339c:	40015c24 	.word	0x40015c24

900033a0 <SAIx_In_DeInit>:
/**
  * @brief  Deinitializes the output Audio Codec audio interface (SAI).
  * @retval None
  */
static void SAIx_In_DeInit(void)
{
900033a0:	b580      	push	{r7, lr}
900033a2:	af00      	add	r7, sp, #0
  /* Initialize the haudio_in_sai Instance parameter */
  haudio_in_sai.Instance = AUDIO_IN_SAIx;
900033a4:	4b07      	ldr	r3, [pc, #28]	; (900033c4 <SAIx_In_DeInit+0x24>)
900033a6:	4a08      	ldr	r2, [pc, #32]	; (900033c8 <SAIx_In_DeInit+0x28>)
900033a8:	601a      	str	r2, [r3, #0]

  /* Disable SAI peripheral */
  __HAL_SAI_DISABLE(&haudio_in_sai);
900033aa:	4b06      	ldr	r3, [pc, #24]	; (900033c4 <SAIx_In_DeInit+0x24>)
900033ac:	681b      	ldr	r3, [r3, #0]
900033ae:	681a      	ldr	r2, [r3, #0]
900033b0:	4b04      	ldr	r3, [pc, #16]	; (900033c4 <SAIx_In_DeInit+0x24>)
900033b2:	681b      	ldr	r3, [r3, #0]
900033b4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
900033b8:	601a      	str	r2, [r3, #0]

  HAL_SAI_DeInit(&haudio_in_sai);
900033ba:	4802      	ldr	r0, [pc, #8]	; (900033c4 <SAIx_In_DeInit+0x24>)
900033bc:	f003 f904 	bl	900065c8 <HAL_SAI_DeInit>
}
900033c0:	bf00      	nop
900033c2:	bd80      	pop	{r7, pc}
900033c4:	20000138 	.word	0x20000138
900033c8:	40015c24 	.word	0x40015c24

900033cc <BSP_SDRAM_Init>:
/**
  * @brief  Initializes the SDRAM device.
  * @retval SDRAM status
  */
uint8_t BSP_SDRAM_Init(void)
{ 
900033cc:	b580      	push	{r7, lr}
900033ce:	af00      	add	r7, sp, #0
  static uint8_t sdramstatus = SDRAM_ERROR;
  /* SDRAM device configuration */
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
900033d0:	4b29      	ldr	r3, [pc, #164]	; (90003478 <BSP_SDRAM_Init+0xac>)
900033d2:	4a2a      	ldr	r2, [pc, #168]	; (9000347c <BSP_SDRAM_Init+0xb0>)
900033d4:	601a      	str	r2, [r3, #0]
    
  /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
  Timing.LoadToActiveDelay    = 2;
900033d6:	4b2a      	ldr	r3, [pc, #168]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033d8:	2202      	movs	r2, #2
900033da:	601a      	str	r2, [r3, #0]
  Timing.ExitSelfRefreshDelay = 7;
900033dc:	4b28      	ldr	r3, [pc, #160]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033de:	2207      	movs	r2, #7
900033e0:	605a      	str	r2, [r3, #4]
  Timing.SelfRefreshTime      = 4;
900033e2:	4b27      	ldr	r3, [pc, #156]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033e4:	2204      	movs	r2, #4
900033e6:	609a      	str	r2, [r3, #8]
  Timing.RowCycleDelay        = 7;
900033e8:	4b25      	ldr	r3, [pc, #148]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033ea:	2207      	movs	r2, #7
900033ec:	60da      	str	r2, [r3, #12]
  Timing.WriteRecoveryTime    = 2;
900033ee:	4b24      	ldr	r3, [pc, #144]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033f0:	2202      	movs	r2, #2
900033f2:	611a      	str	r2, [r3, #16]
  Timing.RPDelay              = 2;
900033f4:	4b22      	ldr	r3, [pc, #136]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033f6:	2202      	movs	r2, #2
900033f8:	615a      	str	r2, [r3, #20]
  Timing.RCDDelay             = 2;
900033fa:	4b21      	ldr	r3, [pc, #132]	; (90003480 <BSP_SDRAM_Init+0xb4>)
900033fc:	2202      	movs	r2, #2
900033fe:	619a      	str	r2, [r3, #24]
  
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
90003400:	4b1d      	ldr	r3, [pc, #116]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003402:	2200      	movs	r2, #0
90003404:	605a      	str	r2, [r3, #4]
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
90003406:	4b1c      	ldr	r3, [pc, #112]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003408:	2200      	movs	r2, #0
9000340a:	609a      	str	r2, [r3, #8]
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
9000340c:	4b1a      	ldr	r3, [pc, #104]	; (90003478 <BSP_SDRAM_Init+0xac>)
9000340e:	2204      	movs	r2, #4
90003410:	60da      	str	r2, [r3, #12]
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
90003412:	4b19      	ldr	r3, [pc, #100]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003414:	2210      	movs	r2, #16
90003416:	611a      	str	r2, [r3, #16]
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
90003418:	4b17      	ldr	r3, [pc, #92]	; (90003478 <BSP_SDRAM_Init+0xac>)
9000341a:	2240      	movs	r2, #64	; 0x40
9000341c:	615a      	str	r2, [r3, #20]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
9000341e:	4b16      	ldr	r3, [pc, #88]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003420:	f44f 7280 	mov.w	r2, #256	; 0x100
90003424:	619a      	str	r2, [r3, #24]
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
90003426:	4b14      	ldr	r3, [pc, #80]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003428:	2200      	movs	r2, #0
9000342a:	61da      	str	r2, [r3, #28]
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
9000342c:	4b12      	ldr	r3, [pc, #72]	; (90003478 <BSP_SDRAM_Init+0xac>)
9000342e:	f44f 6200 	mov.w	r2, #2048	; 0x800
90003432:	621a      	str	r2, [r3, #32]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
90003434:	4b10      	ldr	r3, [pc, #64]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003436:	f44f 5280 	mov.w	r2, #4096	; 0x1000
9000343a:	625a      	str	r2, [r3, #36]	; 0x24
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
9000343c:	4b0e      	ldr	r3, [pc, #56]	; (90003478 <BSP_SDRAM_Init+0xac>)
9000343e:	2200      	movs	r2, #0
90003440:	629a      	str	r2, [r3, #40]	; 0x28
  
  /* SDRAM controller initialization */

  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
90003442:	2100      	movs	r1, #0
90003444:	480c      	ldr	r0, [pc, #48]	; (90003478 <BSP_SDRAM_Init+0xac>)
90003446:	f000 f87f 	bl	90003548 <BSP_SDRAM_MspInit>

  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
9000344a:	490d      	ldr	r1, [pc, #52]	; (90003480 <BSP_SDRAM_Init+0xb4>)
9000344c:	480a      	ldr	r0, [pc, #40]	; (90003478 <BSP_SDRAM_Init+0xac>)
9000344e:	f003 fb6e 	bl	90006b2e <HAL_SDRAM_Init>
90003452:	4603      	mov	r3, r0
90003454:	2b00      	cmp	r3, #0
90003456:	d003      	beq.n	90003460 <BSP_SDRAM_Init+0x94>
  {
    sdramstatus = SDRAM_ERROR;
90003458:	4b0a      	ldr	r3, [pc, #40]	; (90003484 <BSP_SDRAM_Init+0xb8>)
9000345a:	2201      	movs	r2, #1
9000345c:	701a      	strb	r2, [r3, #0]
9000345e:	e002      	b.n	90003466 <BSP_SDRAM_Init+0x9a>
  }
  else
  {
    sdramstatus = SDRAM_OK;
90003460:	4b08      	ldr	r3, [pc, #32]	; (90003484 <BSP_SDRAM_Init+0xb8>)
90003462:	2200      	movs	r2, #0
90003464:	701a      	strb	r2, [r3, #0]
  }
  
  /* SDRAM initialization sequence */
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
90003466:	f240 6003 	movw	r0, #1539	; 0x603
9000346a:	f000 f80d 	bl	90003488 <BSP_SDRAM_Initialization_sequence>
  
  return sdramstatus;
9000346e:	4b05      	ldr	r3, [pc, #20]	; (90003484 <BSP_SDRAM_Init+0xb8>)
90003470:	781b      	ldrb	r3, [r3, #0]
}
90003472:	4618      	mov	r0, r3
90003474:	bd80      	pop	{r7, pc}
90003476:	bf00      	nop
90003478:	20000358 	.word	0x20000358
9000347c:	a0000140 	.word	0xa0000140
90003480:	2000027c 	.word	0x2000027c
90003484:	20000035 	.word	0x20000035

90003488 <BSP_SDRAM_Initialization_sequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
90003488:	b580      	push	{r7, lr}
9000348a:	b084      	sub	sp, #16
9000348c:	af00      	add	r7, sp, #0
9000348e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpmrd = 0;
90003490:	2300      	movs	r3, #0
90003492:	60fb      	str	r3, [r7, #12]
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
90003494:	4b2a      	ldr	r3, [pc, #168]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
90003496:	2201      	movs	r2, #1
90003498:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
9000349a:	4b29      	ldr	r3, [pc, #164]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
9000349c:	2210      	movs	r2, #16
9000349e:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
900034a0:	4b27      	ldr	r3, [pc, #156]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034a2:	2201      	movs	r2, #1
900034a4:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
900034a6:	4b26      	ldr	r3, [pc, #152]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034a8:	2200      	movs	r2, #0
900034aa:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
900034ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
900034b0:	4923      	ldr	r1, [pc, #140]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034b2:	4824      	ldr	r0, [pc, #144]	; (90003544 <BSP_SDRAM_Initialization_sequence+0xbc>)
900034b4:	f003 fb79 	bl	90006baa <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
900034b8:	2001      	movs	r0, #1
900034ba:	f000 f9a3 	bl	90003804 <HAL_Delay>
    
  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
900034be:	4b20      	ldr	r3, [pc, #128]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034c0:	2202      	movs	r2, #2
900034c2:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
900034c4:	4b1e      	ldr	r3, [pc, #120]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034c6:	2210      	movs	r2, #16
900034c8:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
900034ca:	4b1d      	ldr	r3, [pc, #116]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034cc:	2201      	movs	r2, #1
900034ce:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
900034d0:	4b1b      	ldr	r3, [pc, #108]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034d2:	2200      	movs	r2, #0
900034d4:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
900034d6:	f64f 72ff 	movw	r2, #65535	; 0xffff
900034da:	4919      	ldr	r1, [pc, #100]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034dc:	4819      	ldr	r0, [pc, #100]	; (90003544 <BSP_SDRAM_Initialization_sequence+0xbc>)
900034de:	f003 fb64 	bl	90006baa <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
900034e2:	4b17      	ldr	r3, [pc, #92]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034e4:	2203      	movs	r2, #3
900034e6:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
900034e8:	4b15      	ldr	r3, [pc, #84]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034ea:	2210      	movs	r2, #16
900034ec:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 8;
900034ee:	4b14      	ldr	r3, [pc, #80]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034f0:	2208      	movs	r2, #8
900034f2:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
900034f4:	4b12      	ldr	r3, [pc, #72]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
900034f6:	2200      	movs	r2, #0
900034f8:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
900034fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
900034fe:	4910      	ldr	r1, [pc, #64]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
90003500:	4810      	ldr	r0, [pc, #64]	; (90003544 <BSP_SDRAM_Initialization_sequence+0xbc>)
90003502:	f003 fb52 	bl	90006baa <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
90003506:	f44f 7308 	mov.w	r3, #544	; 0x220
9000350a:	60fb      	str	r3, [r7, #12]
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
                     SDRAM_MODEREG_CAS_LATENCY_2           |\
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
9000350c:	4b0c      	ldr	r3, [pc, #48]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
9000350e:	2204      	movs	r2, #4
90003510:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
90003512:	4b0b      	ldr	r3, [pc, #44]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
90003514:	2210      	movs	r2, #16
90003516:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
90003518:	4b09      	ldr	r3, [pc, #36]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
9000351a:	2201      	movs	r2, #1
9000351c:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = tmpmrd;
9000351e:	68fb      	ldr	r3, [r7, #12]
90003520:	4a07      	ldr	r2, [pc, #28]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
90003522:	60d3      	str	r3, [r2, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
90003524:	f64f 72ff 	movw	r2, #65535	; 0xffff
90003528:	4905      	ldr	r1, [pc, #20]	; (90003540 <BSP_SDRAM_Initialization_sequence+0xb8>)
9000352a:	4806      	ldr	r0, [pc, #24]	; (90003544 <BSP_SDRAM_Initialization_sequence+0xbc>)
9000352c:	f003 fb3d 	bl	90006baa <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
90003530:	6879      	ldr	r1, [r7, #4]
90003532:	4804      	ldr	r0, [pc, #16]	; (90003544 <BSP_SDRAM_Initialization_sequence+0xbc>)
90003534:	f003 fb64 	bl	90006c00 <HAL_SDRAM_ProgramRefreshRate>
}
90003538:	bf00      	nop
9000353a:	3710      	adds	r7, #16
9000353c:	46bd      	mov	sp, r7
9000353e:	bd80      	pop	{r7, pc}
90003540:	20000298 	.word	0x20000298
90003544:	20000358 	.word	0x20000358

90003548 <BSP_SDRAM_MspInit>:
  * @param  hsdram: SDRAM handle
  * @param  Params
  * @retval None
  */
__weak void BSP_SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
{  
90003548:	b580      	push	{r7, lr}
9000354a:	b090      	sub	sp, #64	; 0x40
9000354c:	af00      	add	r7, sp, #0
9000354e:	6078      	str	r0, [r7, #4]
90003550:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
90003552:	4b70      	ldr	r3, [pc, #448]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003554:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90003556:	4a6f      	ldr	r2, [pc, #444]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003558:	f043 0301 	orr.w	r3, r3, #1
9000355c:	6393      	str	r3, [r2, #56]	; 0x38
9000355e:	4b6d      	ldr	r3, [pc, #436]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003560:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90003562:	f003 0301 	and.w	r3, r3, #1
90003566:	62bb      	str	r3, [r7, #40]	; 0x28
90003568:	6abb      	ldr	r3, [r7, #40]	; 0x28
  
  /* Enable chosen DMAx clock */
  __DMAx_CLK_ENABLE();
9000356a:	4b6a      	ldr	r3, [pc, #424]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
9000356c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000356e:	4a69      	ldr	r2, [pc, #420]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003570:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
90003574:	6313      	str	r3, [r2, #48]	; 0x30
90003576:	4b67      	ldr	r3, [pc, #412]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003578:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000357a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
9000357e:	627b      	str	r3, [r7, #36]	; 0x24
90003580:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOC_CLK_ENABLE();
90003582:	4b64      	ldr	r3, [pc, #400]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003584:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003586:	4a63      	ldr	r2, [pc, #396]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003588:	f043 0304 	orr.w	r3, r3, #4
9000358c:	6313      	str	r3, [r2, #48]	; 0x30
9000358e:	4b61      	ldr	r3, [pc, #388]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003590:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003592:	f003 0304 	and.w	r3, r3, #4
90003596:	623b      	str	r3, [r7, #32]
90003598:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
9000359a:	4b5e      	ldr	r3, [pc, #376]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
9000359c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000359e:	4a5d      	ldr	r2, [pc, #372]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035a0:	f043 0308 	orr.w	r3, r3, #8
900035a4:	6313      	str	r3, [r2, #48]	; 0x30
900035a6:	4b5b      	ldr	r3, [pc, #364]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035aa:	f003 0308 	and.w	r3, r3, #8
900035ae:	61fb      	str	r3, [r7, #28]
900035b0:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
900035b2:	4b58      	ldr	r3, [pc, #352]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035b6:	4a57      	ldr	r2, [pc, #348]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035b8:	f043 0310 	orr.w	r3, r3, #16
900035bc:	6313      	str	r3, [r2, #48]	; 0x30
900035be:	4b55      	ldr	r3, [pc, #340]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035c2:	f003 0310 	and.w	r3, r3, #16
900035c6:	61bb      	str	r3, [r7, #24]
900035c8:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOF_CLK_ENABLE();
900035ca:	4b52      	ldr	r3, [pc, #328]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035ce:	4a51      	ldr	r2, [pc, #324]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035d0:	f043 0320 	orr.w	r3, r3, #32
900035d4:	6313      	str	r3, [r2, #48]	; 0x30
900035d6:	4b4f      	ldr	r3, [pc, #316]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035da:	f003 0320 	and.w	r3, r3, #32
900035de:	617b      	str	r3, [r7, #20]
900035e0:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
900035e2:	4b4c      	ldr	r3, [pc, #304]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035e6:	4a4b      	ldr	r2, [pc, #300]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
900035ec:	6313      	str	r3, [r2, #48]	; 0x30
900035ee:	4b49      	ldr	r3, [pc, #292]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035f2:	f003 0340 	and.w	r3, r3, #64	; 0x40
900035f6:	613b      	str	r3, [r7, #16]
900035f8:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
900035fa:	4b46      	ldr	r3, [pc, #280]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
900035fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900035fe:	4a45      	ldr	r2, [pc, #276]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003600:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90003604:	6313      	str	r3, [r2, #48]	; 0x30
90003606:	4b43      	ldr	r3, [pc, #268]	; (90003714 <BSP_SDRAM_MspInit+0x1cc>)
90003608:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000360a:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000360e:	60fb      	str	r3, [r7, #12]
90003610:	68fb      	ldr	r3, [r7, #12]
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90003612:	2302      	movs	r3, #2
90003614:	633b      	str	r3, [r7, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
90003616:	2301      	movs	r3, #1
90003618:	637b      	str	r3, [r7, #52]	; 0x34
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
9000361a:	2302      	movs	r3, #2
9000361c:	63bb      	str	r3, [r7, #56]	; 0x38
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
9000361e:	230c      	movs	r3, #12
90003620:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
90003622:	2308      	movs	r3, #8
90003624:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
90003626:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000362a:	4619      	mov	r1, r3
9000362c:	483a      	ldr	r0, [pc, #232]	; (90003718 <BSP_SDRAM_MspInit+0x1d0>)
9000362e:	f000 fc6b 	bl	90003f08 <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
90003632:	f24c 7303 	movw	r3, #50947	; 0xc703
90003636:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90003638:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000363c:	4619      	mov	r1, r3
9000363e:	4837      	ldr	r0, [pc, #220]	; (9000371c <BSP_SDRAM_MspInit+0x1d4>)
90003640:	f000 fc62 	bl	90003f08 <HAL_GPIO_Init>

  /* GPIOE configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
90003644:	f64f 7383 	movw	r3, #65411	; 0xff83
90003648:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
9000364a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
9000364e:	4619      	mov	r1, r3
90003650:	4833      	ldr	r0, [pc, #204]	; (90003720 <BSP_SDRAM_MspInit+0x1d8>)
90003652:	f000 fc59 	bl	90003f08 <HAL_GPIO_Init>
  
  /* GPIOF configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
90003656:	f64f 033f 	movw	r3, #63551	; 0xf83f
9000365a:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
9000365c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90003660:	4619      	mov	r1, r3
90003662:	4830      	ldr	r0, [pc, #192]	; (90003724 <BSP_SDRAM_MspInit+0x1dc>)
90003664:	f000 fc50 	bl	90003f08 <HAL_GPIO_Init>
  
  /* GPIOG configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
90003668:	f248 1333 	movw	r3, #33075	; 0x8133
9000366c:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
9000366e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90003672:	4619      	mov	r1, r3
90003674:	482c      	ldr	r0, [pc, #176]	; (90003728 <BSP_SDRAM_MspInit+0x1e0>)
90003676:	f000 fc47 	bl	90003f08 <HAL_GPIO_Init>

  /* GPIOH configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
9000367a:	2328      	movs	r3, #40	; 0x28
9000367c:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
9000367e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
90003682:	4619      	mov	r1, r3
90003684:	4829      	ldr	r0, [pc, #164]	; (9000372c <BSP_SDRAM_MspInit+0x1e4>)
90003686:	f000 fc3f 	bl	90003f08 <HAL_GPIO_Init>
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
9000368a:	4b29      	ldr	r3, [pc, #164]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
9000368c:	2200      	movs	r2, #0
9000368e:	605a      	str	r2, [r3, #4]
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
90003690:	4b27      	ldr	r3, [pc, #156]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
90003692:	2280      	movs	r2, #128	; 0x80
90003694:	609a      	str	r2, [r3, #8]
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
90003696:	4b26      	ldr	r3, [pc, #152]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
90003698:	f44f 7200 	mov.w	r2, #512	; 0x200
9000369c:	60da      	str	r2, [r3, #12]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
9000369e:	4b24      	ldr	r3, [pc, #144]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036a0:	f44f 6280 	mov.w	r2, #1024	; 0x400
900036a4:	611a      	str	r2, [r3, #16]
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
900036a6:	4b22      	ldr	r3, [pc, #136]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036a8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
900036ac:	615a      	str	r2, [r3, #20]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
900036ae:	4b20      	ldr	r3, [pc, #128]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036b0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
900036b4:	619a      	str	r2, [r3, #24]
  dma_handle.Init.Mode                = DMA_NORMAL;
900036b6:	4b1e      	ldr	r3, [pc, #120]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036b8:	2200      	movs	r2, #0
900036ba:	61da      	str	r2, [r3, #28]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
900036bc:	4b1c      	ldr	r3, [pc, #112]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036be:	f44f 3200 	mov.w	r2, #131072	; 0x20000
900036c2:	621a      	str	r2, [r3, #32]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
900036c4:	4b1a      	ldr	r3, [pc, #104]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036c6:	2200      	movs	r2, #0
900036c8:	625a      	str	r2, [r3, #36]	; 0x24
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
900036ca:	4b19      	ldr	r3, [pc, #100]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036cc:	2203      	movs	r2, #3
900036ce:	629a      	str	r2, [r3, #40]	; 0x28
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
900036d0:	4b17      	ldr	r3, [pc, #92]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036d2:	2200      	movs	r2, #0
900036d4:	62da      	str	r2, [r3, #44]	; 0x2c
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
900036d6:	4b16      	ldr	r3, [pc, #88]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036d8:	2200      	movs	r2, #0
900036da:	631a      	str	r2, [r3, #48]	; 0x30
  
  dma_handle.Instance = SDRAM_DMAx_STREAM;
900036dc:	4b14      	ldr	r3, [pc, #80]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036de:	4a15      	ldr	r2, [pc, #84]	; (90003734 <BSP_SDRAM_MspInit+0x1ec>)
900036e0:	601a      	str	r2, [r3, #0]
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
900036e2:	687b      	ldr	r3, [r7, #4]
900036e4:	4a12      	ldr	r2, [pc, #72]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036e6:	631a      	str	r2, [r3, #48]	; 0x30
900036e8:	4a11      	ldr	r2, [pc, #68]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036ea:	687b      	ldr	r3, [r7, #4]
900036ec:	6393      	str	r3, [r2, #56]	; 0x38
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
900036ee:	4810      	ldr	r0, [pc, #64]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036f0:	f000 fa6c 	bl	90003bcc <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
900036f4:	480e      	ldr	r0, [pc, #56]	; (90003730 <BSP_SDRAM_MspInit+0x1e8>)
900036f6:	f000 f9bb 	bl	90003a70 <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0x0F, 0);
900036fa:	2200      	movs	r2, #0
900036fc:	210f      	movs	r1, #15
900036fe:	2038      	movs	r0, #56	; 0x38
90003700:	f000 f97f 	bl	90003a02 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
90003704:	2038      	movs	r0, #56	; 0x38
90003706:	f000 f998 	bl	90003a3a <HAL_NVIC_EnableIRQ>
}
9000370a:	bf00      	nop
9000370c:	3740      	adds	r7, #64	; 0x40
9000370e:	46bd      	mov	sp, r7
90003710:	bd80      	pop	{r7, pc}
90003712:	bf00      	nop
90003714:	40023800 	.word	0x40023800
90003718:	40020800 	.word	0x40020800
9000371c:	40020c00 	.word	0x40020c00
90003720:	40021000 	.word	0x40021000
90003724:	40021400 	.word	0x40021400
90003728:	40021800 	.word	0x40021800
9000372c:	40021c00 	.word	0x40021c00
90003730:	200002a8 	.word	0x200002a8
90003734:	40026410 	.word	0x40026410

90003738 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
90003738:	b580      	push	{r7, lr}
9000373a:	af00      	add	r7, sp, #0
   __HAL_FLASH_ART_ENABLE();
#endif /* ART_ACCLERATOR_ENABLE */

  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
9000373c:	4b08      	ldr	r3, [pc, #32]	; (90003760 <HAL_Init+0x28>)
9000373e:	681b      	ldr	r3, [r3, #0]
90003740:	4a07      	ldr	r2, [pc, #28]	; (90003760 <HAL_Init+0x28>)
90003742:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90003746:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
90003748:	2003      	movs	r0, #3
9000374a:	f000 f94f 	bl	900039ec <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
9000374e:	200f      	movs	r0, #15
90003750:	f000 f808 	bl	90003764 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
90003754:	f7fd fc9a 	bl	9000108c <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
90003758:	2300      	movs	r3, #0
}
9000375a:	4618      	mov	r0, r3
9000375c:	bd80      	pop	{r7, pc}
9000375e:	bf00      	nop
90003760:	40023c00 	.word	0x40023c00

90003764 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
90003764:	b580      	push	{r7, lr}
90003766:	b082      	sub	sp, #8
90003768:	af00      	add	r7, sp, #0
9000376a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
9000376c:	4b12      	ldr	r3, [pc, #72]	; (900037b8 <HAL_InitTick+0x54>)
9000376e:	681a      	ldr	r2, [r3, #0]
90003770:	4b12      	ldr	r3, [pc, #72]	; (900037bc <HAL_InitTick+0x58>)
90003772:	781b      	ldrb	r3, [r3, #0]
90003774:	4619      	mov	r1, r3
90003776:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
9000377a:	fbb3 f3f1 	udiv	r3, r3, r1
9000377e:	fbb2 f3f3 	udiv	r3, r2, r3
90003782:	4618      	mov	r0, r3
90003784:	f000 f967 	bl	90003a56 <HAL_SYSTICK_Config>
90003788:	4603      	mov	r3, r0
9000378a:	2b00      	cmp	r3, #0
9000378c:	d001      	beq.n	90003792 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
9000378e:	2301      	movs	r3, #1
90003790:	e00e      	b.n	900037b0 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
90003792:	687b      	ldr	r3, [r7, #4]
90003794:	2b0f      	cmp	r3, #15
90003796:	d80a      	bhi.n	900037ae <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
90003798:	2200      	movs	r2, #0
9000379a:	6879      	ldr	r1, [r7, #4]
9000379c:	f04f 30ff 	mov.w	r0, #4294967295
900037a0:	f000 f92f 	bl	90003a02 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
900037a4:	4a06      	ldr	r2, [pc, #24]	; (900037c0 <HAL_InitTick+0x5c>)
900037a6:	687b      	ldr	r3, [r7, #4]
900037a8:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
900037aa:	2300      	movs	r3, #0
900037ac:	e000      	b.n	900037b0 <HAL_InitTick+0x4c>
    return HAL_ERROR;
900037ae:	2301      	movs	r3, #1
}
900037b0:	4618      	mov	r0, r3
900037b2:	3708      	adds	r7, #8
900037b4:	46bd      	mov	sp, r7
900037b6:	bd80      	pop	{r7, pc}
900037b8:	20000000 	.word	0x20000000
900037bc:	2000003c 	.word	0x2000003c
900037c0:	20000038 	.word	0x20000038

900037c4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
900037c4:	b480      	push	{r7}
900037c6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
900037c8:	4b06      	ldr	r3, [pc, #24]	; (900037e4 <HAL_IncTick+0x20>)
900037ca:	781b      	ldrb	r3, [r3, #0]
900037cc:	461a      	mov	r2, r3
900037ce:	4b06      	ldr	r3, [pc, #24]	; (900037e8 <HAL_IncTick+0x24>)
900037d0:	681b      	ldr	r3, [r3, #0]
900037d2:	4413      	add	r3, r2
900037d4:	4a04      	ldr	r2, [pc, #16]	; (900037e8 <HAL_IncTick+0x24>)
900037d6:	6013      	str	r3, [r2, #0]
}
900037d8:	bf00      	nop
900037da:	46bd      	mov	sp, r7
900037dc:	f85d 7b04 	ldr.w	r7, [sp], #4
900037e0:	4770      	bx	lr
900037e2:	bf00      	nop
900037e4:	2000003c 	.word	0x2000003c
900037e8:	2000038c 	.word	0x2000038c

900037ec <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
900037ec:	b480      	push	{r7}
900037ee:	af00      	add	r7, sp, #0
  return uwTick;
900037f0:	4b03      	ldr	r3, [pc, #12]	; (90003800 <HAL_GetTick+0x14>)
900037f2:	681b      	ldr	r3, [r3, #0]
}
900037f4:	4618      	mov	r0, r3
900037f6:	46bd      	mov	sp, r7
900037f8:	f85d 7b04 	ldr.w	r7, [sp], #4
900037fc:	4770      	bx	lr
900037fe:	bf00      	nop
90003800:	2000038c 	.word	0x2000038c

90003804 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
90003804:	b580      	push	{r7, lr}
90003806:	b084      	sub	sp, #16
90003808:	af00      	add	r7, sp, #0
9000380a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
9000380c:	f7ff ffee 	bl	900037ec <HAL_GetTick>
90003810:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
90003812:	687b      	ldr	r3, [r7, #4]
90003814:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
90003816:	68fb      	ldr	r3, [r7, #12]
90003818:	f1b3 3fff 	cmp.w	r3, #4294967295
9000381c:	d005      	beq.n	9000382a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
9000381e:	4b0a      	ldr	r3, [pc, #40]	; (90003848 <HAL_Delay+0x44>)
90003820:	781b      	ldrb	r3, [r3, #0]
90003822:	461a      	mov	r2, r3
90003824:	68fb      	ldr	r3, [r7, #12]
90003826:	4413      	add	r3, r2
90003828:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
9000382a:	bf00      	nop
9000382c:	f7ff ffde 	bl	900037ec <HAL_GetTick>
90003830:	4602      	mov	r2, r0
90003832:	68bb      	ldr	r3, [r7, #8]
90003834:	1ad3      	subs	r3, r2, r3
90003836:	68fa      	ldr	r2, [r7, #12]
90003838:	429a      	cmp	r2, r3
9000383a:	d8f7      	bhi.n	9000382c <HAL_Delay+0x28>
  {
  }
}
9000383c:	bf00      	nop
9000383e:	bf00      	nop
90003840:	3710      	adds	r7, #16
90003842:	46bd      	mov	sp, r7
90003844:	bd80      	pop	{r7, pc}
90003846:	bf00      	nop
90003848:	2000003c 	.word	0x2000003c

9000384c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
9000384c:	b480      	push	{r7}
9000384e:	b085      	sub	sp, #20
90003850:	af00      	add	r7, sp, #0
90003852:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
90003854:	687b      	ldr	r3, [r7, #4]
90003856:	f003 0307 	and.w	r3, r3, #7
9000385a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
9000385c:	4b0b      	ldr	r3, [pc, #44]	; (9000388c <__NVIC_SetPriorityGrouping+0x40>)
9000385e:	68db      	ldr	r3, [r3, #12]
90003860:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
90003862:	68ba      	ldr	r2, [r7, #8]
90003864:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
90003868:	4013      	ands	r3, r2
9000386a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
9000386c:	68fb      	ldr	r3, [r7, #12]
9000386e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
90003870:	68bb      	ldr	r3, [r7, #8]
90003872:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
90003874:	4b06      	ldr	r3, [pc, #24]	; (90003890 <__NVIC_SetPriorityGrouping+0x44>)
90003876:	4313      	orrs	r3, r2
90003878:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
9000387a:	4a04      	ldr	r2, [pc, #16]	; (9000388c <__NVIC_SetPriorityGrouping+0x40>)
9000387c:	68bb      	ldr	r3, [r7, #8]
9000387e:	60d3      	str	r3, [r2, #12]
}
90003880:	bf00      	nop
90003882:	3714      	adds	r7, #20
90003884:	46bd      	mov	sp, r7
90003886:	f85d 7b04 	ldr.w	r7, [sp], #4
9000388a:	4770      	bx	lr
9000388c:	e000ed00 	.word	0xe000ed00
90003890:	05fa0000 	.word	0x05fa0000

90003894 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
90003894:	b480      	push	{r7}
90003896:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
90003898:	4b04      	ldr	r3, [pc, #16]	; (900038ac <__NVIC_GetPriorityGrouping+0x18>)
9000389a:	68db      	ldr	r3, [r3, #12]
9000389c:	0a1b      	lsrs	r3, r3, #8
9000389e:	f003 0307 	and.w	r3, r3, #7
}
900038a2:	4618      	mov	r0, r3
900038a4:	46bd      	mov	sp, r7
900038a6:	f85d 7b04 	ldr.w	r7, [sp], #4
900038aa:	4770      	bx	lr
900038ac:	e000ed00 	.word	0xe000ed00

900038b0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
900038b0:	b480      	push	{r7}
900038b2:	b083      	sub	sp, #12
900038b4:	af00      	add	r7, sp, #0
900038b6:	4603      	mov	r3, r0
900038b8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
900038ba:	f997 3007 	ldrsb.w	r3, [r7, #7]
900038be:	2b00      	cmp	r3, #0
900038c0:	db0b      	blt.n	900038da <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
900038c2:	79fb      	ldrb	r3, [r7, #7]
900038c4:	f003 021f 	and.w	r2, r3, #31
900038c8:	4907      	ldr	r1, [pc, #28]	; (900038e8 <__NVIC_EnableIRQ+0x38>)
900038ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
900038ce:	095b      	lsrs	r3, r3, #5
900038d0:	2001      	movs	r0, #1
900038d2:	fa00 f202 	lsl.w	r2, r0, r2
900038d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
900038da:	bf00      	nop
900038dc:	370c      	adds	r7, #12
900038de:	46bd      	mov	sp, r7
900038e0:	f85d 7b04 	ldr.w	r7, [sp], #4
900038e4:	4770      	bx	lr
900038e6:	bf00      	nop
900038e8:	e000e100 	.word	0xe000e100

900038ec <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
900038ec:	b480      	push	{r7}
900038ee:	b083      	sub	sp, #12
900038f0:	af00      	add	r7, sp, #0
900038f2:	4603      	mov	r3, r0
900038f4:	6039      	str	r1, [r7, #0]
900038f6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
900038f8:	f997 3007 	ldrsb.w	r3, [r7, #7]
900038fc:	2b00      	cmp	r3, #0
900038fe:	db0a      	blt.n	90003916 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90003900:	683b      	ldr	r3, [r7, #0]
90003902:	b2da      	uxtb	r2, r3
90003904:	490c      	ldr	r1, [pc, #48]	; (90003938 <__NVIC_SetPriority+0x4c>)
90003906:	f997 3007 	ldrsb.w	r3, [r7, #7]
9000390a:	0112      	lsls	r2, r2, #4
9000390c:	b2d2      	uxtb	r2, r2
9000390e:	440b      	add	r3, r1
90003910:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
90003914:	e00a      	b.n	9000392c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90003916:	683b      	ldr	r3, [r7, #0]
90003918:	b2da      	uxtb	r2, r3
9000391a:	4908      	ldr	r1, [pc, #32]	; (9000393c <__NVIC_SetPriority+0x50>)
9000391c:	79fb      	ldrb	r3, [r7, #7]
9000391e:	f003 030f 	and.w	r3, r3, #15
90003922:	3b04      	subs	r3, #4
90003924:	0112      	lsls	r2, r2, #4
90003926:	b2d2      	uxtb	r2, r2
90003928:	440b      	add	r3, r1
9000392a:	761a      	strb	r2, [r3, #24]
}
9000392c:	bf00      	nop
9000392e:	370c      	adds	r7, #12
90003930:	46bd      	mov	sp, r7
90003932:	f85d 7b04 	ldr.w	r7, [sp], #4
90003936:	4770      	bx	lr
90003938:	e000e100 	.word	0xe000e100
9000393c:	e000ed00 	.word	0xe000ed00

90003940 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
90003940:	b480      	push	{r7}
90003942:	b089      	sub	sp, #36	; 0x24
90003944:	af00      	add	r7, sp, #0
90003946:	60f8      	str	r0, [r7, #12]
90003948:	60b9      	str	r1, [r7, #8]
9000394a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
9000394c:	68fb      	ldr	r3, [r7, #12]
9000394e:	f003 0307 	and.w	r3, r3, #7
90003952:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
90003954:	69fb      	ldr	r3, [r7, #28]
90003956:	f1c3 0307 	rsb	r3, r3, #7
9000395a:	2b04      	cmp	r3, #4
9000395c:	bf28      	it	cs
9000395e:	2304      	movcs	r3, #4
90003960:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
90003962:	69fb      	ldr	r3, [r7, #28]
90003964:	3304      	adds	r3, #4
90003966:	2b06      	cmp	r3, #6
90003968:	d902      	bls.n	90003970 <NVIC_EncodePriority+0x30>
9000396a:	69fb      	ldr	r3, [r7, #28]
9000396c:	3b03      	subs	r3, #3
9000396e:	e000      	b.n	90003972 <NVIC_EncodePriority+0x32>
90003970:	2300      	movs	r3, #0
90003972:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90003974:	f04f 32ff 	mov.w	r2, #4294967295
90003978:	69bb      	ldr	r3, [r7, #24]
9000397a:	fa02 f303 	lsl.w	r3, r2, r3
9000397e:	43da      	mvns	r2, r3
90003980:	68bb      	ldr	r3, [r7, #8]
90003982:	401a      	ands	r2, r3
90003984:	697b      	ldr	r3, [r7, #20]
90003986:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
90003988:	f04f 31ff 	mov.w	r1, #4294967295
9000398c:	697b      	ldr	r3, [r7, #20]
9000398e:	fa01 f303 	lsl.w	r3, r1, r3
90003992:	43d9      	mvns	r1, r3
90003994:	687b      	ldr	r3, [r7, #4]
90003996:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90003998:	4313      	orrs	r3, r2
         );
}
9000399a:	4618      	mov	r0, r3
9000399c:	3724      	adds	r7, #36	; 0x24
9000399e:	46bd      	mov	sp, r7
900039a0:	f85d 7b04 	ldr.w	r7, [sp], #4
900039a4:	4770      	bx	lr
	...

900039a8 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
900039a8:	b580      	push	{r7, lr}
900039aa:	b082      	sub	sp, #8
900039ac:	af00      	add	r7, sp, #0
900039ae:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
900039b0:	687b      	ldr	r3, [r7, #4]
900039b2:	3b01      	subs	r3, #1
900039b4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
900039b8:	d301      	bcc.n	900039be <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
900039ba:	2301      	movs	r3, #1
900039bc:	e00f      	b.n	900039de <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
900039be:	4a0a      	ldr	r2, [pc, #40]	; (900039e8 <SysTick_Config+0x40>)
900039c0:	687b      	ldr	r3, [r7, #4]
900039c2:	3b01      	subs	r3, #1
900039c4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
900039c6:	210f      	movs	r1, #15
900039c8:	f04f 30ff 	mov.w	r0, #4294967295
900039cc:	f7ff ff8e 	bl	900038ec <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
900039d0:	4b05      	ldr	r3, [pc, #20]	; (900039e8 <SysTick_Config+0x40>)
900039d2:	2200      	movs	r2, #0
900039d4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
900039d6:	4b04      	ldr	r3, [pc, #16]	; (900039e8 <SysTick_Config+0x40>)
900039d8:	2207      	movs	r2, #7
900039da:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
900039dc:	2300      	movs	r3, #0
}
900039de:	4618      	mov	r0, r3
900039e0:	3708      	adds	r7, #8
900039e2:	46bd      	mov	sp, r7
900039e4:	bd80      	pop	{r7, pc}
900039e6:	bf00      	nop
900039e8:	e000e010 	.word	0xe000e010

900039ec <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
900039ec:	b580      	push	{r7, lr}
900039ee:	b082      	sub	sp, #8
900039f0:	af00      	add	r7, sp, #0
900039f2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
900039f4:	6878      	ldr	r0, [r7, #4]
900039f6:	f7ff ff29 	bl	9000384c <__NVIC_SetPriorityGrouping>
}
900039fa:	bf00      	nop
900039fc:	3708      	adds	r7, #8
900039fe:	46bd      	mov	sp, r7
90003a00:	bd80      	pop	{r7, pc}

90003a02 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
90003a02:	b580      	push	{r7, lr}
90003a04:	b086      	sub	sp, #24
90003a06:	af00      	add	r7, sp, #0
90003a08:	4603      	mov	r3, r0
90003a0a:	60b9      	str	r1, [r7, #8]
90003a0c:	607a      	str	r2, [r7, #4]
90003a0e:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
90003a10:	2300      	movs	r3, #0
90003a12:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
90003a14:	f7ff ff3e 	bl	90003894 <__NVIC_GetPriorityGrouping>
90003a18:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
90003a1a:	687a      	ldr	r2, [r7, #4]
90003a1c:	68b9      	ldr	r1, [r7, #8]
90003a1e:	6978      	ldr	r0, [r7, #20]
90003a20:	f7ff ff8e 	bl	90003940 <NVIC_EncodePriority>
90003a24:	4602      	mov	r2, r0
90003a26:	f997 300f 	ldrsb.w	r3, [r7, #15]
90003a2a:	4611      	mov	r1, r2
90003a2c:	4618      	mov	r0, r3
90003a2e:	f7ff ff5d 	bl	900038ec <__NVIC_SetPriority>
}
90003a32:	bf00      	nop
90003a34:	3718      	adds	r7, #24
90003a36:	46bd      	mov	sp, r7
90003a38:	bd80      	pop	{r7, pc}

90003a3a <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
90003a3a:	b580      	push	{r7, lr}
90003a3c:	b082      	sub	sp, #8
90003a3e:	af00      	add	r7, sp, #0
90003a40:	4603      	mov	r3, r0
90003a42:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
90003a44:	f997 3007 	ldrsb.w	r3, [r7, #7]
90003a48:	4618      	mov	r0, r3
90003a4a:	f7ff ff31 	bl	900038b0 <__NVIC_EnableIRQ>
}
90003a4e:	bf00      	nop
90003a50:	3708      	adds	r7, #8
90003a52:	46bd      	mov	sp, r7
90003a54:	bd80      	pop	{r7, pc}

90003a56 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
90003a56:	b580      	push	{r7, lr}
90003a58:	b082      	sub	sp, #8
90003a5a:	af00      	add	r7, sp, #0
90003a5c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
90003a5e:	6878      	ldr	r0, [r7, #4]
90003a60:	f7ff ffa2 	bl	900039a8 <SysTick_Config>
90003a64:	4603      	mov	r3, r0
}
90003a66:	4618      	mov	r0, r3
90003a68:	3708      	adds	r7, #8
90003a6a:	46bd      	mov	sp, r7
90003a6c:	bd80      	pop	{r7, pc}
	...

90003a70 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
90003a70:	b580      	push	{r7, lr}
90003a72:	b086      	sub	sp, #24
90003a74:	af00      	add	r7, sp, #0
90003a76:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
90003a78:	2300      	movs	r3, #0
90003a7a:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
90003a7c:	f7ff feb6 	bl	900037ec <HAL_GetTick>
90003a80:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
90003a82:	687b      	ldr	r3, [r7, #4]
90003a84:	2b00      	cmp	r3, #0
90003a86:	d101      	bne.n	90003a8c <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
90003a88:	2301      	movs	r3, #1
90003a8a:	e099      	b.n	90003bc0 <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
90003a8c:	687b      	ldr	r3, [r7, #4]
90003a8e:	2200      	movs	r2, #0
90003a90:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
90003a94:	687b      	ldr	r3, [r7, #4]
90003a96:	2202      	movs	r2, #2
90003a98:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
90003a9c:	687b      	ldr	r3, [r7, #4]
90003a9e:	681b      	ldr	r3, [r3, #0]
90003aa0:	681a      	ldr	r2, [r3, #0]
90003aa2:	687b      	ldr	r3, [r7, #4]
90003aa4:	681b      	ldr	r3, [r3, #0]
90003aa6:	f022 0201 	bic.w	r2, r2, #1
90003aaa:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
90003aac:	e00f      	b.n	90003ace <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
90003aae:	f7ff fe9d 	bl	900037ec <HAL_GetTick>
90003ab2:	4602      	mov	r2, r0
90003ab4:	693b      	ldr	r3, [r7, #16]
90003ab6:	1ad3      	subs	r3, r2, r3
90003ab8:	2b05      	cmp	r3, #5
90003aba:	d908      	bls.n	90003ace <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
90003abc:	687b      	ldr	r3, [r7, #4]
90003abe:	2220      	movs	r2, #32
90003ac0:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
90003ac2:	687b      	ldr	r3, [r7, #4]
90003ac4:	2203      	movs	r2, #3
90003ac6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
90003aca:	2303      	movs	r3, #3
90003acc:	e078      	b.n	90003bc0 <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
90003ace:	687b      	ldr	r3, [r7, #4]
90003ad0:	681b      	ldr	r3, [r3, #0]
90003ad2:	681b      	ldr	r3, [r3, #0]
90003ad4:	f003 0301 	and.w	r3, r3, #1
90003ad8:	2b00      	cmp	r3, #0
90003ada:	d1e8      	bne.n	90003aae <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
90003adc:	687b      	ldr	r3, [r7, #4]
90003ade:	681b      	ldr	r3, [r3, #0]
90003ae0:	681b      	ldr	r3, [r3, #0]
90003ae2:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
90003ae4:	697a      	ldr	r2, [r7, #20]
90003ae6:	4b38      	ldr	r3, [pc, #224]	; (90003bc8 <HAL_DMA_Init+0x158>)
90003ae8:	4013      	ands	r3, r2
90003aea:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
90003aec:	687b      	ldr	r3, [r7, #4]
90003aee:	685a      	ldr	r2, [r3, #4]
90003af0:	687b      	ldr	r3, [r7, #4]
90003af2:	689b      	ldr	r3, [r3, #8]
90003af4:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
90003af6:	687b      	ldr	r3, [r7, #4]
90003af8:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
90003afa:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
90003afc:	687b      	ldr	r3, [r7, #4]
90003afe:	691b      	ldr	r3, [r3, #16]
90003b00:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
90003b02:	687b      	ldr	r3, [r7, #4]
90003b04:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
90003b06:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
90003b08:	687b      	ldr	r3, [r7, #4]
90003b0a:	699b      	ldr	r3, [r3, #24]
90003b0c:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
90003b0e:	687b      	ldr	r3, [r7, #4]
90003b10:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
90003b12:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
90003b14:	687b      	ldr	r3, [r7, #4]
90003b16:	6a1b      	ldr	r3, [r3, #32]
90003b18:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
90003b1a:	697a      	ldr	r2, [r7, #20]
90003b1c:	4313      	orrs	r3, r2
90003b1e:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
90003b20:	687b      	ldr	r3, [r7, #4]
90003b22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90003b24:	2b04      	cmp	r3, #4
90003b26:	d107      	bne.n	90003b38 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
90003b28:	687b      	ldr	r3, [r7, #4]
90003b2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
90003b2c:	687b      	ldr	r3, [r7, #4]
90003b2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90003b30:	4313      	orrs	r3, r2
90003b32:	697a      	ldr	r2, [r7, #20]
90003b34:	4313      	orrs	r3, r2
90003b36:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
90003b38:	687b      	ldr	r3, [r7, #4]
90003b3a:	681b      	ldr	r3, [r3, #0]
90003b3c:	697a      	ldr	r2, [r7, #20]
90003b3e:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
90003b40:	687b      	ldr	r3, [r7, #4]
90003b42:	681b      	ldr	r3, [r3, #0]
90003b44:	695b      	ldr	r3, [r3, #20]
90003b46:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
90003b48:	697b      	ldr	r3, [r7, #20]
90003b4a:	f023 0307 	bic.w	r3, r3, #7
90003b4e:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
90003b50:	687b      	ldr	r3, [r7, #4]
90003b52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90003b54:	697a      	ldr	r2, [r7, #20]
90003b56:	4313      	orrs	r3, r2
90003b58:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
90003b5a:	687b      	ldr	r3, [r7, #4]
90003b5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90003b5e:	2b04      	cmp	r3, #4
90003b60:	d117      	bne.n	90003b92 <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
90003b62:	687b      	ldr	r3, [r7, #4]
90003b64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90003b66:	697a      	ldr	r2, [r7, #20]
90003b68:	4313      	orrs	r3, r2
90003b6a:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
90003b6c:	687b      	ldr	r3, [r7, #4]
90003b6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003b70:	2b00      	cmp	r3, #0
90003b72:	d00e      	beq.n	90003b92 <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
90003b74:	6878      	ldr	r0, [r7, #4]
90003b76:	f000 f94b 	bl	90003e10 <DMA_CheckFifoParam>
90003b7a:	4603      	mov	r3, r0
90003b7c:	2b00      	cmp	r3, #0
90003b7e:	d008      	beq.n	90003b92 <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
90003b80:	687b      	ldr	r3, [r7, #4]
90003b82:	2240      	movs	r2, #64	; 0x40
90003b84:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
90003b86:	687b      	ldr	r3, [r7, #4]
90003b88:	2201      	movs	r2, #1
90003b8a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
90003b8e:	2301      	movs	r3, #1
90003b90:	e016      	b.n	90003bc0 <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
90003b92:	687b      	ldr	r3, [r7, #4]
90003b94:	681b      	ldr	r3, [r3, #0]
90003b96:	697a      	ldr	r2, [r7, #20]
90003b98:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
90003b9a:	6878      	ldr	r0, [r7, #4]
90003b9c:	f000 f902 	bl	90003da4 <DMA_CalcBaseAndBitshift>
90003ba0:	4603      	mov	r3, r0
90003ba2:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
90003ba4:	687b      	ldr	r3, [r7, #4]
90003ba6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
90003ba8:	223f      	movs	r2, #63	; 0x3f
90003baa:	409a      	lsls	r2, r3
90003bac:	68fb      	ldr	r3, [r7, #12]
90003bae:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
90003bb0:	687b      	ldr	r3, [r7, #4]
90003bb2:	2200      	movs	r2, #0
90003bb4:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
90003bb6:	687b      	ldr	r3, [r7, #4]
90003bb8:	2201      	movs	r2, #1
90003bba:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
90003bbe:	2300      	movs	r3, #0
}
90003bc0:	4618      	mov	r0, r3
90003bc2:	3718      	adds	r7, #24
90003bc4:	46bd      	mov	sp, r7
90003bc6:	bd80      	pop	{r7, pc}
90003bc8:	f010803f 	.word	0xf010803f

90003bcc <HAL_DMA_DeInit>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
90003bcc:	b580      	push	{r7, lr}
90003bce:	b084      	sub	sp, #16
90003bd0:	af00      	add	r7, sp, #0
90003bd2:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
90003bd4:	687b      	ldr	r3, [r7, #4]
90003bd6:	2b00      	cmp	r3, #0
90003bd8:	d101      	bne.n	90003bde <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
90003bda:	2301      	movs	r3, #1
90003bdc:	e050      	b.n	90003c80 <HAL_DMA_DeInit+0xb4>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
90003bde:	687b      	ldr	r3, [r7, #4]
90003be0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
90003be4:	b2db      	uxtb	r3, r3
90003be6:	2b02      	cmp	r3, #2
90003be8:	d101      	bne.n	90003bee <HAL_DMA_DeInit+0x22>
  {
    /* Return error status */
    return HAL_BUSY;
90003bea:	2302      	movs	r3, #2
90003bec:	e048      	b.n	90003c80 <HAL_DMA_DeInit+0xb4>

  /* Check the parameters */
  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
90003bee:	687b      	ldr	r3, [r7, #4]
90003bf0:	681b      	ldr	r3, [r3, #0]
90003bf2:	681a      	ldr	r2, [r3, #0]
90003bf4:	687b      	ldr	r3, [r7, #4]
90003bf6:	681b      	ldr	r3, [r3, #0]
90003bf8:	f022 0201 	bic.w	r2, r2, #1
90003bfc:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0U;
90003bfe:	687b      	ldr	r3, [r7, #4]
90003c00:	681b      	ldr	r3, [r3, #0]
90003c02:	2200      	movs	r2, #0
90003c04:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0U;
90003c06:	687b      	ldr	r3, [r7, #4]
90003c08:	681b      	ldr	r3, [r3, #0]
90003c0a:	2200      	movs	r2, #0
90003c0c:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0U;
90003c0e:	687b      	ldr	r3, [r7, #4]
90003c10:	681b      	ldr	r3, [r3, #0]
90003c12:	2200      	movs	r2, #0
90003c14:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0U;
90003c16:	687b      	ldr	r3, [r7, #4]
90003c18:	681b      	ldr	r3, [r3, #0]
90003c1a:	2200      	movs	r2, #0
90003c1c:	60da      	str	r2, [r3, #12]
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0U;
90003c1e:	687b      	ldr	r3, [r7, #4]
90003c20:	681b      	ldr	r3, [r3, #0]
90003c22:	2200      	movs	r2, #0
90003c24:	611a      	str	r2, [r3, #16]
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
90003c26:	687b      	ldr	r3, [r7, #4]
90003c28:	681b      	ldr	r3, [r3, #0]
90003c2a:	2221      	movs	r2, #33	; 0x21
90003c2c:	615a      	str	r2, [r3, #20]
  
  /* Get DMA steam Base Address */  
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
90003c2e:	6878      	ldr	r0, [r7, #4]
90003c30:	f000 f8b8 	bl	90003da4 <DMA_CalcBaseAndBitshift>
90003c34:	4603      	mov	r3, r0
90003c36:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags at correct offset within the register */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
90003c38:	687b      	ldr	r3, [r7, #4]
90003c3a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
90003c3c:	223f      	movs	r2, #63	; 0x3f
90003c3e:	409a      	lsls	r2, r3
90003c40:	68fb      	ldr	r3, [r7, #12]
90003c42:	609a      	str	r2, [r3, #8]
  
  /* Clean all callbacks */
  hdma->XferCpltCallback = NULL;
90003c44:	687b      	ldr	r3, [r7, #4]
90003c46:	2200      	movs	r2, #0
90003c48:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback = NULL;
90003c4a:	687b      	ldr	r3, [r7, #4]
90003c4c:	2200      	movs	r2, #0
90003c4e:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback = NULL;
90003c50:	687b      	ldr	r3, [r7, #4]
90003c52:	2200      	movs	r2, #0
90003c54:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
90003c56:	687b      	ldr	r3, [r7, #4]
90003c58:	2200      	movs	r2, #0
90003c5a:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback = NULL;
90003c5c:	687b      	ldr	r3, [r7, #4]
90003c5e:	2200      	movs	r2, #0
90003c60:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback = NULL;  
90003c62:	687b      	ldr	r3, [r7, #4]
90003c64:	2200      	movs	r2, #0
90003c66:	651a      	str	r2, [r3, #80]	; 0x50

  /* Reset the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
90003c68:	687b      	ldr	r3, [r7, #4]
90003c6a:	2200      	movs	r2, #0
90003c6c:	655a      	str	r2, [r3, #84]	; 0x54

  /* Reset the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
90003c6e:	687b      	ldr	r3, [r7, #4]
90003c70:	2200      	movs	r2, #0
90003c72:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
90003c76:	687b      	ldr	r3, [r7, #4]
90003c78:	2200      	movs	r2, #0
90003c7a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
90003c7e:	2300      	movs	r3, #0
}
90003c80:	4618      	mov	r0, r3
90003c82:	3710      	adds	r7, #16
90003c84:	46bd      	mov	sp, r7
90003c86:	bd80      	pop	{r7, pc}

90003c88 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
90003c88:	b580      	push	{r7, lr}
90003c8a:	b086      	sub	sp, #24
90003c8c:	af00      	add	r7, sp, #0
90003c8e:	60f8      	str	r0, [r7, #12]
90003c90:	60b9      	str	r1, [r7, #8]
90003c92:	607a      	str	r2, [r7, #4]
90003c94:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
90003c96:	2300      	movs	r3, #0
90003c98:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
90003c9a:	68fb      	ldr	r3, [r7, #12]
90003c9c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90003c9e:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
90003ca0:	68fb      	ldr	r3, [r7, #12]
90003ca2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
90003ca6:	2b01      	cmp	r3, #1
90003ca8:	d101      	bne.n	90003cae <HAL_DMA_Start_IT+0x26>
90003caa:	2302      	movs	r3, #2
90003cac:	e048      	b.n	90003d40 <HAL_DMA_Start_IT+0xb8>
90003cae:	68fb      	ldr	r3, [r7, #12]
90003cb0:	2201      	movs	r2, #1
90003cb2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
90003cb6:	68fb      	ldr	r3, [r7, #12]
90003cb8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
90003cbc:	b2db      	uxtb	r3, r3
90003cbe:	2b01      	cmp	r3, #1
90003cc0:	d137      	bne.n	90003d32 <HAL_DMA_Start_IT+0xaa>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
90003cc2:	68fb      	ldr	r3, [r7, #12]
90003cc4:	2202      	movs	r2, #2
90003cc6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
90003cca:	68fb      	ldr	r3, [r7, #12]
90003ccc:	2200      	movs	r2, #0
90003cce:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
90003cd0:	683b      	ldr	r3, [r7, #0]
90003cd2:	687a      	ldr	r2, [r7, #4]
90003cd4:	68b9      	ldr	r1, [r7, #8]
90003cd6:	68f8      	ldr	r0, [r7, #12]
90003cd8:	f000 f836 	bl	90003d48 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
90003cdc:	68fb      	ldr	r3, [r7, #12]
90003cde:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
90003ce0:	223f      	movs	r2, #63	; 0x3f
90003ce2:	409a      	lsls	r2, r3
90003ce4:	693b      	ldr	r3, [r7, #16]
90003ce6:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
90003ce8:	68fb      	ldr	r3, [r7, #12]
90003cea:	681b      	ldr	r3, [r3, #0]
90003cec:	681a      	ldr	r2, [r3, #0]
90003cee:	68fb      	ldr	r3, [r7, #12]
90003cf0:	681b      	ldr	r3, [r3, #0]
90003cf2:	f042 0216 	orr.w	r2, r2, #22
90003cf6:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
90003cf8:	68fb      	ldr	r3, [r7, #12]
90003cfa:	681b      	ldr	r3, [r3, #0]
90003cfc:	695a      	ldr	r2, [r3, #20]
90003cfe:	68fb      	ldr	r3, [r7, #12]
90003d00:	681b      	ldr	r3, [r3, #0]
90003d02:	f042 0280 	orr.w	r2, r2, #128	; 0x80
90003d06:	615a      	str	r2, [r3, #20]
    
    if(hdma->XferHalfCpltCallback != NULL)
90003d08:	68fb      	ldr	r3, [r7, #12]
90003d0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90003d0c:	2b00      	cmp	r3, #0
90003d0e:	d007      	beq.n	90003d20 <HAL_DMA_Start_IT+0x98>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
90003d10:	68fb      	ldr	r3, [r7, #12]
90003d12:	681b      	ldr	r3, [r3, #0]
90003d14:	681a      	ldr	r2, [r3, #0]
90003d16:	68fb      	ldr	r3, [r7, #12]
90003d18:	681b      	ldr	r3, [r3, #0]
90003d1a:	f042 0208 	orr.w	r2, r2, #8
90003d1e:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
90003d20:	68fb      	ldr	r3, [r7, #12]
90003d22:	681b      	ldr	r3, [r3, #0]
90003d24:	681a      	ldr	r2, [r3, #0]
90003d26:	68fb      	ldr	r3, [r7, #12]
90003d28:	681b      	ldr	r3, [r3, #0]
90003d2a:	f042 0201 	orr.w	r2, r2, #1
90003d2e:	601a      	str	r2, [r3, #0]
90003d30:	e005      	b.n	90003d3e <HAL_DMA_Start_IT+0xb6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
90003d32:	68fb      	ldr	r3, [r7, #12]
90003d34:	2200      	movs	r2, #0
90003d36:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
90003d3a:	2302      	movs	r3, #2
90003d3c:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
90003d3e:	7dfb      	ldrb	r3, [r7, #23]
}
90003d40:	4618      	mov	r0, r3
90003d42:	3718      	adds	r7, #24
90003d44:	46bd      	mov	sp, r7
90003d46:	bd80      	pop	{r7, pc}

90003d48 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
90003d48:	b480      	push	{r7}
90003d4a:	b085      	sub	sp, #20
90003d4c:	af00      	add	r7, sp, #0
90003d4e:	60f8      	str	r0, [r7, #12]
90003d50:	60b9      	str	r1, [r7, #8]
90003d52:	607a      	str	r2, [r7, #4]
90003d54:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
90003d56:	68fb      	ldr	r3, [r7, #12]
90003d58:	681b      	ldr	r3, [r3, #0]
90003d5a:	681a      	ldr	r2, [r3, #0]
90003d5c:	68fb      	ldr	r3, [r7, #12]
90003d5e:	681b      	ldr	r3, [r3, #0]
90003d60:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
90003d64:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
90003d66:	68fb      	ldr	r3, [r7, #12]
90003d68:	681b      	ldr	r3, [r3, #0]
90003d6a:	683a      	ldr	r2, [r7, #0]
90003d6c:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
90003d6e:	68fb      	ldr	r3, [r7, #12]
90003d70:	689b      	ldr	r3, [r3, #8]
90003d72:	2b40      	cmp	r3, #64	; 0x40
90003d74:	d108      	bne.n	90003d88 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
90003d76:	68fb      	ldr	r3, [r7, #12]
90003d78:	681b      	ldr	r3, [r3, #0]
90003d7a:	687a      	ldr	r2, [r7, #4]
90003d7c:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
90003d7e:	68fb      	ldr	r3, [r7, #12]
90003d80:	681b      	ldr	r3, [r3, #0]
90003d82:	68ba      	ldr	r2, [r7, #8]
90003d84:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
90003d86:	e007      	b.n	90003d98 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
90003d88:	68fb      	ldr	r3, [r7, #12]
90003d8a:	681b      	ldr	r3, [r3, #0]
90003d8c:	68ba      	ldr	r2, [r7, #8]
90003d8e:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
90003d90:	68fb      	ldr	r3, [r7, #12]
90003d92:	681b      	ldr	r3, [r3, #0]
90003d94:	687a      	ldr	r2, [r7, #4]
90003d96:	60da      	str	r2, [r3, #12]
}
90003d98:	bf00      	nop
90003d9a:	3714      	adds	r7, #20
90003d9c:	46bd      	mov	sp, r7
90003d9e:	f85d 7b04 	ldr.w	r7, [sp], #4
90003da2:	4770      	bx	lr

90003da4 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
90003da4:	b480      	push	{r7}
90003da6:	b085      	sub	sp, #20
90003da8:	af00      	add	r7, sp, #0
90003daa:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
90003dac:	687b      	ldr	r3, [r7, #4]
90003dae:	681b      	ldr	r3, [r3, #0]
90003db0:	b2db      	uxtb	r3, r3
90003db2:	3b10      	subs	r3, #16
90003db4:	4a13      	ldr	r2, [pc, #76]	; (90003e04 <DMA_CalcBaseAndBitshift+0x60>)
90003db6:	fba2 2303 	umull	r2, r3, r2, r3
90003dba:	091b      	lsrs	r3, r3, #4
90003dbc:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
90003dbe:	4a12      	ldr	r2, [pc, #72]	; (90003e08 <DMA_CalcBaseAndBitshift+0x64>)
90003dc0:	68fb      	ldr	r3, [r7, #12]
90003dc2:	4413      	add	r3, r2
90003dc4:	781b      	ldrb	r3, [r3, #0]
90003dc6:	461a      	mov	r2, r3
90003dc8:	687b      	ldr	r3, [r7, #4]
90003dca:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
90003dcc:	68fb      	ldr	r3, [r7, #12]
90003dce:	2b03      	cmp	r3, #3
90003dd0:	d908      	bls.n	90003de4 <DMA_CalcBaseAndBitshift+0x40>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
90003dd2:	687b      	ldr	r3, [r7, #4]
90003dd4:	681b      	ldr	r3, [r3, #0]
90003dd6:	461a      	mov	r2, r3
90003dd8:	4b0c      	ldr	r3, [pc, #48]	; (90003e0c <DMA_CalcBaseAndBitshift+0x68>)
90003dda:	4013      	ands	r3, r2
90003ddc:	1d1a      	adds	r2, r3, #4
90003dde:	687b      	ldr	r3, [r7, #4]
90003de0:	659a      	str	r2, [r3, #88]	; 0x58
90003de2:	e006      	b.n	90003df2 <DMA_CalcBaseAndBitshift+0x4e>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
90003de4:	687b      	ldr	r3, [r7, #4]
90003de6:	681b      	ldr	r3, [r3, #0]
90003de8:	461a      	mov	r2, r3
90003dea:	4b08      	ldr	r3, [pc, #32]	; (90003e0c <DMA_CalcBaseAndBitshift+0x68>)
90003dec:	4013      	ands	r3, r2
90003dee:	687a      	ldr	r2, [r7, #4]
90003df0:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
90003df2:	687b      	ldr	r3, [r7, #4]
90003df4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
90003df6:	4618      	mov	r0, r3
90003df8:	3714      	adds	r7, #20
90003dfa:	46bd      	mov	sp, r7
90003dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
90003e00:	4770      	bx	lr
90003e02:	bf00      	nop
90003e04:	aaaaaaab 	.word	0xaaaaaaab
90003e08:	90006f44 	.word	0x90006f44
90003e0c:	fffffc00 	.word	0xfffffc00

90003e10 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
90003e10:	b480      	push	{r7}
90003e12:	b085      	sub	sp, #20
90003e14:	af00      	add	r7, sp, #0
90003e16:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
90003e18:	2300      	movs	r3, #0
90003e1a:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
90003e1c:	687b      	ldr	r3, [r7, #4]
90003e1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90003e20:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
90003e22:	687b      	ldr	r3, [r7, #4]
90003e24:	699b      	ldr	r3, [r3, #24]
90003e26:	2b00      	cmp	r3, #0
90003e28:	d11f      	bne.n	90003e6a <DMA_CheckFifoParam+0x5a>
90003e2a:	68bb      	ldr	r3, [r7, #8]
90003e2c:	2b03      	cmp	r3, #3
90003e2e:	d856      	bhi.n	90003ede <DMA_CheckFifoParam+0xce>
90003e30:	a201      	add	r2, pc, #4	; (adr r2, 90003e38 <DMA_CheckFifoParam+0x28>)
90003e32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90003e36:	bf00      	nop
90003e38:	90003e49 	.word	0x90003e49
90003e3c:	90003e5b 	.word	0x90003e5b
90003e40:	90003e49 	.word	0x90003e49
90003e44:	90003edf 	.word	0x90003edf
  {
    switch (tmp)
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
90003e48:	687b      	ldr	r3, [r7, #4]
90003e4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003e4c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
90003e50:	2b00      	cmp	r3, #0
90003e52:	d046      	beq.n	90003ee2 <DMA_CheckFifoParam+0xd2>
      {
        status = HAL_ERROR;
90003e54:	2301      	movs	r3, #1
90003e56:	73fb      	strb	r3, [r7, #15]
      }
      break;
90003e58:	e043      	b.n	90003ee2 <DMA_CheckFifoParam+0xd2>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
90003e5a:	687b      	ldr	r3, [r7, #4]
90003e5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003e5e:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
90003e62:	d140      	bne.n	90003ee6 <DMA_CheckFifoParam+0xd6>
      {
        status = HAL_ERROR;
90003e64:	2301      	movs	r3, #1
90003e66:	73fb      	strb	r3, [r7, #15]
      }
      break;
90003e68:	e03d      	b.n	90003ee6 <DMA_CheckFifoParam+0xd6>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
90003e6a:	687b      	ldr	r3, [r7, #4]
90003e6c:	699b      	ldr	r3, [r3, #24]
90003e6e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90003e72:	d121      	bne.n	90003eb8 <DMA_CheckFifoParam+0xa8>
90003e74:	68bb      	ldr	r3, [r7, #8]
90003e76:	2b03      	cmp	r3, #3
90003e78:	d837      	bhi.n	90003eea <DMA_CheckFifoParam+0xda>
90003e7a:	a201      	add	r2, pc, #4	; (adr r2, 90003e80 <DMA_CheckFifoParam+0x70>)
90003e7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90003e80:	90003e91 	.word	0x90003e91
90003e84:	90003e97 	.word	0x90003e97
90003e88:	90003e91 	.word	0x90003e91
90003e8c:	90003ea9 	.word	0x90003ea9
  {
    switch (tmp)
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
90003e90:	2301      	movs	r3, #1
90003e92:	73fb      	strb	r3, [r7, #15]
      break;
90003e94:	e030      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
90003e96:	687b      	ldr	r3, [r7, #4]
90003e98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003e9a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
90003e9e:	2b00      	cmp	r3, #0
90003ea0:	d025      	beq.n	90003eee <DMA_CheckFifoParam+0xde>
      {
        status = HAL_ERROR;
90003ea2:	2301      	movs	r3, #1
90003ea4:	73fb      	strb	r3, [r7, #15]
      }
      break;
90003ea6:	e022      	b.n	90003eee <DMA_CheckFifoParam+0xde>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
90003ea8:	687b      	ldr	r3, [r7, #4]
90003eaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003eac:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
90003eb0:	d11f      	bne.n	90003ef2 <DMA_CheckFifoParam+0xe2>
      {
        status = HAL_ERROR;
90003eb2:	2301      	movs	r3, #1
90003eb4:	73fb      	strb	r3, [r7, #15]
      }
      break;   
90003eb6:	e01c      	b.n	90003ef2 <DMA_CheckFifoParam+0xe2>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
90003eb8:	68bb      	ldr	r3, [r7, #8]
90003eba:	2b02      	cmp	r3, #2
90003ebc:	d903      	bls.n	90003ec6 <DMA_CheckFifoParam+0xb6>
90003ebe:	68bb      	ldr	r3, [r7, #8]
90003ec0:	2b03      	cmp	r3, #3
90003ec2:	d003      	beq.n	90003ecc <DMA_CheckFifoParam+0xbc>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
90003ec4:	e018      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      status = HAL_ERROR;
90003ec6:	2301      	movs	r3, #1
90003ec8:	73fb      	strb	r3, [r7, #15]
      break;
90003eca:	e015      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
90003ecc:	687b      	ldr	r3, [r7, #4]
90003ece:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90003ed0:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
90003ed4:	2b00      	cmp	r3, #0
90003ed6:	d00e      	beq.n	90003ef6 <DMA_CheckFifoParam+0xe6>
        status = HAL_ERROR;
90003ed8:	2301      	movs	r3, #1
90003eda:	73fb      	strb	r3, [r7, #15]
      break;
90003edc:	e00b      	b.n	90003ef6 <DMA_CheckFifoParam+0xe6>
      break;
90003ede:	bf00      	nop
90003ee0:	e00a      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      break;
90003ee2:	bf00      	nop
90003ee4:	e008      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      break;
90003ee6:	bf00      	nop
90003ee8:	e006      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      break;
90003eea:	bf00      	nop
90003eec:	e004      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      break;
90003eee:	bf00      	nop
90003ef0:	e002      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      break;   
90003ef2:	bf00      	nop
90003ef4:	e000      	b.n	90003ef8 <DMA_CheckFifoParam+0xe8>
      break;
90003ef6:	bf00      	nop
    }
  } 
  
  return status; 
90003ef8:	7bfb      	ldrb	r3, [r7, #15]
}
90003efa:	4618      	mov	r0, r3
90003efc:	3714      	adds	r7, #20
90003efe:	46bd      	mov	sp, r7
90003f00:	f85d 7b04 	ldr.w	r7, [sp], #4
90003f04:	4770      	bx	lr
90003f06:	bf00      	nop

90003f08 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
90003f08:	b480      	push	{r7}
90003f0a:	b089      	sub	sp, #36	; 0x24
90003f0c:	af00      	add	r7, sp, #0
90003f0e:	6078      	str	r0, [r7, #4]
90003f10:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
90003f12:	2300      	movs	r3, #0
90003f14:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
90003f16:	2300      	movs	r3, #0
90003f18:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
90003f1a:	2300      	movs	r3, #0
90003f1c:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
90003f1e:	2300      	movs	r3, #0
90003f20:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
90003f22:	2300      	movs	r3, #0
90003f24:	61fb      	str	r3, [r7, #28]
90003f26:	e175      	b.n	90004214 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
90003f28:	2201      	movs	r2, #1
90003f2a:	69fb      	ldr	r3, [r7, #28]
90003f2c:	fa02 f303 	lsl.w	r3, r2, r3
90003f30:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
90003f32:	683b      	ldr	r3, [r7, #0]
90003f34:	681b      	ldr	r3, [r3, #0]
90003f36:	697a      	ldr	r2, [r7, #20]
90003f38:	4013      	ands	r3, r2
90003f3a:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
90003f3c:	693a      	ldr	r2, [r7, #16]
90003f3e:	697b      	ldr	r3, [r7, #20]
90003f40:	429a      	cmp	r2, r3
90003f42:	f040 8164 	bne.w	9000420e <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
90003f46:	683b      	ldr	r3, [r7, #0]
90003f48:	685b      	ldr	r3, [r3, #4]
90003f4a:	2b01      	cmp	r3, #1
90003f4c:	d00b      	beq.n	90003f66 <HAL_GPIO_Init+0x5e>
90003f4e:	683b      	ldr	r3, [r7, #0]
90003f50:	685b      	ldr	r3, [r3, #4]
90003f52:	2b02      	cmp	r3, #2
90003f54:	d007      	beq.n	90003f66 <HAL_GPIO_Init+0x5e>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
90003f56:	683b      	ldr	r3, [r7, #0]
90003f58:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
90003f5a:	2b11      	cmp	r3, #17
90003f5c:	d003      	beq.n	90003f66 <HAL_GPIO_Init+0x5e>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
90003f5e:	683b      	ldr	r3, [r7, #0]
90003f60:	685b      	ldr	r3, [r3, #4]
90003f62:	2b12      	cmp	r3, #18
90003f64:	d130      	bne.n	90003fc8 <HAL_GPIO_Init+0xc0>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
90003f66:	687b      	ldr	r3, [r7, #4]
90003f68:	689b      	ldr	r3, [r3, #8]
90003f6a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
90003f6c:	69fb      	ldr	r3, [r7, #28]
90003f6e:	005b      	lsls	r3, r3, #1
90003f70:	2203      	movs	r2, #3
90003f72:	fa02 f303 	lsl.w	r3, r2, r3
90003f76:	43db      	mvns	r3, r3
90003f78:	69ba      	ldr	r2, [r7, #24]
90003f7a:	4013      	ands	r3, r2
90003f7c:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
90003f7e:	683b      	ldr	r3, [r7, #0]
90003f80:	68da      	ldr	r2, [r3, #12]
90003f82:	69fb      	ldr	r3, [r7, #28]
90003f84:	005b      	lsls	r3, r3, #1
90003f86:	fa02 f303 	lsl.w	r3, r2, r3
90003f8a:	69ba      	ldr	r2, [r7, #24]
90003f8c:	4313      	orrs	r3, r2
90003f8e:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
90003f90:	687b      	ldr	r3, [r7, #4]
90003f92:	69ba      	ldr	r2, [r7, #24]
90003f94:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
90003f96:	687b      	ldr	r3, [r7, #4]
90003f98:	685b      	ldr	r3, [r3, #4]
90003f9a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
90003f9c:	2201      	movs	r2, #1
90003f9e:	69fb      	ldr	r3, [r7, #28]
90003fa0:	fa02 f303 	lsl.w	r3, r2, r3
90003fa4:	43db      	mvns	r3, r3
90003fa6:	69ba      	ldr	r2, [r7, #24]
90003fa8:	4013      	ands	r3, r2
90003faa:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
90003fac:	683b      	ldr	r3, [r7, #0]
90003fae:	685b      	ldr	r3, [r3, #4]
90003fb0:	091b      	lsrs	r3, r3, #4
90003fb2:	f003 0201 	and.w	r2, r3, #1
90003fb6:	69fb      	ldr	r3, [r7, #28]
90003fb8:	fa02 f303 	lsl.w	r3, r2, r3
90003fbc:	69ba      	ldr	r2, [r7, #24]
90003fbe:	4313      	orrs	r3, r2
90003fc0:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
90003fc2:	687b      	ldr	r3, [r7, #4]
90003fc4:	69ba      	ldr	r2, [r7, #24]
90003fc6:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
90003fc8:	687b      	ldr	r3, [r7, #4]
90003fca:	68db      	ldr	r3, [r3, #12]
90003fcc:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
90003fce:	69fb      	ldr	r3, [r7, #28]
90003fd0:	005b      	lsls	r3, r3, #1
90003fd2:	2203      	movs	r2, #3
90003fd4:	fa02 f303 	lsl.w	r3, r2, r3
90003fd8:	43db      	mvns	r3, r3
90003fda:	69ba      	ldr	r2, [r7, #24]
90003fdc:	4013      	ands	r3, r2
90003fde:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
90003fe0:	683b      	ldr	r3, [r7, #0]
90003fe2:	689a      	ldr	r2, [r3, #8]
90003fe4:	69fb      	ldr	r3, [r7, #28]
90003fe6:	005b      	lsls	r3, r3, #1
90003fe8:	fa02 f303 	lsl.w	r3, r2, r3
90003fec:	69ba      	ldr	r2, [r7, #24]
90003fee:	4313      	orrs	r3, r2
90003ff0:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
90003ff2:	687b      	ldr	r3, [r7, #4]
90003ff4:	69ba      	ldr	r2, [r7, #24]
90003ff6:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
90003ff8:	683b      	ldr	r3, [r7, #0]
90003ffa:	685b      	ldr	r3, [r3, #4]
90003ffc:	2b02      	cmp	r3, #2
90003ffe:	d003      	beq.n	90004008 <HAL_GPIO_Init+0x100>
90004000:	683b      	ldr	r3, [r7, #0]
90004002:	685b      	ldr	r3, [r3, #4]
90004004:	2b12      	cmp	r3, #18
90004006:	d123      	bne.n	90004050 <HAL_GPIO_Init+0x148>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
90004008:	69fb      	ldr	r3, [r7, #28]
9000400a:	08da      	lsrs	r2, r3, #3
9000400c:	687b      	ldr	r3, [r7, #4]
9000400e:	3208      	adds	r2, #8
90004010:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
90004014:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
90004016:	69fb      	ldr	r3, [r7, #28]
90004018:	f003 0307 	and.w	r3, r3, #7
9000401c:	009b      	lsls	r3, r3, #2
9000401e:	220f      	movs	r2, #15
90004020:	fa02 f303 	lsl.w	r3, r2, r3
90004024:	43db      	mvns	r3, r3
90004026:	69ba      	ldr	r2, [r7, #24]
90004028:	4013      	ands	r3, r2
9000402a:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
9000402c:	683b      	ldr	r3, [r7, #0]
9000402e:	691a      	ldr	r2, [r3, #16]
90004030:	69fb      	ldr	r3, [r7, #28]
90004032:	f003 0307 	and.w	r3, r3, #7
90004036:	009b      	lsls	r3, r3, #2
90004038:	fa02 f303 	lsl.w	r3, r2, r3
9000403c:	69ba      	ldr	r2, [r7, #24]
9000403e:	4313      	orrs	r3, r2
90004040:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
90004042:	69fb      	ldr	r3, [r7, #28]
90004044:	08da      	lsrs	r2, r3, #3
90004046:	687b      	ldr	r3, [r7, #4]
90004048:	3208      	adds	r2, #8
9000404a:	69b9      	ldr	r1, [r7, #24]
9000404c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }
      
      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
90004050:	687b      	ldr	r3, [r7, #4]
90004052:	681b      	ldr	r3, [r3, #0]
90004054:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
90004056:	69fb      	ldr	r3, [r7, #28]
90004058:	005b      	lsls	r3, r3, #1
9000405a:	2203      	movs	r2, #3
9000405c:	fa02 f303 	lsl.w	r3, r2, r3
90004060:	43db      	mvns	r3, r3
90004062:	69ba      	ldr	r2, [r7, #24]
90004064:	4013      	ands	r3, r2
90004066:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
90004068:	683b      	ldr	r3, [r7, #0]
9000406a:	685b      	ldr	r3, [r3, #4]
9000406c:	f003 0203 	and.w	r2, r3, #3
90004070:	69fb      	ldr	r3, [r7, #28]
90004072:	005b      	lsls	r3, r3, #1
90004074:	fa02 f303 	lsl.w	r3, r2, r3
90004078:	69ba      	ldr	r2, [r7, #24]
9000407a:	4313      	orrs	r3, r2
9000407c:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
9000407e:	687b      	ldr	r3, [r7, #4]
90004080:	69ba      	ldr	r2, [r7, #24]
90004082:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
90004084:	683b      	ldr	r3, [r7, #0]
90004086:	685b      	ldr	r3, [r3, #4]
90004088:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
9000408c:	2b00      	cmp	r3, #0
9000408e:	f000 80be 	beq.w	9000420e <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
90004092:	4b66      	ldr	r3, [pc, #408]	; (9000422c <HAL_GPIO_Init+0x324>)
90004094:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90004096:	4a65      	ldr	r2, [pc, #404]	; (9000422c <HAL_GPIO_Init+0x324>)
90004098:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
9000409c:	6453      	str	r3, [r2, #68]	; 0x44
9000409e:	4b63      	ldr	r3, [pc, #396]	; (9000422c <HAL_GPIO_Init+0x324>)
900040a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
900040a2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
900040a6:	60fb      	str	r3, [r7, #12]
900040a8:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
900040aa:	4a61      	ldr	r2, [pc, #388]	; (90004230 <HAL_GPIO_Init+0x328>)
900040ac:	69fb      	ldr	r3, [r7, #28]
900040ae:	089b      	lsrs	r3, r3, #2
900040b0:	3302      	adds	r3, #2
900040b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
900040b6:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
900040b8:	69fb      	ldr	r3, [r7, #28]
900040ba:	f003 0303 	and.w	r3, r3, #3
900040be:	009b      	lsls	r3, r3, #2
900040c0:	220f      	movs	r2, #15
900040c2:	fa02 f303 	lsl.w	r3, r2, r3
900040c6:	43db      	mvns	r3, r3
900040c8:	69ba      	ldr	r2, [r7, #24]
900040ca:	4013      	ands	r3, r2
900040cc:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
900040ce:	687b      	ldr	r3, [r7, #4]
900040d0:	4a58      	ldr	r2, [pc, #352]	; (90004234 <HAL_GPIO_Init+0x32c>)
900040d2:	4293      	cmp	r3, r2
900040d4:	d037      	beq.n	90004146 <HAL_GPIO_Init+0x23e>
900040d6:	687b      	ldr	r3, [r7, #4]
900040d8:	4a57      	ldr	r2, [pc, #348]	; (90004238 <HAL_GPIO_Init+0x330>)
900040da:	4293      	cmp	r3, r2
900040dc:	d031      	beq.n	90004142 <HAL_GPIO_Init+0x23a>
900040de:	687b      	ldr	r3, [r7, #4]
900040e0:	4a56      	ldr	r2, [pc, #344]	; (9000423c <HAL_GPIO_Init+0x334>)
900040e2:	4293      	cmp	r3, r2
900040e4:	d02b      	beq.n	9000413e <HAL_GPIO_Init+0x236>
900040e6:	687b      	ldr	r3, [r7, #4]
900040e8:	4a55      	ldr	r2, [pc, #340]	; (90004240 <HAL_GPIO_Init+0x338>)
900040ea:	4293      	cmp	r3, r2
900040ec:	d025      	beq.n	9000413a <HAL_GPIO_Init+0x232>
900040ee:	687b      	ldr	r3, [r7, #4]
900040f0:	4a54      	ldr	r2, [pc, #336]	; (90004244 <HAL_GPIO_Init+0x33c>)
900040f2:	4293      	cmp	r3, r2
900040f4:	d01f      	beq.n	90004136 <HAL_GPIO_Init+0x22e>
900040f6:	687b      	ldr	r3, [r7, #4]
900040f8:	4a53      	ldr	r2, [pc, #332]	; (90004248 <HAL_GPIO_Init+0x340>)
900040fa:	4293      	cmp	r3, r2
900040fc:	d019      	beq.n	90004132 <HAL_GPIO_Init+0x22a>
900040fe:	687b      	ldr	r3, [r7, #4]
90004100:	4a52      	ldr	r2, [pc, #328]	; (9000424c <HAL_GPIO_Init+0x344>)
90004102:	4293      	cmp	r3, r2
90004104:	d013      	beq.n	9000412e <HAL_GPIO_Init+0x226>
90004106:	687b      	ldr	r3, [r7, #4]
90004108:	4a51      	ldr	r2, [pc, #324]	; (90004250 <HAL_GPIO_Init+0x348>)
9000410a:	4293      	cmp	r3, r2
9000410c:	d00d      	beq.n	9000412a <HAL_GPIO_Init+0x222>
9000410e:	687b      	ldr	r3, [r7, #4]
90004110:	4a50      	ldr	r2, [pc, #320]	; (90004254 <HAL_GPIO_Init+0x34c>)
90004112:	4293      	cmp	r3, r2
90004114:	d007      	beq.n	90004126 <HAL_GPIO_Init+0x21e>
90004116:	687b      	ldr	r3, [r7, #4]
90004118:	4a4f      	ldr	r2, [pc, #316]	; (90004258 <HAL_GPIO_Init+0x350>)
9000411a:	4293      	cmp	r3, r2
9000411c:	d101      	bne.n	90004122 <HAL_GPIO_Init+0x21a>
9000411e:	2309      	movs	r3, #9
90004120:	e012      	b.n	90004148 <HAL_GPIO_Init+0x240>
90004122:	230a      	movs	r3, #10
90004124:	e010      	b.n	90004148 <HAL_GPIO_Init+0x240>
90004126:	2308      	movs	r3, #8
90004128:	e00e      	b.n	90004148 <HAL_GPIO_Init+0x240>
9000412a:	2307      	movs	r3, #7
9000412c:	e00c      	b.n	90004148 <HAL_GPIO_Init+0x240>
9000412e:	2306      	movs	r3, #6
90004130:	e00a      	b.n	90004148 <HAL_GPIO_Init+0x240>
90004132:	2305      	movs	r3, #5
90004134:	e008      	b.n	90004148 <HAL_GPIO_Init+0x240>
90004136:	2304      	movs	r3, #4
90004138:	e006      	b.n	90004148 <HAL_GPIO_Init+0x240>
9000413a:	2303      	movs	r3, #3
9000413c:	e004      	b.n	90004148 <HAL_GPIO_Init+0x240>
9000413e:	2302      	movs	r3, #2
90004140:	e002      	b.n	90004148 <HAL_GPIO_Init+0x240>
90004142:	2301      	movs	r3, #1
90004144:	e000      	b.n	90004148 <HAL_GPIO_Init+0x240>
90004146:	2300      	movs	r3, #0
90004148:	69fa      	ldr	r2, [r7, #28]
9000414a:	f002 0203 	and.w	r2, r2, #3
9000414e:	0092      	lsls	r2, r2, #2
90004150:	4093      	lsls	r3, r2
90004152:	69ba      	ldr	r2, [r7, #24]
90004154:	4313      	orrs	r3, r2
90004156:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
90004158:	4935      	ldr	r1, [pc, #212]	; (90004230 <HAL_GPIO_Init+0x328>)
9000415a:	69fb      	ldr	r3, [r7, #28]
9000415c:	089b      	lsrs	r3, r3, #2
9000415e:	3302      	adds	r3, #2
90004160:	69ba      	ldr	r2, [r7, #24]
90004162:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
90004166:	4b3d      	ldr	r3, [pc, #244]	; (9000425c <HAL_GPIO_Init+0x354>)
90004168:	681b      	ldr	r3, [r3, #0]
9000416a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
9000416c:	693b      	ldr	r3, [r7, #16]
9000416e:	43db      	mvns	r3, r3
90004170:	69ba      	ldr	r2, [r7, #24]
90004172:	4013      	ands	r3, r2
90004174:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
90004176:	683b      	ldr	r3, [r7, #0]
90004178:	685b      	ldr	r3, [r3, #4]
9000417a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
9000417e:	2b00      	cmp	r3, #0
90004180:	d003      	beq.n	9000418a <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
90004182:	69ba      	ldr	r2, [r7, #24]
90004184:	693b      	ldr	r3, [r7, #16]
90004186:	4313      	orrs	r3, r2
90004188:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
9000418a:	4a34      	ldr	r2, [pc, #208]	; (9000425c <HAL_GPIO_Init+0x354>)
9000418c:	69bb      	ldr	r3, [r7, #24]
9000418e:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
90004190:	4b32      	ldr	r3, [pc, #200]	; (9000425c <HAL_GPIO_Init+0x354>)
90004192:	685b      	ldr	r3, [r3, #4]
90004194:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
90004196:	693b      	ldr	r3, [r7, #16]
90004198:	43db      	mvns	r3, r3
9000419a:	69ba      	ldr	r2, [r7, #24]
9000419c:	4013      	ands	r3, r2
9000419e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
900041a0:	683b      	ldr	r3, [r7, #0]
900041a2:	685b      	ldr	r3, [r3, #4]
900041a4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
900041a8:	2b00      	cmp	r3, #0
900041aa:	d003      	beq.n	900041b4 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
900041ac:	69ba      	ldr	r2, [r7, #24]
900041ae:	693b      	ldr	r3, [r7, #16]
900041b0:	4313      	orrs	r3, r2
900041b2:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
900041b4:	4a29      	ldr	r2, [pc, #164]	; (9000425c <HAL_GPIO_Init+0x354>)
900041b6:	69bb      	ldr	r3, [r7, #24]
900041b8:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
900041ba:	4b28      	ldr	r3, [pc, #160]	; (9000425c <HAL_GPIO_Init+0x354>)
900041bc:	689b      	ldr	r3, [r3, #8]
900041be:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
900041c0:	693b      	ldr	r3, [r7, #16]
900041c2:	43db      	mvns	r3, r3
900041c4:	69ba      	ldr	r2, [r7, #24]
900041c6:	4013      	ands	r3, r2
900041c8:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
900041ca:	683b      	ldr	r3, [r7, #0]
900041cc:	685b      	ldr	r3, [r3, #4]
900041ce:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
900041d2:	2b00      	cmp	r3, #0
900041d4:	d003      	beq.n	900041de <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
900041d6:	69ba      	ldr	r2, [r7, #24]
900041d8:	693b      	ldr	r3, [r7, #16]
900041da:	4313      	orrs	r3, r2
900041dc:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
900041de:	4a1f      	ldr	r2, [pc, #124]	; (9000425c <HAL_GPIO_Init+0x354>)
900041e0:	69bb      	ldr	r3, [r7, #24]
900041e2:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
900041e4:	4b1d      	ldr	r3, [pc, #116]	; (9000425c <HAL_GPIO_Init+0x354>)
900041e6:	68db      	ldr	r3, [r3, #12]
900041e8:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
900041ea:	693b      	ldr	r3, [r7, #16]
900041ec:	43db      	mvns	r3, r3
900041ee:	69ba      	ldr	r2, [r7, #24]
900041f0:	4013      	ands	r3, r2
900041f2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
900041f4:	683b      	ldr	r3, [r7, #0]
900041f6:	685b      	ldr	r3, [r3, #4]
900041f8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
900041fc:	2b00      	cmp	r3, #0
900041fe:	d003      	beq.n	90004208 <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
90004200:	69ba      	ldr	r2, [r7, #24]
90004202:	693b      	ldr	r3, [r7, #16]
90004204:	4313      	orrs	r3, r2
90004206:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
90004208:	4a14      	ldr	r2, [pc, #80]	; (9000425c <HAL_GPIO_Init+0x354>)
9000420a:	69bb      	ldr	r3, [r7, #24]
9000420c:	60d3      	str	r3, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
9000420e:	69fb      	ldr	r3, [r7, #28]
90004210:	3301      	adds	r3, #1
90004212:	61fb      	str	r3, [r7, #28]
90004214:	69fb      	ldr	r3, [r7, #28]
90004216:	2b0f      	cmp	r3, #15
90004218:	f67f ae86 	bls.w	90003f28 <HAL_GPIO_Init+0x20>
      }
    }
  }
}
9000421c:	bf00      	nop
9000421e:	bf00      	nop
90004220:	3724      	adds	r7, #36	; 0x24
90004222:	46bd      	mov	sp, r7
90004224:	f85d 7b04 	ldr.w	r7, [sp], #4
90004228:	4770      	bx	lr
9000422a:	bf00      	nop
9000422c:	40023800 	.word	0x40023800
90004230:	40013800 	.word	0x40013800
90004234:	40020000 	.word	0x40020000
90004238:	40020400 	.word	0x40020400
9000423c:	40020800 	.word	0x40020800
90004240:	40020c00 	.word	0x40020c00
90004244:	40021000 	.word	0x40021000
90004248:	40021400 	.word	0x40021400
9000424c:	40021800 	.word	0x40021800
90004250:	40021c00 	.word	0x40021c00
90004254:	40022000 	.word	0x40022000
90004258:	40022400 	.word	0x40022400
9000425c:	40013c00 	.word	0x40013c00

90004260 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
90004260:	b480      	push	{r7}
90004262:	b083      	sub	sp, #12
90004264:	af00      	add	r7, sp, #0
90004266:	6078      	str	r0, [r7, #4]
90004268:	460b      	mov	r3, r1
9000426a:	807b      	strh	r3, [r7, #2]
9000426c:	4613      	mov	r3, r2
9000426e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
90004270:	787b      	ldrb	r3, [r7, #1]
90004272:	2b00      	cmp	r3, #0
90004274:	d003      	beq.n	9000427e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
90004276:	887a      	ldrh	r2, [r7, #2]
90004278:	687b      	ldr	r3, [r7, #4]
9000427a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  }
}
9000427c:	e003      	b.n	90004286 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
9000427e:	887b      	ldrh	r3, [r7, #2]
90004280:	041a      	lsls	r2, r3, #16
90004282:	687b      	ldr	r3, [r7, #4]
90004284:	619a      	str	r2, [r3, #24]
}
90004286:	bf00      	nop
90004288:	370c      	adds	r7, #12
9000428a:	46bd      	mov	sp, r7
9000428c:	f85d 7b04 	ldr.w	r7, [sp], #4
90004290:	4770      	bx	lr

90004292 <HAL_GPIO_TogglePin>:
  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
90004292:	b480      	push	{r7}
90004294:	b085      	sub	sp, #20
90004296:	af00      	add	r7, sp, #0
90004298:	6078      	str	r0, [r7, #4]
9000429a:	460b      	mov	r3, r1
9000429c:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
9000429e:	687b      	ldr	r3, [r7, #4]
900042a0:	695b      	ldr	r3, [r3, #20]
900042a2:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
900042a4:	887a      	ldrh	r2, [r7, #2]
900042a6:	68fb      	ldr	r3, [r7, #12]
900042a8:	4013      	ands	r3, r2
900042aa:	041a      	lsls	r2, r3, #16
900042ac:	68fb      	ldr	r3, [r7, #12]
900042ae:	43d9      	mvns	r1, r3
900042b0:	887b      	ldrh	r3, [r7, #2]
900042b2:	400b      	ands	r3, r1
900042b4:	431a      	orrs	r2, r3
900042b6:	687b      	ldr	r3, [r7, #4]
900042b8:	619a      	str	r2, [r3, #24]
}
900042ba:	bf00      	nop
900042bc:	3714      	adds	r7, #20
900042be:	46bd      	mov	sp, r7
900042c0:	f85d 7b04 	ldr.w	r7, [sp], #4
900042c4:	4770      	bx	lr
	...

900042c8 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
900042c8:	b580      	push	{r7, lr}
900042ca:	b082      	sub	sp, #8
900042cc:	af00      	add	r7, sp, #0
900042ce:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
900042d0:	687b      	ldr	r3, [r7, #4]
900042d2:	2b00      	cmp	r3, #0
900042d4:	d101      	bne.n	900042da <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
900042d6:	2301      	movs	r3, #1
900042d8:	e07f      	b.n	900043da <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
900042da:	687b      	ldr	r3, [r7, #4]
900042dc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
900042e0:	b2db      	uxtb	r3, r3
900042e2:	2b00      	cmp	r3, #0
900042e4:	d106      	bne.n	900042f4 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
900042e6:	687b      	ldr	r3, [r7, #4]
900042e8:	2200      	movs	r2, #0
900042ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
900042ee:	6878      	ldr	r0, [r7, #4]
900042f0:	f000 f8a9 	bl	90004446 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
900042f4:	687b      	ldr	r3, [r7, #4]
900042f6:	2224      	movs	r2, #36	; 0x24
900042f8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
900042fc:	687b      	ldr	r3, [r7, #4]
900042fe:	681b      	ldr	r3, [r3, #0]
90004300:	681a      	ldr	r2, [r3, #0]
90004302:	687b      	ldr	r3, [r7, #4]
90004304:	681b      	ldr	r3, [r3, #0]
90004306:	f022 0201 	bic.w	r2, r2, #1
9000430a:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
9000430c:	687b      	ldr	r3, [r7, #4]
9000430e:	685a      	ldr	r2, [r3, #4]
90004310:	687b      	ldr	r3, [r7, #4]
90004312:	681b      	ldr	r3, [r3, #0]
90004314:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
90004318:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
9000431a:	687b      	ldr	r3, [r7, #4]
9000431c:	681b      	ldr	r3, [r3, #0]
9000431e:	689a      	ldr	r2, [r3, #8]
90004320:	687b      	ldr	r3, [r7, #4]
90004322:	681b      	ldr	r3, [r3, #0]
90004324:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
90004328:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
9000432a:	687b      	ldr	r3, [r7, #4]
9000432c:	68db      	ldr	r3, [r3, #12]
9000432e:	2b01      	cmp	r3, #1
90004330:	d107      	bne.n	90004342 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
90004332:	687b      	ldr	r3, [r7, #4]
90004334:	689a      	ldr	r2, [r3, #8]
90004336:	687b      	ldr	r3, [r7, #4]
90004338:	681b      	ldr	r3, [r3, #0]
9000433a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
9000433e:	609a      	str	r2, [r3, #8]
90004340:	e006      	b.n	90004350 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
90004342:	687b      	ldr	r3, [r7, #4]
90004344:	689a      	ldr	r2, [r3, #8]
90004346:	687b      	ldr	r3, [r7, #4]
90004348:	681b      	ldr	r3, [r3, #0]
9000434a:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
9000434e:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
90004350:	687b      	ldr	r3, [r7, #4]
90004352:	68db      	ldr	r3, [r3, #12]
90004354:	2b02      	cmp	r3, #2
90004356:	d104      	bne.n	90004362 <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
90004358:	687b      	ldr	r3, [r7, #4]
9000435a:	681b      	ldr	r3, [r3, #0]
9000435c:	f44f 6200 	mov.w	r2, #2048	; 0x800
90004360:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
90004362:	687b      	ldr	r3, [r7, #4]
90004364:	681b      	ldr	r3, [r3, #0]
90004366:	6859      	ldr	r1, [r3, #4]
90004368:	687b      	ldr	r3, [r7, #4]
9000436a:	681a      	ldr	r2, [r3, #0]
9000436c:	4b1d      	ldr	r3, [pc, #116]	; (900043e4 <HAL_I2C_Init+0x11c>)
9000436e:	430b      	orrs	r3, r1
90004370:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
90004372:	687b      	ldr	r3, [r7, #4]
90004374:	681b      	ldr	r3, [r3, #0]
90004376:	68da      	ldr	r2, [r3, #12]
90004378:	687b      	ldr	r3, [r7, #4]
9000437a:	681b      	ldr	r3, [r3, #0]
9000437c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
90004380:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
90004382:	687b      	ldr	r3, [r7, #4]
90004384:	691a      	ldr	r2, [r3, #16]
90004386:	687b      	ldr	r3, [r7, #4]
90004388:	695b      	ldr	r3, [r3, #20]
9000438a:	ea42 0103 	orr.w	r1, r2, r3
9000438e:	687b      	ldr	r3, [r7, #4]
90004390:	699b      	ldr	r3, [r3, #24]
90004392:	021a      	lsls	r2, r3, #8
90004394:	687b      	ldr	r3, [r7, #4]
90004396:	681b      	ldr	r3, [r3, #0]
90004398:	430a      	orrs	r2, r1
9000439a:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
9000439c:	687b      	ldr	r3, [r7, #4]
9000439e:	69d9      	ldr	r1, [r3, #28]
900043a0:	687b      	ldr	r3, [r7, #4]
900043a2:	6a1a      	ldr	r2, [r3, #32]
900043a4:	687b      	ldr	r3, [r7, #4]
900043a6:	681b      	ldr	r3, [r3, #0]
900043a8:	430a      	orrs	r2, r1
900043aa:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
900043ac:	687b      	ldr	r3, [r7, #4]
900043ae:	681b      	ldr	r3, [r3, #0]
900043b0:	681a      	ldr	r2, [r3, #0]
900043b2:	687b      	ldr	r3, [r7, #4]
900043b4:	681b      	ldr	r3, [r3, #0]
900043b6:	f042 0201 	orr.w	r2, r2, #1
900043ba:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
900043bc:	687b      	ldr	r3, [r7, #4]
900043be:	2200      	movs	r2, #0
900043c0:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
900043c2:	687b      	ldr	r3, [r7, #4]
900043c4:	2220      	movs	r2, #32
900043c6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
900043ca:	687b      	ldr	r3, [r7, #4]
900043cc:	2200      	movs	r2, #0
900043ce:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
900043d0:	687b      	ldr	r3, [r7, #4]
900043d2:	2200      	movs	r2, #0
900043d4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
900043d8:	2300      	movs	r3, #0
}
900043da:	4618      	mov	r0, r3
900043dc:	3708      	adds	r7, #8
900043de:	46bd      	mov	sp, r7
900043e0:	bd80      	pop	{r7, pc}
900043e2:	bf00      	nop
900043e4:	02008000 	.word	0x02008000

900043e8 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
900043e8:	b580      	push	{r7, lr}
900043ea:	b082      	sub	sp, #8
900043ec:	af00      	add	r7, sp, #0
900043ee:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
900043f0:	687b      	ldr	r3, [r7, #4]
900043f2:	2b00      	cmp	r3, #0
900043f4:	d101      	bne.n	900043fa <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
900043f6:	2301      	movs	r3, #1
900043f8:	e021      	b.n	9000443e <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
900043fa:	687b      	ldr	r3, [r7, #4]
900043fc:	2224      	movs	r2, #36	; 0x24
900043fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
90004402:	687b      	ldr	r3, [r7, #4]
90004404:	681b      	ldr	r3, [r3, #0]
90004406:	681a      	ldr	r2, [r3, #0]
90004408:	687b      	ldr	r3, [r7, #4]
9000440a:	681b      	ldr	r3, [r3, #0]
9000440c:	f022 0201 	bic.w	r2, r2, #1
90004410:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
90004412:	6878      	ldr	r0, [r7, #4]
90004414:	f000 f821 	bl	9000445a <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
90004418:	687b      	ldr	r3, [r7, #4]
9000441a:	2200      	movs	r2, #0
9000441c:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
9000441e:	687b      	ldr	r3, [r7, #4]
90004420:	2200      	movs	r2, #0
90004422:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
90004426:	687b      	ldr	r3, [r7, #4]
90004428:	2200      	movs	r2, #0
9000442a:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
9000442c:	687b      	ldr	r3, [r7, #4]
9000442e:	2200      	movs	r2, #0
90004430:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
90004434:	687b      	ldr	r3, [r7, #4]
90004436:	2200      	movs	r2, #0
90004438:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
9000443c:	2300      	movs	r3, #0
}
9000443e:	4618      	mov	r0, r3
90004440:	3708      	adds	r7, #8
90004442:	46bd      	mov	sp, r7
90004444:	bd80      	pop	{r7, pc}

90004446 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
90004446:	b480      	push	{r7}
90004448:	b083      	sub	sp, #12
9000444a:	af00      	add	r7, sp, #0
9000444c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
9000444e:	bf00      	nop
90004450:	370c      	adds	r7, #12
90004452:	46bd      	mov	sp, r7
90004454:	f85d 7b04 	ldr.w	r7, [sp], #4
90004458:	4770      	bx	lr

9000445a <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
9000445a:	b480      	push	{r7}
9000445c:	b083      	sub	sp, #12
9000445e:	af00      	add	r7, sp, #0
90004460:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
90004462:	bf00      	nop
90004464:	370c      	adds	r7, #12
90004466:	46bd      	mov	sp, r7
90004468:	f85d 7b04 	ldr.w	r7, [sp], #4
9000446c:	4770      	bx	lr
	...

90004470 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
90004470:	b580      	push	{r7, lr}
90004472:	b088      	sub	sp, #32
90004474:	af02      	add	r7, sp, #8
90004476:	60f8      	str	r0, [r7, #12]
90004478:	4608      	mov	r0, r1
9000447a:	4611      	mov	r1, r2
9000447c:	461a      	mov	r2, r3
9000447e:	4603      	mov	r3, r0
90004480:	817b      	strh	r3, [r7, #10]
90004482:	460b      	mov	r3, r1
90004484:	813b      	strh	r3, [r7, #8]
90004486:	4613      	mov	r3, r2
90004488:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
9000448a:	68fb      	ldr	r3, [r7, #12]
9000448c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
90004490:	b2db      	uxtb	r3, r3
90004492:	2b20      	cmp	r3, #32
90004494:	f040 80f9 	bne.w	9000468a <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
90004498:	6a3b      	ldr	r3, [r7, #32]
9000449a:	2b00      	cmp	r3, #0
9000449c:	d002      	beq.n	900044a4 <HAL_I2C_Mem_Write+0x34>
9000449e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
900044a0:	2b00      	cmp	r3, #0
900044a2:	d105      	bne.n	900044b0 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
900044a4:	68fb      	ldr	r3, [r7, #12]
900044a6:	f44f 7200 	mov.w	r2, #512	; 0x200
900044aa:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
900044ac:	2301      	movs	r3, #1
900044ae:	e0ed      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
900044b0:	68fb      	ldr	r3, [r7, #12]
900044b2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
900044b6:	2b01      	cmp	r3, #1
900044b8:	d101      	bne.n	900044be <HAL_I2C_Mem_Write+0x4e>
900044ba:	2302      	movs	r3, #2
900044bc:	e0e6      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
900044be:	68fb      	ldr	r3, [r7, #12]
900044c0:	2201      	movs	r2, #1
900044c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
900044c6:	f7ff f991 	bl	900037ec <HAL_GetTick>
900044ca:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
900044cc:	697b      	ldr	r3, [r7, #20]
900044ce:	9300      	str	r3, [sp, #0]
900044d0:	2319      	movs	r3, #25
900044d2:	2201      	movs	r2, #1
900044d4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
900044d8:	68f8      	ldr	r0, [r7, #12]
900044da:	f000 fad1 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
900044de:	4603      	mov	r3, r0
900044e0:	2b00      	cmp	r3, #0
900044e2:	d001      	beq.n	900044e8 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
900044e4:	2301      	movs	r3, #1
900044e6:	e0d1      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
900044e8:	68fb      	ldr	r3, [r7, #12]
900044ea:	2221      	movs	r2, #33	; 0x21
900044ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
900044f0:	68fb      	ldr	r3, [r7, #12]
900044f2:	2240      	movs	r2, #64	; 0x40
900044f4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
900044f8:	68fb      	ldr	r3, [r7, #12]
900044fa:	2200      	movs	r2, #0
900044fc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
900044fe:	68fb      	ldr	r3, [r7, #12]
90004500:	6a3a      	ldr	r2, [r7, #32]
90004502:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
90004504:	68fb      	ldr	r3, [r7, #12]
90004506:	8cba      	ldrh	r2, [r7, #36]	; 0x24
90004508:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
9000450a:	68fb      	ldr	r3, [r7, #12]
9000450c:	2200      	movs	r2, #0
9000450e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
90004510:	88f8      	ldrh	r0, [r7, #6]
90004512:	893a      	ldrh	r2, [r7, #8]
90004514:	8979      	ldrh	r1, [r7, #10]
90004516:	697b      	ldr	r3, [r7, #20]
90004518:	9301      	str	r3, [sp, #4]
9000451a:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000451c:	9300      	str	r3, [sp, #0]
9000451e:	4603      	mov	r3, r0
90004520:	68f8      	ldr	r0, [r7, #12]
90004522:	f000 f9e1 	bl	900048e8 <I2C_RequestMemoryWrite>
90004526:	4603      	mov	r3, r0
90004528:	2b00      	cmp	r3, #0
9000452a:	d005      	beq.n	90004538 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
9000452c:	68fb      	ldr	r3, [r7, #12]
9000452e:	2200      	movs	r2, #0
90004530:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
90004534:	2301      	movs	r3, #1
90004536:	e0a9      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
90004538:	68fb      	ldr	r3, [r7, #12]
9000453a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000453c:	b29b      	uxth	r3, r3
9000453e:	2bff      	cmp	r3, #255	; 0xff
90004540:	d90e      	bls.n	90004560 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
90004542:	68fb      	ldr	r3, [r7, #12]
90004544:	22ff      	movs	r2, #255	; 0xff
90004546:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
90004548:	68fb      	ldr	r3, [r7, #12]
9000454a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000454c:	b2da      	uxtb	r2, r3
9000454e:	8979      	ldrh	r1, [r7, #10]
90004550:	2300      	movs	r3, #0
90004552:	9300      	str	r3, [sp, #0]
90004554:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
90004558:	68f8      	ldr	r0, [r7, #12]
9000455a:	f000 fbb3 	bl	90004cc4 <I2C_TransferConfig>
9000455e:	e00f      	b.n	90004580 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
90004560:	68fb      	ldr	r3, [r7, #12]
90004562:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
90004564:	b29a      	uxth	r2, r3
90004566:	68fb      	ldr	r3, [r7, #12]
90004568:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
9000456a:	68fb      	ldr	r3, [r7, #12]
9000456c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000456e:	b2da      	uxtb	r2, r3
90004570:	8979      	ldrh	r1, [r7, #10]
90004572:	2300      	movs	r3, #0
90004574:	9300      	str	r3, [sp, #0]
90004576:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
9000457a:	68f8      	ldr	r0, [r7, #12]
9000457c:	f000 fba2 	bl	90004cc4 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
90004580:	697a      	ldr	r2, [r7, #20]
90004582:	6ab9      	ldr	r1, [r7, #40]	; 0x28
90004584:	68f8      	ldr	r0, [r7, #12]
90004586:	f000 fabb 	bl	90004b00 <I2C_WaitOnTXISFlagUntilTimeout>
9000458a:	4603      	mov	r3, r0
9000458c:	2b00      	cmp	r3, #0
9000458e:	d001      	beq.n	90004594 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
90004590:	2301      	movs	r3, #1
90004592:	e07b      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
90004594:	68fb      	ldr	r3, [r7, #12]
90004596:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90004598:	781a      	ldrb	r2, [r3, #0]
9000459a:	68fb      	ldr	r3, [r7, #12]
9000459c:	681b      	ldr	r3, [r3, #0]
9000459e:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
900045a0:	68fb      	ldr	r3, [r7, #12]
900045a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
900045a4:	1c5a      	adds	r2, r3, #1
900045a6:	68fb      	ldr	r3, [r7, #12]
900045a8:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
900045aa:	68fb      	ldr	r3, [r7, #12]
900045ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
900045ae:	b29b      	uxth	r3, r3
900045b0:	3b01      	subs	r3, #1
900045b2:	b29a      	uxth	r2, r3
900045b4:	68fb      	ldr	r3, [r7, #12]
900045b6:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
900045b8:	68fb      	ldr	r3, [r7, #12]
900045ba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
900045bc:	3b01      	subs	r3, #1
900045be:	b29a      	uxth	r2, r3
900045c0:	68fb      	ldr	r3, [r7, #12]
900045c2:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
900045c4:	68fb      	ldr	r3, [r7, #12]
900045c6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
900045c8:	b29b      	uxth	r3, r3
900045ca:	2b00      	cmp	r3, #0
900045cc:	d034      	beq.n	90004638 <HAL_I2C_Mem_Write+0x1c8>
900045ce:	68fb      	ldr	r3, [r7, #12]
900045d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
900045d2:	2b00      	cmp	r3, #0
900045d4:	d130      	bne.n	90004638 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
900045d6:	697b      	ldr	r3, [r7, #20]
900045d8:	9300      	str	r3, [sp, #0]
900045da:	6abb      	ldr	r3, [r7, #40]	; 0x28
900045dc:	2200      	movs	r2, #0
900045de:	2180      	movs	r1, #128	; 0x80
900045e0:	68f8      	ldr	r0, [r7, #12]
900045e2:	f000 fa4d 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
900045e6:	4603      	mov	r3, r0
900045e8:	2b00      	cmp	r3, #0
900045ea:	d001      	beq.n	900045f0 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
900045ec:	2301      	movs	r3, #1
900045ee:	e04d      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
900045f0:	68fb      	ldr	r3, [r7, #12]
900045f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
900045f4:	b29b      	uxth	r3, r3
900045f6:	2bff      	cmp	r3, #255	; 0xff
900045f8:	d90e      	bls.n	90004618 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
900045fa:	68fb      	ldr	r3, [r7, #12]
900045fc:	22ff      	movs	r2, #255	; 0xff
900045fe:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
90004600:	68fb      	ldr	r3, [r7, #12]
90004602:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004604:	b2da      	uxtb	r2, r3
90004606:	8979      	ldrh	r1, [r7, #10]
90004608:	2300      	movs	r3, #0
9000460a:	9300      	str	r3, [sp, #0]
9000460c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
90004610:	68f8      	ldr	r0, [r7, #12]
90004612:	f000 fb57 	bl	90004cc4 <I2C_TransferConfig>
90004616:	e00f      	b.n	90004638 <HAL_I2C_Mem_Write+0x1c8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
90004618:	68fb      	ldr	r3, [r7, #12]
9000461a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000461c:	b29a      	uxth	r2, r3
9000461e:	68fb      	ldr	r3, [r7, #12]
90004620:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
90004622:	68fb      	ldr	r3, [r7, #12]
90004624:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004626:	b2da      	uxtb	r2, r3
90004628:	8979      	ldrh	r1, [r7, #10]
9000462a:	2300      	movs	r3, #0
9000462c:	9300      	str	r3, [sp, #0]
9000462e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
90004632:	68f8      	ldr	r0, [r7, #12]
90004634:	f000 fb46 	bl	90004cc4 <I2C_TransferConfig>
        }
      }

    } while (hi2c->XferCount > 0U);
90004638:	68fb      	ldr	r3, [r7, #12]
9000463a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000463c:	b29b      	uxth	r3, r3
9000463e:	2b00      	cmp	r3, #0
90004640:	d19e      	bne.n	90004580 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
90004642:	697a      	ldr	r2, [r7, #20]
90004644:	6ab9      	ldr	r1, [r7, #40]	; 0x28
90004646:	68f8      	ldr	r0, [r7, #12]
90004648:	f000 fa9a 	bl	90004b80 <I2C_WaitOnSTOPFlagUntilTimeout>
9000464c:	4603      	mov	r3, r0
9000464e:	2b00      	cmp	r3, #0
90004650:	d001      	beq.n	90004656 <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
90004652:	2301      	movs	r3, #1
90004654:	e01a      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
90004656:	68fb      	ldr	r3, [r7, #12]
90004658:	681b      	ldr	r3, [r3, #0]
9000465a:	2220      	movs	r2, #32
9000465c:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
9000465e:	68fb      	ldr	r3, [r7, #12]
90004660:	681b      	ldr	r3, [r3, #0]
90004662:	6859      	ldr	r1, [r3, #4]
90004664:	68fb      	ldr	r3, [r7, #12]
90004666:	681a      	ldr	r2, [r3, #0]
90004668:	4b0a      	ldr	r3, [pc, #40]	; (90004694 <HAL_I2C_Mem_Write+0x224>)
9000466a:	400b      	ands	r3, r1
9000466c:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
9000466e:	68fb      	ldr	r3, [r7, #12]
90004670:	2220      	movs	r2, #32
90004672:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
90004676:	68fb      	ldr	r3, [r7, #12]
90004678:	2200      	movs	r2, #0
9000467a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
9000467e:	68fb      	ldr	r3, [r7, #12]
90004680:	2200      	movs	r2, #0
90004682:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
90004686:	2300      	movs	r3, #0
90004688:	e000      	b.n	9000468c <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
9000468a:	2302      	movs	r3, #2
  }
}
9000468c:	4618      	mov	r0, r3
9000468e:	3718      	adds	r7, #24
90004690:	46bd      	mov	sp, r7
90004692:	bd80      	pop	{r7, pc}
90004694:	fe00e800 	.word	0xfe00e800

90004698 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
90004698:	b580      	push	{r7, lr}
9000469a:	b088      	sub	sp, #32
9000469c:	af02      	add	r7, sp, #8
9000469e:	60f8      	str	r0, [r7, #12]
900046a0:	4608      	mov	r0, r1
900046a2:	4611      	mov	r1, r2
900046a4:	461a      	mov	r2, r3
900046a6:	4603      	mov	r3, r0
900046a8:	817b      	strh	r3, [r7, #10]
900046aa:	460b      	mov	r3, r1
900046ac:	813b      	strh	r3, [r7, #8]
900046ae:	4613      	mov	r3, r2
900046b0:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
900046b2:	68fb      	ldr	r3, [r7, #12]
900046b4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
900046b8:	b2db      	uxtb	r3, r3
900046ba:	2b20      	cmp	r3, #32
900046bc:	f040 80fd 	bne.w	900048ba <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
900046c0:	6a3b      	ldr	r3, [r7, #32]
900046c2:	2b00      	cmp	r3, #0
900046c4:	d002      	beq.n	900046cc <HAL_I2C_Mem_Read+0x34>
900046c6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
900046c8:	2b00      	cmp	r3, #0
900046ca:	d105      	bne.n	900046d8 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
900046cc:	68fb      	ldr	r3, [r7, #12]
900046ce:	f44f 7200 	mov.w	r2, #512	; 0x200
900046d2:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
900046d4:	2301      	movs	r3, #1
900046d6:	e0f1      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
900046d8:	68fb      	ldr	r3, [r7, #12]
900046da:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
900046de:	2b01      	cmp	r3, #1
900046e0:	d101      	bne.n	900046e6 <HAL_I2C_Mem_Read+0x4e>
900046e2:	2302      	movs	r3, #2
900046e4:	e0ea      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
900046e6:	68fb      	ldr	r3, [r7, #12]
900046e8:	2201      	movs	r2, #1
900046ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
900046ee:	f7ff f87d 	bl	900037ec <HAL_GetTick>
900046f2:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
900046f4:	697b      	ldr	r3, [r7, #20]
900046f6:	9300      	str	r3, [sp, #0]
900046f8:	2319      	movs	r3, #25
900046fa:	2201      	movs	r2, #1
900046fc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
90004700:	68f8      	ldr	r0, [r7, #12]
90004702:	f000 f9bd 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
90004706:	4603      	mov	r3, r0
90004708:	2b00      	cmp	r3, #0
9000470a:	d001      	beq.n	90004710 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
9000470c:	2301      	movs	r3, #1
9000470e:	e0d5      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
90004710:	68fb      	ldr	r3, [r7, #12]
90004712:	2222      	movs	r2, #34	; 0x22
90004714:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
90004718:	68fb      	ldr	r3, [r7, #12]
9000471a:	2240      	movs	r2, #64	; 0x40
9000471c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
90004720:	68fb      	ldr	r3, [r7, #12]
90004722:	2200      	movs	r2, #0
90004724:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
90004726:	68fb      	ldr	r3, [r7, #12]
90004728:	6a3a      	ldr	r2, [r7, #32]
9000472a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
9000472c:	68fb      	ldr	r3, [r7, #12]
9000472e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
90004730:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
90004732:	68fb      	ldr	r3, [r7, #12]
90004734:	2200      	movs	r2, #0
90004736:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
90004738:	88f8      	ldrh	r0, [r7, #6]
9000473a:	893a      	ldrh	r2, [r7, #8]
9000473c:	8979      	ldrh	r1, [r7, #10]
9000473e:	697b      	ldr	r3, [r7, #20]
90004740:	9301      	str	r3, [sp, #4]
90004742:	6abb      	ldr	r3, [r7, #40]	; 0x28
90004744:	9300      	str	r3, [sp, #0]
90004746:	4603      	mov	r3, r0
90004748:	68f8      	ldr	r0, [r7, #12]
9000474a:	f000 f921 	bl	90004990 <I2C_RequestMemoryRead>
9000474e:	4603      	mov	r3, r0
90004750:	2b00      	cmp	r3, #0
90004752:	d005      	beq.n	90004760 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
90004754:	68fb      	ldr	r3, [r7, #12]
90004756:	2200      	movs	r2, #0
90004758:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
9000475c:	2301      	movs	r3, #1
9000475e:	e0ad      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
90004760:	68fb      	ldr	r3, [r7, #12]
90004762:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
90004764:	b29b      	uxth	r3, r3
90004766:	2bff      	cmp	r3, #255	; 0xff
90004768:	d90e      	bls.n	90004788 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
9000476a:	68fb      	ldr	r3, [r7, #12]
9000476c:	22ff      	movs	r2, #255	; 0xff
9000476e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
90004770:	68fb      	ldr	r3, [r7, #12]
90004772:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004774:	b2da      	uxtb	r2, r3
90004776:	8979      	ldrh	r1, [r7, #10]
90004778:	4b52      	ldr	r3, [pc, #328]	; (900048c4 <HAL_I2C_Mem_Read+0x22c>)
9000477a:	9300      	str	r3, [sp, #0]
9000477c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
90004780:	68f8      	ldr	r0, [r7, #12]
90004782:	f000 fa9f 	bl	90004cc4 <I2C_TransferConfig>
90004786:	e00f      	b.n	900047a8 <HAL_I2C_Mem_Read+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
90004788:	68fb      	ldr	r3, [r7, #12]
9000478a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000478c:	b29a      	uxth	r2, r3
9000478e:	68fb      	ldr	r3, [r7, #12]
90004790:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
90004792:	68fb      	ldr	r3, [r7, #12]
90004794:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004796:	b2da      	uxtb	r2, r3
90004798:	8979      	ldrh	r1, [r7, #10]
9000479a:	4b4a      	ldr	r3, [pc, #296]	; (900048c4 <HAL_I2C_Mem_Read+0x22c>)
9000479c:	9300      	str	r3, [sp, #0]
9000479e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
900047a2:	68f8      	ldr	r0, [r7, #12]
900047a4:	f000 fa8e 	bl	90004cc4 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
900047a8:	697b      	ldr	r3, [r7, #20]
900047aa:	9300      	str	r3, [sp, #0]
900047ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
900047ae:	2200      	movs	r2, #0
900047b0:	2104      	movs	r1, #4
900047b2:	68f8      	ldr	r0, [r7, #12]
900047b4:	f000 f964 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
900047b8:	4603      	mov	r3, r0
900047ba:	2b00      	cmp	r3, #0
900047bc:	d001      	beq.n	900047c2 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
900047be:	2301      	movs	r3, #1
900047c0:	e07c      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
900047c2:	68fb      	ldr	r3, [r7, #12]
900047c4:	681b      	ldr	r3, [r3, #0]
900047c6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
900047c8:	68fb      	ldr	r3, [r7, #12]
900047ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
900047cc:	b2d2      	uxtb	r2, r2
900047ce:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
900047d0:	68fb      	ldr	r3, [r7, #12]
900047d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
900047d4:	1c5a      	adds	r2, r3, #1
900047d6:	68fb      	ldr	r3, [r7, #12]
900047d8:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
900047da:	68fb      	ldr	r3, [r7, #12]
900047dc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
900047de:	3b01      	subs	r3, #1
900047e0:	b29a      	uxth	r2, r3
900047e2:	68fb      	ldr	r3, [r7, #12]
900047e4:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
900047e6:	68fb      	ldr	r3, [r7, #12]
900047e8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
900047ea:	b29b      	uxth	r3, r3
900047ec:	3b01      	subs	r3, #1
900047ee:	b29a      	uxth	r2, r3
900047f0:	68fb      	ldr	r3, [r7, #12]
900047f2:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
900047f4:	68fb      	ldr	r3, [r7, #12]
900047f6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
900047f8:	b29b      	uxth	r3, r3
900047fa:	2b00      	cmp	r3, #0
900047fc:	d034      	beq.n	90004868 <HAL_I2C_Mem_Read+0x1d0>
900047fe:	68fb      	ldr	r3, [r7, #12]
90004800:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004802:	2b00      	cmp	r3, #0
90004804:	d130      	bne.n	90004868 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
90004806:	697b      	ldr	r3, [r7, #20]
90004808:	9300      	str	r3, [sp, #0]
9000480a:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000480c:	2200      	movs	r2, #0
9000480e:	2180      	movs	r1, #128	; 0x80
90004810:	68f8      	ldr	r0, [r7, #12]
90004812:	f000 f935 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
90004816:	4603      	mov	r3, r0
90004818:	2b00      	cmp	r3, #0
9000481a:	d001      	beq.n	90004820 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
9000481c:	2301      	movs	r3, #1
9000481e:	e04d      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
90004820:	68fb      	ldr	r3, [r7, #12]
90004822:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
90004824:	b29b      	uxth	r3, r3
90004826:	2bff      	cmp	r3, #255	; 0xff
90004828:	d90e      	bls.n	90004848 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
9000482a:	68fb      	ldr	r3, [r7, #12]
9000482c:	22ff      	movs	r2, #255	; 0xff
9000482e:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
90004830:	68fb      	ldr	r3, [r7, #12]
90004832:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004834:	b2da      	uxtb	r2, r3
90004836:	8979      	ldrh	r1, [r7, #10]
90004838:	2300      	movs	r3, #0
9000483a:	9300      	str	r3, [sp, #0]
9000483c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
90004840:	68f8      	ldr	r0, [r7, #12]
90004842:	f000 fa3f 	bl	90004cc4 <I2C_TransferConfig>
90004846:	e00f      	b.n	90004868 <HAL_I2C_Mem_Read+0x1d0>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
90004848:	68fb      	ldr	r3, [r7, #12]
9000484a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000484c:	b29a      	uxth	r2, r3
9000484e:	68fb      	ldr	r3, [r7, #12]
90004850:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
90004852:	68fb      	ldr	r3, [r7, #12]
90004854:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
90004856:	b2da      	uxtb	r2, r3
90004858:	8979      	ldrh	r1, [r7, #10]
9000485a:	2300      	movs	r3, #0
9000485c:	9300      	str	r3, [sp, #0]
9000485e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
90004862:	68f8      	ldr	r0, [r7, #12]
90004864:	f000 fa2e 	bl	90004cc4 <I2C_TransferConfig>
        }
      }
    } while (hi2c->XferCount > 0U);
90004868:	68fb      	ldr	r3, [r7, #12]
9000486a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000486c:	b29b      	uxth	r3, r3
9000486e:	2b00      	cmp	r3, #0
90004870:	d19a      	bne.n	900047a8 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
90004872:	697a      	ldr	r2, [r7, #20]
90004874:	6ab9      	ldr	r1, [r7, #40]	; 0x28
90004876:	68f8      	ldr	r0, [r7, #12]
90004878:	f000 f982 	bl	90004b80 <I2C_WaitOnSTOPFlagUntilTimeout>
9000487c:	4603      	mov	r3, r0
9000487e:	2b00      	cmp	r3, #0
90004880:	d001      	beq.n	90004886 <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
90004882:	2301      	movs	r3, #1
90004884:	e01a      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
90004886:	68fb      	ldr	r3, [r7, #12]
90004888:	681b      	ldr	r3, [r3, #0]
9000488a:	2220      	movs	r2, #32
9000488c:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
9000488e:	68fb      	ldr	r3, [r7, #12]
90004890:	681b      	ldr	r3, [r3, #0]
90004892:	6859      	ldr	r1, [r3, #4]
90004894:	68fb      	ldr	r3, [r7, #12]
90004896:	681a      	ldr	r2, [r3, #0]
90004898:	4b0b      	ldr	r3, [pc, #44]	; (900048c8 <HAL_I2C_Mem_Read+0x230>)
9000489a:	400b      	ands	r3, r1
9000489c:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
9000489e:	68fb      	ldr	r3, [r7, #12]
900048a0:	2220      	movs	r2, #32
900048a2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
900048a6:	68fb      	ldr	r3, [r7, #12]
900048a8:	2200      	movs	r2, #0
900048aa:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
900048ae:	68fb      	ldr	r3, [r7, #12]
900048b0:	2200      	movs	r2, #0
900048b2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
900048b6:	2300      	movs	r3, #0
900048b8:	e000      	b.n	900048bc <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
900048ba:	2302      	movs	r3, #2
  }
}
900048bc:	4618      	mov	r0, r3
900048be:	3718      	adds	r7, #24
900048c0:	46bd      	mov	sp, r7
900048c2:	bd80      	pop	{r7, pc}
900048c4:	80002400 	.word	0x80002400
900048c8:	fe00e800 	.word	0xfe00e800

900048cc <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
900048cc:	b480      	push	{r7}
900048ce:	b083      	sub	sp, #12
900048d0:	af00      	add	r7, sp, #0
900048d2:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
900048d4:	687b      	ldr	r3, [r7, #4]
900048d6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
900048da:	b2db      	uxtb	r3, r3
}
900048dc:	4618      	mov	r0, r3
900048de:	370c      	adds	r7, #12
900048e0:	46bd      	mov	sp, r7
900048e2:	f85d 7b04 	ldr.w	r7, [sp], #4
900048e6:	4770      	bx	lr

900048e8 <I2C_RequestMemoryWrite>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                                uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
900048e8:	b580      	push	{r7, lr}
900048ea:	b086      	sub	sp, #24
900048ec:	af02      	add	r7, sp, #8
900048ee:	60f8      	str	r0, [r7, #12]
900048f0:	4608      	mov	r0, r1
900048f2:	4611      	mov	r1, r2
900048f4:	461a      	mov	r2, r3
900048f6:	4603      	mov	r3, r0
900048f8:	817b      	strh	r3, [r7, #10]
900048fa:	460b      	mov	r3, r1
900048fc:	813b      	strh	r3, [r7, #8]
900048fe:	4613      	mov	r3, r2
90004900:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
90004902:	88fb      	ldrh	r3, [r7, #6]
90004904:	b2da      	uxtb	r2, r3
90004906:	8979      	ldrh	r1, [r7, #10]
90004908:	4b20      	ldr	r3, [pc, #128]	; (9000498c <I2C_RequestMemoryWrite+0xa4>)
9000490a:	9300      	str	r3, [sp, #0]
9000490c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
90004910:	68f8      	ldr	r0, [r7, #12]
90004912:	f000 f9d7 	bl	90004cc4 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
90004916:	69fa      	ldr	r2, [r7, #28]
90004918:	69b9      	ldr	r1, [r7, #24]
9000491a:	68f8      	ldr	r0, [r7, #12]
9000491c:	f000 f8f0 	bl	90004b00 <I2C_WaitOnTXISFlagUntilTimeout>
90004920:	4603      	mov	r3, r0
90004922:	2b00      	cmp	r3, #0
90004924:	d001      	beq.n	9000492a <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
90004926:	2301      	movs	r3, #1
90004928:	e02c      	b.n	90004984 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
9000492a:	88fb      	ldrh	r3, [r7, #6]
9000492c:	2b01      	cmp	r3, #1
9000492e:	d105      	bne.n	9000493c <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
90004930:	893b      	ldrh	r3, [r7, #8]
90004932:	b2da      	uxtb	r2, r3
90004934:	68fb      	ldr	r3, [r7, #12]
90004936:	681b      	ldr	r3, [r3, #0]
90004938:	629a      	str	r2, [r3, #40]	; 0x28
9000493a:	e015      	b.n	90004968 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
9000493c:	893b      	ldrh	r3, [r7, #8]
9000493e:	0a1b      	lsrs	r3, r3, #8
90004940:	b29b      	uxth	r3, r3
90004942:	b2da      	uxtb	r2, r3
90004944:	68fb      	ldr	r3, [r7, #12]
90004946:	681b      	ldr	r3, [r3, #0]
90004948:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
9000494a:	69fa      	ldr	r2, [r7, #28]
9000494c:	69b9      	ldr	r1, [r7, #24]
9000494e:	68f8      	ldr	r0, [r7, #12]
90004950:	f000 f8d6 	bl	90004b00 <I2C_WaitOnTXISFlagUntilTimeout>
90004954:	4603      	mov	r3, r0
90004956:	2b00      	cmp	r3, #0
90004958:	d001      	beq.n	9000495e <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
9000495a:	2301      	movs	r3, #1
9000495c:	e012      	b.n	90004984 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
9000495e:	893b      	ldrh	r3, [r7, #8]
90004960:	b2da      	uxtb	r2, r3
90004962:	68fb      	ldr	r3, [r7, #12]
90004964:	681b      	ldr	r3, [r3, #0]
90004966:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
90004968:	69fb      	ldr	r3, [r7, #28]
9000496a:	9300      	str	r3, [sp, #0]
9000496c:	69bb      	ldr	r3, [r7, #24]
9000496e:	2200      	movs	r2, #0
90004970:	2180      	movs	r1, #128	; 0x80
90004972:	68f8      	ldr	r0, [r7, #12]
90004974:	f000 f884 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
90004978:	4603      	mov	r3, r0
9000497a:	2b00      	cmp	r3, #0
9000497c:	d001      	beq.n	90004982 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
9000497e:	2301      	movs	r3, #1
90004980:	e000      	b.n	90004984 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
90004982:	2300      	movs	r3, #0
}
90004984:	4618      	mov	r0, r3
90004986:	3710      	adds	r7, #16
90004988:	46bd      	mov	sp, r7
9000498a:	bd80      	pop	{r7, pc}
9000498c:	80002000 	.word	0x80002000

90004990 <I2C_RequestMemoryRead>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                               uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
90004990:	b580      	push	{r7, lr}
90004992:	b086      	sub	sp, #24
90004994:	af02      	add	r7, sp, #8
90004996:	60f8      	str	r0, [r7, #12]
90004998:	4608      	mov	r0, r1
9000499a:	4611      	mov	r1, r2
9000499c:	461a      	mov	r2, r3
9000499e:	4603      	mov	r3, r0
900049a0:	817b      	strh	r3, [r7, #10]
900049a2:	460b      	mov	r3, r1
900049a4:	813b      	strh	r3, [r7, #8]
900049a6:	4613      	mov	r3, r2
900049a8:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
900049aa:	88fb      	ldrh	r3, [r7, #6]
900049ac:	b2da      	uxtb	r2, r3
900049ae:	8979      	ldrh	r1, [r7, #10]
900049b0:	4b20      	ldr	r3, [pc, #128]	; (90004a34 <I2C_RequestMemoryRead+0xa4>)
900049b2:	9300      	str	r3, [sp, #0]
900049b4:	2300      	movs	r3, #0
900049b6:	68f8      	ldr	r0, [r7, #12]
900049b8:	f000 f984 	bl	90004cc4 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
900049bc:	69fa      	ldr	r2, [r7, #28]
900049be:	69b9      	ldr	r1, [r7, #24]
900049c0:	68f8      	ldr	r0, [r7, #12]
900049c2:	f000 f89d 	bl	90004b00 <I2C_WaitOnTXISFlagUntilTimeout>
900049c6:	4603      	mov	r3, r0
900049c8:	2b00      	cmp	r3, #0
900049ca:	d001      	beq.n	900049d0 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
900049cc:	2301      	movs	r3, #1
900049ce:	e02c      	b.n	90004a2a <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
900049d0:	88fb      	ldrh	r3, [r7, #6]
900049d2:	2b01      	cmp	r3, #1
900049d4:	d105      	bne.n	900049e2 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
900049d6:	893b      	ldrh	r3, [r7, #8]
900049d8:	b2da      	uxtb	r2, r3
900049da:	68fb      	ldr	r3, [r7, #12]
900049dc:	681b      	ldr	r3, [r3, #0]
900049de:	629a      	str	r2, [r3, #40]	; 0x28
900049e0:	e015      	b.n	90004a0e <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
900049e2:	893b      	ldrh	r3, [r7, #8]
900049e4:	0a1b      	lsrs	r3, r3, #8
900049e6:	b29b      	uxth	r3, r3
900049e8:	b2da      	uxtb	r2, r3
900049ea:	68fb      	ldr	r3, [r7, #12]
900049ec:	681b      	ldr	r3, [r3, #0]
900049ee:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
900049f0:	69fa      	ldr	r2, [r7, #28]
900049f2:	69b9      	ldr	r1, [r7, #24]
900049f4:	68f8      	ldr	r0, [r7, #12]
900049f6:	f000 f883 	bl	90004b00 <I2C_WaitOnTXISFlagUntilTimeout>
900049fa:	4603      	mov	r3, r0
900049fc:	2b00      	cmp	r3, #0
900049fe:	d001      	beq.n	90004a04 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
90004a00:	2301      	movs	r3, #1
90004a02:	e012      	b.n	90004a2a <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
90004a04:	893b      	ldrh	r3, [r7, #8]
90004a06:	b2da      	uxtb	r2, r3
90004a08:	68fb      	ldr	r3, [r7, #12]
90004a0a:	681b      	ldr	r3, [r3, #0]
90004a0c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
90004a0e:	69fb      	ldr	r3, [r7, #28]
90004a10:	9300      	str	r3, [sp, #0]
90004a12:	69bb      	ldr	r3, [r7, #24]
90004a14:	2200      	movs	r2, #0
90004a16:	2140      	movs	r1, #64	; 0x40
90004a18:	68f8      	ldr	r0, [r7, #12]
90004a1a:	f000 f831 	bl	90004a80 <I2C_WaitOnFlagUntilTimeout>
90004a1e:	4603      	mov	r3, r0
90004a20:	2b00      	cmp	r3, #0
90004a22:	d001      	beq.n	90004a28 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
90004a24:	2301      	movs	r3, #1
90004a26:	e000      	b.n	90004a2a <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
90004a28:	2300      	movs	r3, #0
}
90004a2a:	4618      	mov	r0, r3
90004a2c:	3710      	adds	r7, #16
90004a2e:	46bd      	mov	sp, r7
90004a30:	bd80      	pop	{r7, pc}
90004a32:	bf00      	nop
90004a34:	80002000 	.word	0x80002000

90004a38 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
90004a38:	b480      	push	{r7}
90004a3a:	b083      	sub	sp, #12
90004a3c:	af00      	add	r7, sp, #0
90004a3e:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
90004a40:	687b      	ldr	r3, [r7, #4]
90004a42:	681b      	ldr	r3, [r3, #0]
90004a44:	699b      	ldr	r3, [r3, #24]
90004a46:	f003 0302 	and.w	r3, r3, #2
90004a4a:	2b02      	cmp	r3, #2
90004a4c:	d103      	bne.n	90004a56 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
90004a4e:	687b      	ldr	r3, [r7, #4]
90004a50:	681b      	ldr	r3, [r3, #0]
90004a52:	2200      	movs	r2, #0
90004a54:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
90004a56:	687b      	ldr	r3, [r7, #4]
90004a58:	681b      	ldr	r3, [r3, #0]
90004a5a:	699b      	ldr	r3, [r3, #24]
90004a5c:	f003 0301 	and.w	r3, r3, #1
90004a60:	2b01      	cmp	r3, #1
90004a62:	d007      	beq.n	90004a74 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
90004a64:	687b      	ldr	r3, [r7, #4]
90004a66:	681b      	ldr	r3, [r3, #0]
90004a68:	699a      	ldr	r2, [r3, #24]
90004a6a:	687b      	ldr	r3, [r7, #4]
90004a6c:	681b      	ldr	r3, [r3, #0]
90004a6e:	f042 0201 	orr.w	r2, r2, #1
90004a72:	619a      	str	r2, [r3, #24]
  }
}
90004a74:	bf00      	nop
90004a76:	370c      	adds	r7, #12
90004a78:	46bd      	mov	sp, r7
90004a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
90004a7e:	4770      	bx	lr

90004a80 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
90004a80:	b580      	push	{r7, lr}
90004a82:	b084      	sub	sp, #16
90004a84:	af00      	add	r7, sp, #0
90004a86:	60f8      	str	r0, [r7, #12]
90004a88:	60b9      	str	r1, [r7, #8]
90004a8a:	603b      	str	r3, [r7, #0]
90004a8c:	4613      	mov	r3, r2
90004a8e:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
90004a90:	e022      	b.n	90004ad8 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
90004a92:	683b      	ldr	r3, [r7, #0]
90004a94:	f1b3 3fff 	cmp.w	r3, #4294967295
90004a98:	d01e      	beq.n	90004ad8 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
90004a9a:	f7fe fea7 	bl	900037ec <HAL_GetTick>
90004a9e:	4602      	mov	r2, r0
90004aa0:	69bb      	ldr	r3, [r7, #24]
90004aa2:	1ad3      	subs	r3, r2, r3
90004aa4:	683a      	ldr	r2, [r7, #0]
90004aa6:	429a      	cmp	r2, r3
90004aa8:	d302      	bcc.n	90004ab0 <I2C_WaitOnFlagUntilTimeout+0x30>
90004aaa:	683b      	ldr	r3, [r7, #0]
90004aac:	2b00      	cmp	r3, #0
90004aae:	d113      	bne.n	90004ad8 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
90004ab0:	68fb      	ldr	r3, [r7, #12]
90004ab2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90004ab4:	f043 0220 	orr.w	r2, r3, #32
90004ab8:	68fb      	ldr	r3, [r7, #12]
90004aba:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
90004abc:	68fb      	ldr	r3, [r7, #12]
90004abe:	2220      	movs	r2, #32
90004ac0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
90004ac4:	68fb      	ldr	r3, [r7, #12]
90004ac6:	2200      	movs	r2, #0
90004ac8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
90004acc:	68fb      	ldr	r3, [r7, #12]
90004ace:	2200      	movs	r2, #0
90004ad0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
90004ad4:	2301      	movs	r3, #1
90004ad6:	e00f      	b.n	90004af8 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
90004ad8:	68fb      	ldr	r3, [r7, #12]
90004ada:	681b      	ldr	r3, [r3, #0]
90004adc:	699a      	ldr	r2, [r3, #24]
90004ade:	68bb      	ldr	r3, [r7, #8]
90004ae0:	4013      	ands	r3, r2
90004ae2:	68ba      	ldr	r2, [r7, #8]
90004ae4:	429a      	cmp	r2, r3
90004ae6:	bf0c      	ite	eq
90004ae8:	2301      	moveq	r3, #1
90004aea:	2300      	movne	r3, #0
90004aec:	b2db      	uxtb	r3, r3
90004aee:	461a      	mov	r2, r3
90004af0:	79fb      	ldrb	r3, [r7, #7]
90004af2:	429a      	cmp	r2, r3
90004af4:	d0cd      	beq.n	90004a92 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
90004af6:	2300      	movs	r3, #0
}
90004af8:	4618      	mov	r0, r3
90004afa:	3710      	adds	r7, #16
90004afc:	46bd      	mov	sp, r7
90004afe:	bd80      	pop	{r7, pc}

90004b00 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
90004b00:	b580      	push	{r7, lr}
90004b02:	b084      	sub	sp, #16
90004b04:	af00      	add	r7, sp, #0
90004b06:	60f8      	str	r0, [r7, #12]
90004b08:	60b9      	str	r1, [r7, #8]
90004b0a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
90004b0c:	e02c      	b.n	90004b68 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
90004b0e:	687a      	ldr	r2, [r7, #4]
90004b10:	68b9      	ldr	r1, [r7, #8]
90004b12:	68f8      	ldr	r0, [r7, #12]
90004b14:	f000 f870 	bl	90004bf8 <I2C_IsAcknowledgeFailed>
90004b18:	4603      	mov	r3, r0
90004b1a:	2b00      	cmp	r3, #0
90004b1c:	d001      	beq.n	90004b22 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
90004b1e:	2301      	movs	r3, #1
90004b20:	e02a      	b.n	90004b78 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
90004b22:	68bb      	ldr	r3, [r7, #8]
90004b24:	f1b3 3fff 	cmp.w	r3, #4294967295
90004b28:	d01e      	beq.n	90004b68 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
90004b2a:	f7fe fe5f 	bl	900037ec <HAL_GetTick>
90004b2e:	4602      	mov	r2, r0
90004b30:	687b      	ldr	r3, [r7, #4]
90004b32:	1ad3      	subs	r3, r2, r3
90004b34:	68ba      	ldr	r2, [r7, #8]
90004b36:	429a      	cmp	r2, r3
90004b38:	d302      	bcc.n	90004b40 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
90004b3a:	68bb      	ldr	r3, [r7, #8]
90004b3c:	2b00      	cmp	r3, #0
90004b3e:	d113      	bne.n	90004b68 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
90004b40:	68fb      	ldr	r3, [r7, #12]
90004b42:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90004b44:	f043 0220 	orr.w	r2, r3, #32
90004b48:	68fb      	ldr	r3, [r7, #12]
90004b4a:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
90004b4c:	68fb      	ldr	r3, [r7, #12]
90004b4e:	2220      	movs	r2, #32
90004b50:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
90004b54:	68fb      	ldr	r3, [r7, #12]
90004b56:	2200      	movs	r2, #0
90004b58:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
90004b5c:	68fb      	ldr	r3, [r7, #12]
90004b5e:	2200      	movs	r2, #0
90004b60:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
90004b64:	2301      	movs	r3, #1
90004b66:	e007      	b.n	90004b78 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
90004b68:	68fb      	ldr	r3, [r7, #12]
90004b6a:	681b      	ldr	r3, [r3, #0]
90004b6c:	699b      	ldr	r3, [r3, #24]
90004b6e:	f003 0302 	and.w	r3, r3, #2
90004b72:	2b02      	cmp	r3, #2
90004b74:	d1cb      	bne.n	90004b0e <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
90004b76:	2300      	movs	r3, #0
}
90004b78:	4618      	mov	r0, r3
90004b7a:	3710      	adds	r7, #16
90004b7c:	46bd      	mov	sp, r7
90004b7e:	bd80      	pop	{r7, pc}

90004b80 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
90004b80:	b580      	push	{r7, lr}
90004b82:	b084      	sub	sp, #16
90004b84:	af00      	add	r7, sp, #0
90004b86:	60f8      	str	r0, [r7, #12]
90004b88:	60b9      	str	r1, [r7, #8]
90004b8a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
90004b8c:	e028      	b.n	90004be0 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
90004b8e:	687a      	ldr	r2, [r7, #4]
90004b90:	68b9      	ldr	r1, [r7, #8]
90004b92:	68f8      	ldr	r0, [r7, #12]
90004b94:	f000 f830 	bl	90004bf8 <I2C_IsAcknowledgeFailed>
90004b98:	4603      	mov	r3, r0
90004b9a:	2b00      	cmp	r3, #0
90004b9c:	d001      	beq.n	90004ba2 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
90004b9e:	2301      	movs	r3, #1
90004ba0:	e026      	b.n	90004bf0 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
90004ba2:	f7fe fe23 	bl	900037ec <HAL_GetTick>
90004ba6:	4602      	mov	r2, r0
90004ba8:	687b      	ldr	r3, [r7, #4]
90004baa:	1ad3      	subs	r3, r2, r3
90004bac:	68ba      	ldr	r2, [r7, #8]
90004bae:	429a      	cmp	r2, r3
90004bb0:	d302      	bcc.n	90004bb8 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
90004bb2:	68bb      	ldr	r3, [r7, #8]
90004bb4:	2b00      	cmp	r3, #0
90004bb6:	d113      	bne.n	90004be0 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
90004bb8:	68fb      	ldr	r3, [r7, #12]
90004bba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90004bbc:	f043 0220 	orr.w	r2, r3, #32
90004bc0:	68fb      	ldr	r3, [r7, #12]
90004bc2:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
90004bc4:	68fb      	ldr	r3, [r7, #12]
90004bc6:	2220      	movs	r2, #32
90004bc8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
90004bcc:	68fb      	ldr	r3, [r7, #12]
90004bce:	2200      	movs	r2, #0
90004bd0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
90004bd4:	68fb      	ldr	r3, [r7, #12]
90004bd6:	2200      	movs	r2, #0
90004bd8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
90004bdc:	2301      	movs	r3, #1
90004bde:	e007      	b.n	90004bf0 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
90004be0:	68fb      	ldr	r3, [r7, #12]
90004be2:	681b      	ldr	r3, [r3, #0]
90004be4:	699b      	ldr	r3, [r3, #24]
90004be6:	f003 0320 	and.w	r3, r3, #32
90004bea:	2b20      	cmp	r3, #32
90004bec:	d1cf      	bne.n	90004b8e <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
90004bee:	2300      	movs	r3, #0
}
90004bf0:	4618      	mov	r0, r3
90004bf2:	3710      	adds	r7, #16
90004bf4:	46bd      	mov	sp, r7
90004bf6:	bd80      	pop	{r7, pc}

90004bf8 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
90004bf8:	b580      	push	{r7, lr}
90004bfa:	b084      	sub	sp, #16
90004bfc:	af00      	add	r7, sp, #0
90004bfe:	60f8      	str	r0, [r7, #12]
90004c00:	60b9      	str	r1, [r7, #8]
90004c02:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
90004c04:	68fb      	ldr	r3, [r7, #12]
90004c06:	681b      	ldr	r3, [r3, #0]
90004c08:	699b      	ldr	r3, [r3, #24]
90004c0a:	f003 0310 	and.w	r3, r3, #16
90004c0e:	2b10      	cmp	r3, #16
90004c10:	d151      	bne.n	90004cb6 <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
90004c12:	e022      	b.n	90004c5a <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
90004c14:	68bb      	ldr	r3, [r7, #8]
90004c16:	f1b3 3fff 	cmp.w	r3, #4294967295
90004c1a:	d01e      	beq.n	90004c5a <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
90004c1c:	f7fe fde6 	bl	900037ec <HAL_GetTick>
90004c20:	4602      	mov	r2, r0
90004c22:	687b      	ldr	r3, [r7, #4]
90004c24:	1ad3      	subs	r3, r2, r3
90004c26:	68ba      	ldr	r2, [r7, #8]
90004c28:	429a      	cmp	r2, r3
90004c2a:	d302      	bcc.n	90004c32 <I2C_IsAcknowledgeFailed+0x3a>
90004c2c:	68bb      	ldr	r3, [r7, #8]
90004c2e:	2b00      	cmp	r3, #0
90004c30:	d113      	bne.n	90004c5a <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
90004c32:	68fb      	ldr	r3, [r7, #12]
90004c34:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90004c36:	f043 0220 	orr.w	r2, r3, #32
90004c3a:	68fb      	ldr	r3, [r7, #12]
90004c3c:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
90004c3e:	68fb      	ldr	r3, [r7, #12]
90004c40:	2220      	movs	r2, #32
90004c42:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
90004c46:	68fb      	ldr	r3, [r7, #12]
90004c48:	2200      	movs	r2, #0
90004c4a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
90004c4e:	68fb      	ldr	r3, [r7, #12]
90004c50:	2200      	movs	r2, #0
90004c52:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
90004c56:	2301      	movs	r3, #1
90004c58:	e02e      	b.n	90004cb8 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
90004c5a:	68fb      	ldr	r3, [r7, #12]
90004c5c:	681b      	ldr	r3, [r3, #0]
90004c5e:	699b      	ldr	r3, [r3, #24]
90004c60:	f003 0320 	and.w	r3, r3, #32
90004c64:	2b20      	cmp	r3, #32
90004c66:	d1d5      	bne.n	90004c14 <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
90004c68:	68fb      	ldr	r3, [r7, #12]
90004c6a:	681b      	ldr	r3, [r3, #0]
90004c6c:	2210      	movs	r2, #16
90004c6e:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
90004c70:	68fb      	ldr	r3, [r7, #12]
90004c72:	681b      	ldr	r3, [r3, #0]
90004c74:	2220      	movs	r2, #32
90004c76:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
90004c78:	68f8      	ldr	r0, [r7, #12]
90004c7a:	f7ff fedd 	bl	90004a38 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
90004c7e:	68fb      	ldr	r3, [r7, #12]
90004c80:	681b      	ldr	r3, [r3, #0]
90004c82:	6859      	ldr	r1, [r3, #4]
90004c84:	68fb      	ldr	r3, [r7, #12]
90004c86:	681a      	ldr	r2, [r3, #0]
90004c88:	4b0d      	ldr	r3, [pc, #52]	; (90004cc0 <I2C_IsAcknowledgeFailed+0xc8>)
90004c8a:	400b      	ands	r3, r1
90004c8c:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
90004c8e:	68fb      	ldr	r3, [r7, #12]
90004c90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90004c92:	f043 0204 	orr.w	r2, r3, #4
90004c96:	68fb      	ldr	r3, [r7, #12]
90004c98:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
90004c9a:	68fb      	ldr	r3, [r7, #12]
90004c9c:	2220      	movs	r2, #32
90004c9e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
90004ca2:	68fb      	ldr	r3, [r7, #12]
90004ca4:	2200      	movs	r2, #0
90004ca6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
90004caa:	68fb      	ldr	r3, [r7, #12]
90004cac:	2200      	movs	r2, #0
90004cae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
90004cb2:	2301      	movs	r3, #1
90004cb4:	e000      	b.n	90004cb8 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
90004cb6:	2300      	movs	r3, #0
}
90004cb8:	4618      	mov	r0, r3
90004cba:	3710      	adds	r7, #16
90004cbc:	46bd      	mov	sp, r7
90004cbe:	bd80      	pop	{r7, pc}
90004cc0:	fe00e800 	.word	0xfe00e800

90004cc4 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
90004cc4:	b480      	push	{r7}
90004cc6:	b085      	sub	sp, #20
90004cc8:	af00      	add	r7, sp, #0
90004cca:	60f8      	str	r0, [r7, #12]
90004ccc:	607b      	str	r3, [r7, #4]
90004cce:	460b      	mov	r3, r1
90004cd0:	817b      	strh	r3, [r7, #10]
90004cd2:	4613      	mov	r3, r2
90004cd4:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
90004cd6:	68fb      	ldr	r3, [r7, #12]
90004cd8:	681b      	ldr	r3, [r3, #0]
90004cda:	685a      	ldr	r2, [r3, #4]
90004cdc:	69bb      	ldr	r3, [r7, #24]
90004cde:	0d5b      	lsrs	r3, r3, #21
90004ce0:	f403 6180 	and.w	r1, r3, #1024	; 0x400
90004ce4:	4b0d      	ldr	r3, [pc, #52]	; (90004d1c <I2C_TransferConfig+0x58>)
90004ce6:	430b      	orrs	r3, r1
90004ce8:	43db      	mvns	r3, r3
90004cea:	ea02 0103 	and.w	r1, r2, r3
90004cee:	897b      	ldrh	r3, [r7, #10]
90004cf0:	f3c3 0209 	ubfx	r2, r3, #0, #10
90004cf4:	7a7b      	ldrb	r3, [r7, #9]
90004cf6:	041b      	lsls	r3, r3, #16
90004cf8:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
90004cfc:	431a      	orrs	r2, r3
90004cfe:	687b      	ldr	r3, [r7, #4]
90004d00:	431a      	orrs	r2, r3
90004d02:	69bb      	ldr	r3, [r7, #24]
90004d04:	431a      	orrs	r2, r3
90004d06:	68fb      	ldr	r3, [r7, #12]
90004d08:	681b      	ldr	r3, [r3, #0]
90004d0a:	430a      	orrs	r2, r1
90004d0c:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
90004d0e:	bf00      	nop
90004d10:	3714      	adds	r7, #20
90004d12:	46bd      	mov	sp, r7
90004d14:	f85d 7b04 	ldr.w	r7, [sp], #4
90004d18:	4770      	bx	lr
90004d1a:	bf00      	nop
90004d1c:	03ff63ff 	.word	0x03ff63ff

90004d20 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
90004d20:	b580      	push	{r7, lr}
90004d22:	b082      	sub	sp, #8
90004d24:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
90004d26:	2300      	movs	r3, #0
90004d28:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
90004d2a:	4b23      	ldr	r3, [pc, #140]	; (90004db8 <HAL_PWREx_EnableOverDrive+0x98>)
90004d2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90004d2e:	4a22      	ldr	r2, [pc, #136]	; (90004db8 <HAL_PWREx_EnableOverDrive+0x98>)
90004d30:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90004d34:	6413      	str	r3, [r2, #64]	; 0x40
90004d36:	4b20      	ldr	r3, [pc, #128]	; (90004db8 <HAL_PWREx_EnableOverDrive+0x98>)
90004d38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90004d3a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90004d3e:	603b      	str	r3, [r7, #0]
90004d40:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
90004d42:	4b1e      	ldr	r3, [pc, #120]	; (90004dbc <HAL_PWREx_EnableOverDrive+0x9c>)
90004d44:	681b      	ldr	r3, [r3, #0]
90004d46:	4a1d      	ldr	r2, [pc, #116]	; (90004dbc <HAL_PWREx_EnableOverDrive+0x9c>)
90004d48:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90004d4c:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
90004d4e:	f7fe fd4d 	bl	900037ec <HAL_GetTick>
90004d52:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
90004d54:	e009      	b.n	90004d6a <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
90004d56:	f7fe fd49 	bl	900037ec <HAL_GetTick>
90004d5a:	4602      	mov	r2, r0
90004d5c:	687b      	ldr	r3, [r7, #4]
90004d5e:	1ad3      	subs	r3, r2, r3
90004d60:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
90004d64:	d901      	bls.n	90004d6a <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
90004d66:	2303      	movs	r3, #3
90004d68:	e022      	b.n	90004db0 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
90004d6a:	4b14      	ldr	r3, [pc, #80]	; (90004dbc <HAL_PWREx_EnableOverDrive+0x9c>)
90004d6c:	685b      	ldr	r3, [r3, #4]
90004d6e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90004d72:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90004d76:	d1ee      	bne.n	90004d56 <HAL_PWREx_EnableOverDrive+0x36>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
90004d78:	4b10      	ldr	r3, [pc, #64]	; (90004dbc <HAL_PWREx_EnableOverDrive+0x9c>)
90004d7a:	681b      	ldr	r3, [r3, #0]
90004d7c:	4a0f      	ldr	r2, [pc, #60]	; (90004dbc <HAL_PWREx_EnableOverDrive+0x9c>)
90004d7e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90004d82:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
90004d84:	f7fe fd32 	bl	900037ec <HAL_GetTick>
90004d88:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
90004d8a:	e009      	b.n	90004da0 <HAL_PWREx_EnableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
90004d8c:	f7fe fd2e 	bl	900037ec <HAL_GetTick>
90004d90:	4602      	mov	r2, r0
90004d92:	687b      	ldr	r3, [r7, #4]
90004d94:	1ad3      	subs	r3, r2, r3
90004d96:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
90004d9a:	d901      	bls.n	90004da0 <HAL_PWREx_EnableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
90004d9c:	2303      	movs	r3, #3
90004d9e:	e007      	b.n	90004db0 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
90004da0:	4b06      	ldr	r3, [pc, #24]	; (90004dbc <HAL_PWREx_EnableOverDrive+0x9c>)
90004da2:	685b      	ldr	r3, [r3, #4]
90004da4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90004da8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90004dac:	d1ee      	bne.n	90004d8c <HAL_PWREx_EnableOverDrive+0x6c>
    }
  } 
  return HAL_OK;
90004dae:	2300      	movs	r3, #0
}
90004db0:	4618      	mov	r0, r3
90004db2:	3708      	adds	r7, #8
90004db4:	46bd      	mov	sp, r7
90004db6:	bd80      	pop	{r7, pc}
90004db8:	40023800 	.word	0x40023800
90004dbc:	40007000 	.word	0x40007000

90004dc0 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
90004dc0:	b580      	push	{r7, lr}
90004dc2:	b086      	sub	sp, #24
90004dc4:	af00      	add	r7, sp, #0
90004dc6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;
90004dc8:	2300      	movs	r3, #0
90004dca:	75fb      	strb	r3, [r7, #23]

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
90004dcc:	687b      	ldr	r3, [r7, #4]
90004dce:	2b00      	cmp	r3, #0
90004dd0:	d101      	bne.n	90004dd6 <HAL_RCC_OscConfig+0x16>
  {
    return HAL_ERROR;
90004dd2:	2301      	movs	r3, #1
90004dd4:	e291      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
90004dd6:	687b      	ldr	r3, [r7, #4]
90004dd8:	681b      	ldr	r3, [r3, #0]
90004dda:	f003 0301 	and.w	r3, r3, #1
90004dde:	2b00      	cmp	r3, #0
90004de0:	f000 8087 	beq.w	90004ef2 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
90004de4:	4b96      	ldr	r3, [pc, #600]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004de6:	689b      	ldr	r3, [r3, #8]
90004de8:	f003 030c 	and.w	r3, r3, #12
90004dec:	2b04      	cmp	r3, #4
90004dee:	d00c      	beq.n	90004e0a <HAL_RCC_OscConfig+0x4a>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
90004df0:	4b93      	ldr	r3, [pc, #588]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004df2:	689b      	ldr	r3, [r3, #8]
90004df4:	f003 030c 	and.w	r3, r3, #12
90004df8:	2b08      	cmp	r3, #8
90004dfa:	d112      	bne.n	90004e22 <HAL_RCC_OscConfig+0x62>
90004dfc:	4b90      	ldr	r3, [pc, #576]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004dfe:	685b      	ldr	r3, [r3, #4]
90004e00:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90004e04:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90004e08:	d10b      	bne.n	90004e22 <HAL_RCC_OscConfig+0x62>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
90004e0a:	4b8d      	ldr	r3, [pc, #564]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e0c:	681b      	ldr	r3, [r3, #0]
90004e0e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90004e12:	2b00      	cmp	r3, #0
90004e14:	d06c      	beq.n	90004ef0 <HAL_RCC_OscConfig+0x130>
90004e16:	687b      	ldr	r3, [r7, #4]
90004e18:	685b      	ldr	r3, [r3, #4]
90004e1a:	2b00      	cmp	r3, #0
90004e1c:	d168      	bne.n	90004ef0 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
90004e1e:	2301      	movs	r3, #1
90004e20:	e26b      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
90004e22:	687b      	ldr	r3, [r7, #4]
90004e24:	685b      	ldr	r3, [r3, #4]
90004e26:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90004e2a:	d106      	bne.n	90004e3a <HAL_RCC_OscConfig+0x7a>
90004e2c:	4b84      	ldr	r3, [pc, #528]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e2e:	681b      	ldr	r3, [r3, #0]
90004e30:	4a83      	ldr	r2, [pc, #524]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e32:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90004e36:	6013      	str	r3, [r2, #0]
90004e38:	e02e      	b.n	90004e98 <HAL_RCC_OscConfig+0xd8>
90004e3a:	687b      	ldr	r3, [r7, #4]
90004e3c:	685b      	ldr	r3, [r3, #4]
90004e3e:	2b00      	cmp	r3, #0
90004e40:	d10c      	bne.n	90004e5c <HAL_RCC_OscConfig+0x9c>
90004e42:	4b7f      	ldr	r3, [pc, #508]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e44:	681b      	ldr	r3, [r3, #0]
90004e46:	4a7e      	ldr	r2, [pc, #504]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e48:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
90004e4c:	6013      	str	r3, [r2, #0]
90004e4e:	4b7c      	ldr	r3, [pc, #496]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e50:	681b      	ldr	r3, [r3, #0]
90004e52:	4a7b      	ldr	r2, [pc, #492]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e54:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
90004e58:	6013      	str	r3, [r2, #0]
90004e5a:	e01d      	b.n	90004e98 <HAL_RCC_OscConfig+0xd8>
90004e5c:	687b      	ldr	r3, [r7, #4]
90004e5e:	685b      	ldr	r3, [r3, #4]
90004e60:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
90004e64:	d10c      	bne.n	90004e80 <HAL_RCC_OscConfig+0xc0>
90004e66:	4b76      	ldr	r3, [pc, #472]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e68:	681b      	ldr	r3, [r3, #0]
90004e6a:	4a75      	ldr	r2, [pc, #468]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e6c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
90004e70:	6013      	str	r3, [r2, #0]
90004e72:	4b73      	ldr	r3, [pc, #460]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e74:	681b      	ldr	r3, [r3, #0]
90004e76:	4a72      	ldr	r2, [pc, #456]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e78:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90004e7c:	6013      	str	r3, [r2, #0]
90004e7e:	e00b      	b.n	90004e98 <HAL_RCC_OscConfig+0xd8>
90004e80:	4b6f      	ldr	r3, [pc, #444]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e82:	681b      	ldr	r3, [r3, #0]
90004e84:	4a6e      	ldr	r2, [pc, #440]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e86:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
90004e8a:	6013      	str	r3, [r2, #0]
90004e8c:	4b6c      	ldr	r3, [pc, #432]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e8e:	681b      	ldr	r3, [r3, #0]
90004e90:	4a6b      	ldr	r2, [pc, #428]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004e92:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
90004e96:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
90004e98:	687b      	ldr	r3, [r7, #4]
90004e9a:	685b      	ldr	r3, [r3, #4]
90004e9c:	2b00      	cmp	r3, #0
90004e9e:	d013      	beq.n	90004ec8 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90004ea0:	f7fe fca4 	bl	900037ec <HAL_GetTick>
90004ea4:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
90004ea6:	e008      	b.n	90004eba <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
90004ea8:	f7fe fca0 	bl	900037ec <HAL_GetTick>
90004eac:	4602      	mov	r2, r0
90004eae:	693b      	ldr	r3, [r7, #16]
90004eb0:	1ad3      	subs	r3, r2, r3
90004eb2:	2b64      	cmp	r3, #100	; 0x64
90004eb4:	d901      	bls.n	90004eba <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
90004eb6:	2303      	movs	r3, #3
90004eb8:	e21f      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
90004eba:	4b61      	ldr	r3, [pc, #388]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004ebc:	681b      	ldr	r3, [r3, #0]
90004ebe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90004ec2:	2b00      	cmp	r3, #0
90004ec4:	d0f0      	beq.n	90004ea8 <HAL_RCC_OscConfig+0xe8>
90004ec6:	e014      	b.n	90004ef2 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90004ec8:	f7fe fc90 	bl	900037ec <HAL_GetTick>
90004ecc:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
90004ece:	e008      	b.n	90004ee2 <HAL_RCC_OscConfig+0x122>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
90004ed0:	f7fe fc8c 	bl	900037ec <HAL_GetTick>
90004ed4:	4602      	mov	r2, r0
90004ed6:	693b      	ldr	r3, [r7, #16]
90004ed8:	1ad3      	subs	r3, r2, r3
90004eda:	2b64      	cmp	r3, #100	; 0x64
90004edc:	d901      	bls.n	90004ee2 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
90004ede:	2303      	movs	r3, #3
90004ee0:	e20b      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
90004ee2:	4b57      	ldr	r3, [pc, #348]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004ee4:	681b      	ldr	r3, [r3, #0]
90004ee6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90004eea:	2b00      	cmp	r3, #0
90004eec:	d1f0      	bne.n	90004ed0 <HAL_RCC_OscConfig+0x110>
90004eee:	e000      	b.n	90004ef2 <HAL_RCC_OscConfig+0x132>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
90004ef0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
90004ef2:	687b      	ldr	r3, [r7, #4]
90004ef4:	681b      	ldr	r3, [r3, #0]
90004ef6:	f003 0302 	and.w	r3, r3, #2
90004efa:	2b00      	cmp	r3, #0
90004efc:	d069      	beq.n	90004fd2 <HAL_RCC_OscConfig+0x212>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
90004efe:	4b50      	ldr	r3, [pc, #320]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f00:	689b      	ldr	r3, [r3, #8]
90004f02:	f003 030c 	and.w	r3, r3, #12
90004f06:	2b00      	cmp	r3, #0
90004f08:	d00b      	beq.n	90004f22 <HAL_RCC_OscConfig+0x162>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
90004f0a:	4b4d      	ldr	r3, [pc, #308]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f0c:	689b      	ldr	r3, [r3, #8]
90004f0e:	f003 030c 	and.w	r3, r3, #12
90004f12:	2b08      	cmp	r3, #8
90004f14:	d11c      	bne.n	90004f50 <HAL_RCC_OscConfig+0x190>
90004f16:	4b4a      	ldr	r3, [pc, #296]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f18:	685b      	ldr	r3, [r3, #4]
90004f1a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90004f1e:	2b00      	cmp	r3, #0
90004f20:	d116      	bne.n	90004f50 <HAL_RCC_OscConfig+0x190>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
90004f22:	4b47      	ldr	r3, [pc, #284]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f24:	681b      	ldr	r3, [r3, #0]
90004f26:	f003 0302 	and.w	r3, r3, #2
90004f2a:	2b00      	cmp	r3, #0
90004f2c:	d005      	beq.n	90004f3a <HAL_RCC_OscConfig+0x17a>
90004f2e:	687b      	ldr	r3, [r7, #4]
90004f30:	68db      	ldr	r3, [r3, #12]
90004f32:	2b01      	cmp	r3, #1
90004f34:	d001      	beq.n	90004f3a <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
90004f36:	2301      	movs	r3, #1
90004f38:	e1df      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
90004f3a:	4b41      	ldr	r3, [pc, #260]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f3c:	681b      	ldr	r3, [r3, #0]
90004f3e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
90004f42:	687b      	ldr	r3, [r7, #4]
90004f44:	691b      	ldr	r3, [r3, #16]
90004f46:	00db      	lsls	r3, r3, #3
90004f48:	493d      	ldr	r1, [pc, #244]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f4a:	4313      	orrs	r3, r2
90004f4c:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
90004f4e:	e040      	b.n	90004fd2 <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
90004f50:	687b      	ldr	r3, [r7, #4]
90004f52:	68db      	ldr	r3, [r3, #12]
90004f54:	2b00      	cmp	r3, #0
90004f56:	d023      	beq.n	90004fa0 <HAL_RCC_OscConfig+0x1e0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
90004f58:	4b39      	ldr	r3, [pc, #228]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f5a:	681b      	ldr	r3, [r3, #0]
90004f5c:	4a38      	ldr	r2, [pc, #224]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f5e:	f043 0301 	orr.w	r3, r3, #1
90004f62:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90004f64:	f7fe fc42 	bl	900037ec <HAL_GetTick>
90004f68:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
90004f6a:	e008      	b.n	90004f7e <HAL_RCC_OscConfig+0x1be>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
90004f6c:	f7fe fc3e 	bl	900037ec <HAL_GetTick>
90004f70:	4602      	mov	r2, r0
90004f72:	693b      	ldr	r3, [r7, #16]
90004f74:	1ad3      	subs	r3, r2, r3
90004f76:	2b02      	cmp	r3, #2
90004f78:	d901      	bls.n	90004f7e <HAL_RCC_OscConfig+0x1be>
          {
            return HAL_TIMEOUT;
90004f7a:	2303      	movs	r3, #3
90004f7c:	e1bd      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
90004f7e:	4b30      	ldr	r3, [pc, #192]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f80:	681b      	ldr	r3, [r3, #0]
90004f82:	f003 0302 	and.w	r3, r3, #2
90004f86:	2b00      	cmp	r3, #0
90004f88:	d0f0      	beq.n	90004f6c <HAL_RCC_OscConfig+0x1ac>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
90004f8a:	4b2d      	ldr	r3, [pc, #180]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f8c:	681b      	ldr	r3, [r3, #0]
90004f8e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
90004f92:	687b      	ldr	r3, [r7, #4]
90004f94:	691b      	ldr	r3, [r3, #16]
90004f96:	00db      	lsls	r3, r3, #3
90004f98:	4929      	ldr	r1, [pc, #164]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004f9a:	4313      	orrs	r3, r2
90004f9c:	600b      	str	r3, [r1, #0]
90004f9e:	e018      	b.n	90004fd2 <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
90004fa0:	4b27      	ldr	r3, [pc, #156]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004fa2:	681b      	ldr	r3, [r3, #0]
90004fa4:	4a26      	ldr	r2, [pc, #152]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004fa6:	f023 0301 	bic.w	r3, r3, #1
90004faa:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90004fac:	f7fe fc1e 	bl	900037ec <HAL_GetTick>
90004fb0:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
90004fb2:	e008      	b.n	90004fc6 <HAL_RCC_OscConfig+0x206>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
90004fb4:	f7fe fc1a 	bl	900037ec <HAL_GetTick>
90004fb8:	4602      	mov	r2, r0
90004fba:	693b      	ldr	r3, [r7, #16]
90004fbc:	1ad3      	subs	r3, r2, r3
90004fbe:	2b02      	cmp	r3, #2
90004fc0:	d901      	bls.n	90004fc6 <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
90004fc2:	2303      	movs	r3, #3
90004fc4:	e199      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
90004fc6:	4b1e      	ldr	r3, [pc, #120]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004fc8:	681b      	ldr	r3, [r3, #0]
90004fca:	f003 0302 	and.w	r3, r3, #2
90004fce:	2b00      	cmp	r3, #0
90004fd0:	d1f0      	bne.n	90004fb4 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
90004fd2:	687b      	ldr	r3, [r7, #4]
90004fd4:	681b      	ldr	r3, [r3, #0]
90004fd6:	f003 0308 	and.w	r3, r3, #8
90004fda:	2b00      	cmp	r3, #0
90004fdc:	d038      	beq.n	90005050 <HAL_RCC_OscConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
90004fde:	687b      	ldr	r3, [r7, #4]
90004fe0:	695b      	ldr	r3, [r3, #20]
90004fe2:	2b00      	cmp	r3, #0
90004fe4:	d019      	beq.n	9000501a <HAL_RCC_OscConfig+0x25a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
90004fe6:	4b16      	ldr	r3, [pc, #88]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004fe8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90004fea:	4a15      	ldr	r2, [pc, #84]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90004fec:	f043 0301 	orr.w	r3, r3, #1
90004ff0:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
90004ff2:	f7fe fbfb 	bl	900037ec <HAL_GetTick>
90004ff6:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
90004ff8:	e008      	b.n	9000500c <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
90004ffa:	f7fe fbf7 	bl	900037ec <HAL_GetTick>
90004ffe:	4602      	mov	r2, r0
90005000:	693b      	ldr	r3, [r7, #16]
90005002:	1ad3      	subs	r3, r2, r3
90005004:	2b02      	cmp	r3, #2
90005006:	d901      	bls.n	9000500c <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
90005008:	2303      	movs	r3, #3
9000500a:	e176      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
9000500c:	4b0c      	ldr	r3, [pc, #48]	; (90005040 <HAL_RCC_OscConfig+0x280>)
9000500e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90005010:	f003 0302 	and.w	r3, r3, #2
90005014:	2b00      	cmp	r3, #0
90005016:	d0f0      	beq.n	90004ffa <HAL_RCC_OscConfig+0x23a>
90005018:	e01a      	b.n	90005050 <HAL_RCC_OscConfig+0x290>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
9000501a:	4b09      	ldr	r3, [pc, #36]	; (90005040 <HAL_RCC_OscConfig+0x280>)
9000501c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
9000501e:	4a08      	ldr	r2, [pc, #32]	; (90005040 <HAL_RCC_OscConfig+0x280>)
90005020:	f023 0301 	bic.w	r3, r3, #1
90005024:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
90005026:	f7fe fbe1 	bl	900037ec <HAL_GetTick>
9000502a:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
9000502c:	e00a      	b.n	90005044 <HAL_RCC_OscConfig+0x284>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
9000502e:	f7fe fbdd 	bl	900037ec <HAL_GetTick>
90005032:	4602      	mov	r2, r0
90005034:	693b      	ldr	r3, [r7, #16]
90005036:	1ad3      	subs	r3, r2, r3
90005038:	2b02      	cmp	r3, #2
9000503a:	d903      	bls.n	90005044 <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
9000503c:	2303      	movs	r3, #3
9000503e:	e15c      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
90005040:	40023800 	.word	0x40023800
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
90005044:	4b91      	ldr	r3, [pc, #580]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005046:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90005048:	f003 0302 	and.w	r3, r3, #2
9000504c:	2b00      	cmp	r3, #0
9000504e:	d1ee      	bne.n	9000502e <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
90005050:	687b      	ldr	r3, [r7, #4]
90005052:	681b      	ldr	r3, [r3, #0]
90005054:	f003 0304 	and.w	r3, r3, #4
90005058:	2b00      	cmp	r3, #0
9000505a:	f000 80a4 	beq.w	900051a6 <HAL_RCC_OscConfig+0x3e6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
9000505e:	4b8b      	ldr	r3, [pc, #556]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005060:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90005062:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90005066:	2b00      	cmp	r3, #0
90005068:	d10d      	bne.n	90005086 <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
9000506a:	4b88      	ldr	r3, [pc, #544]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000506c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000506e:	4a87      	ldr	r2, [pc, #540]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005070:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90005074:	6413      	str	r3, [r2, #64]	; 0x40
90005076:	4b85      	ldr	r3, [pc, #532]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005078:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000507a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
9000507e:	60bb      	str	r3, [r7, #8]
90005080:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
90005082:	2301      	movs	r3, #1
90005084:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
90005086:	4b82      	ldr	r3, [pc, #520]	; (90005290 <HAL_RCC_OscConfig+0x4d0>)
90005088:	681b      	ldr	r3, [r3, #0]
9000508a:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000508e:	2b00      	cmp	r3, #0
90005090:	d118      	bne.n	900050c4 <HAL_RCC_OscConfig+0x304>
    {
      /* Enable write access to Backup domain */
      PWR->CR1 |= PWR_CR1_DBP;
90005092:	4b7f      	ldr	r3, [pc, #508]	; (90005290 <HAL_RCC_OscConfig+0x4d0>)
90005094:	681b      	ldr	r3, [r3, #0]
90005096:	4a7e      	ldr	r2, [pc, #504]	; (90005290 <HAL_RCC_OscConfig+0x4d0>)
90005098:	f443 7380 	orr.w	r3, r3, #256	; 0x100
9000509c:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
9000509e:	f7fe fba5 	bl	900037ec <HAL_GetTick>
900050a2:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
900050a4:	e008      	b.n	900050b8 <HAL_RCC_OscConfig+0x2f8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
900050a6:	f7fe fba1 	bl	900037ec <HAL_GetTick>
900050aa:	4602      	mov	r2, r0
900050ac:	693b      	ldr	r3, [r7, #16]
900050ae:	1ad3      	subs	r3, r2, r3
900050b0:	2b64      	cmp	r3, #100	; 0x64
900050b2:	d901      	bls.n	900050b8 <HAL_RCC_OscConfig+0x2f8>
        {
          return HAL_TIMEOUT;
900050b4:	2303      	movs	r3, #3
900050b6:	e120      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
900050b8:	4b75      	ldr	r3, [pc, #468]	; (90005290 <HAL_RCC_OscConfig+0x4d0>)
900050ba:	681b      	ldr	r3, [r3, #0]
900050bc:	f403 7380 	and.w	r3, r3, #256	; 0x100
900050c0:	2b00      	cmp	r3, #0
900050c2:	d0f0      	beq.n	900050a6 <HAL_RCC_OscConfig+0x2e6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
900050c4:	687b      	ldr	r3, [r7, #4]
900050c6:	689b      	ldr	r3, [r3, #8]
900050c8:	2b01      	cmp	r3, #1
900050ca:	d106      	bne.n	900050da <HAL_RCC_OscConfig+0x31a>
900050cc:	4b6f      	ldr	r3, [pc, #444]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900050ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900050d0:	4a6e      	ldr	r2, [pc, #440]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900050d2:	f043 0301 	orr.w	r3, r3, #1
900050d6:	6713      	str	r3, [r2, #112]	; 0x70
900050d8:	e02d      	b.n	90005136 <HAL_RCC_OscConfig+0x376>
900050da:	687b      	ldr	r3, [r7, #4]
900050dc:	689b      	ldr	r3, [r3, #8]
900050de:	2b00      	cmp	r3, #0
900050e0:	d10c      	bne.n	900050fc <HAL_RCC_OscConfig+0x33c>
900050e2:	4b6a      	ldr	r3, [pc, #424]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900050e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900050e6:	4a69      	ldr	r2, [pc, #420]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900050e8:	f023 0301 	bic.w	r3, r3, #1
900050ec:	6713      	str	r3, [r2, #112]	; 0x70
900050ee:	4b67      	ldr	r3, [pc, #412]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900050f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900050f2:	4a66      	ldr	r2, [pc, #408]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900050f4:	f023 0304 	bic.w	r3, r3, #4
900050f8:	6713      	str	r3, [r2, #112]	; 0x70
900050fa:	e01c      	b.n	90005136 <HAL_RCC_OscConfig+0x376>
900050fc:	687b      	ldr	r3, [r7, #4]
900050fe:	689b      	ldr	r3, [r3, #8]
90005100:	2b05      	cmp	r3, #5
90005102:	d10c      	bne.n	9000511e <HAL_RCC_OscConfig+0x35e>
90005104:	4b61      	ldr	r3, [pc, #388]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005106:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90005108:	4a60      	ldr	r2, [pc, #384]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000510a:	f043 0304 	orr.w	r3, r3, #4
9000510e:	6713      	str	r3, [r2, #112]	; 0x70
90005110:	4b5e      	ldr	r3, [pc, #376]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005112:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90005114:	4a5d      	ldr	r2, [pc, #372]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005116:	f043 0301 	orr.w	r3, r3, #1
9000511a:	6713      	str	r3, [r2, #112]	; 0x70
9000511c:	e00b      	b.n	90005136 <HAL_RCC_OscConfig+0x376>
9000511e:	4b5b      	ldr	r3, [pc, #364]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005120:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90005122:	4a5a      	ldr	r2, [pc, #360]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005124:	f023 0301 	bic.w	r3, r3, #1
90005128:	6713      	str	r3, [r2, #112]	; 0x70
9000512a:	4b58      	ldr	r3, [pc, #352]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000512c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000512e:	4a57      	ldr	r2, [pc, #348]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005130:	f023 0304 	bic.w	r3, r3, #4
90005134:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
90005136:	687b      	ldr	r3, [r7, #4]
90005138:	689b      	ldr	r3, [r3, #8]
9000513a:	2b00      	cmp	r3, #0
9000513c:	d015      	beq.n	9000516a <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
9000513e:	f7fe fb55 	bl	900037ec <HAL_GetTick>
90005142:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
90005144:	e00a      	b.n	9000515c <HAL_RCC_OscConfig+0x39c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90005146:	f7fe fb51 	bl	900037ec <HAL_GetTick>
9000514a:	4602      	mov	r2, r0
9000514c:	693b      	ldr	r3, [r7, #16]
9000514e:	1ad3      	subs	r3, r2, r3
90005150:	f241 3288 	movw	r2, #5000	; 0x1388
90005154:	4293      	cmp	r3, r2
90005156:	d901      	bls.n	9000515c <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
90005158:	2303      	movs	r3, #3
9000515a:	e0ce      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
9000515c:	4b4b      	ldr	r3, [pc, #300]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000515e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90005160:	f003 0302 	and.w	r3, r3, #2
90005164:	2b00      	cmp	r3, #0
90005166:	d0ee      	beq.n	90005146 <HAL_RCC_OscConfig+0x386>
90005168:	e014      	b.n	90005194 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
9000516a:	f7fe fb3f 	bl	900037ec <HAL_GetTick>
9000516e:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
90005170:	e00a      	b.n	90005188 <HAL_RCC_OscConfig+0x3c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90005172:	f7fe fb3b 	bl	900037ec <HAL_GetTick>
90005176:	4602      	mov	r2, r0
90005178:	693b      	ldr	r3, [r7, #16]
9000517a:	1ad3      	subs	r3, r2, r3
9000517c:	f241 3288 	movw	r2, #5000	; 0x1388
90005180:	4293      	cmp	r3, r2
90005182:	d901      	bls.n	90005188 <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
90005184:	2303      	movs	r3, #3
90005186:	e0b8      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
90005188:	4b40      	ldr	r3, [pc, #256]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000518a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000518c:	f003 0302 	and.w	r3, r3, #2
90005190:	2b00      	cmp	r3, #0
90005192:	d1ee      	bne.n	90005172 <HAL_RCC_OscConfig+0x3b2>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
90005194:	7dfb      	ldrb	r3, [r7, #23]
90005196:	2b01      	cmp	r3, #1
90005198:	d105      	bne.n	900051a6 <HAL_RCC_OscConfig+0x3e6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
9000519a:	4b3c      	ldr	r3, [pc, #240]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000519c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000519e:	4a3b      	ldr	r2, [pc, #236]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900051a0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
900051a4:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
900051a6:	687b      	ldr	r3, [r7, #4]
900051a8:	699b      	ldr	r3, [r3, #24]
900051aa:	2b00      	cmp	r3, #0
900051ac:	f000 80a4 	beq.w	900052f8 <HAL_RCC_OscConfig+0x538>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
900051b0:	4b36      	ldr	r3, [pc, #216]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900051b2:	689b      	ldr	r3, [r3, #8]
900051b4:	f003 030c 	and.w	r3, r3, #12
900051b8:	2b08      	cmp	r3, #8
900051ba:	d06b      	beq.n	90005294 <HAL_RCC_OscConfig+0x4d4>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
900051bc:	687b      	ldr	r3, [r7, #4]
900051be:	699b      	ldr	r3, [r3, #24]
900051c0:	2b02      	cmp	r3, #2
900051c2:	d149      	bne.n	90005258 <HAL_RCC_OscConfig+0x498>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
900051c4:	4b31      	ldr	r3, [pc, #196]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900051c6:	681b      	ldr	r3, [r3, #0]
900051c8:	4a30      	ldr	r2, [pc, #192]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900051ca:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
900051ce:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
900051d0:	f7fe fb0c 	bl	900037ec <HAL_GetTick>
900051d4:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
900051d6:	e008      	b.n	900051ea <HAL_RCC_OscConfig+0x42a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
900051d8:	f7fe fb08 	bl	900037ec <HAL_GetTick>
900051dc:	4602      	mov	r2, r0
900051de:	693b      	ldr	r3, [r7, #16]
900051e0:	1ad3      	subs	r3, r2, r3
900051e2:	2b02      	cmp	r3, #2
900051e4:	d901      	bls.n	900051ea <HAL_RCC_OscConfig+0x42a>
          {
            return HAL_TIMEOUT;
900051e6:	2303      	movs	r3, #3
900051e8:	e087      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
900051ea:	4b28      	ldr	r3, [pc, #160]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
900051ec:	681b      	ldr	r3, [r3, #0]
900051ee:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
900051f2:	2b00      	cmp	r3, #0
900051f4:	d1f0      	bne.n	900051d8 <HAL_RCC_OscConfig+0x418>
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);
#else
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
900051f6:	687b      	ldr	r3, [r7, #4]
900051f8:	69da      	ldr	r2, [r3, #28]
900051fa:	687b      	ldr	r3, [r7, #4]
900051fc:	6a1b      	ldr	r3, [r3, #32]
900051fe:	431a      	orrs	r2, r3
90005200:	687b      	ldr	r3, [r7, #4]
90005202:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90005204:	019b      	lsls	r3, r3, #6
90005206:	431a      	orrs	r2, r3
90005208:	687b      	ldr	r3, [r7, #4]
9000520a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000520c:	085b      	lsrs	r3, r3, #1
9000520e:	3b01      	subs	r3, #1
90005210:	041b      	lsls	r3, r3, #16
90005212:	431a      	orrs	r2, r3
90005214:	687b      	ldr	r3, [r7, #4]
90005216:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90005218:	061b      	lsls	r3, r3, #24
9000521a:	4313      	orrs	r3, r2
9000521c:	4a1b      	ldr	r2, [pc, #108]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000521e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
90005222:	6053      	str	r3, [r2, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
90005224:	4b19      	ldr	r3, [pc, #100]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005226:	681b      	ldr	r3, [r3, #0]
90005228:	4a18      	ldr	r2, [pc, #96]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000522a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
9000522e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90005230:	f7fe fadc 	bl	900037ec <HAL_GetTick>
90005234:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
90005236:	e008      	b.n	9000524a <HAL_RCC_OscConfig+0x48a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
90005238:	f7fe fad8 	bl	900037ec <HAL_GetTick>
9000523c:	4602      	mov	r2, r0
9000523e:	693b      	ldr	r3, [r7, #16]
90005240:	1ad3      	subs	r3, r2, r3
90005242:	2b02      	cmp	r3, #2
90005244:	d901      	bls.n	9000524a <HAL_RCC_OscConfig+0x48a>
          {
            return HAL_TIMEOUT;
90005246:	2303      	movs	r3, #3
90005248:	e057      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
9000524a:	4b10      	ldr	r3, [pc, #64]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000524c:	681b      	ldr	r3, [r3, #0]
9000524e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90005252:	2b00      	cmp	r3, #0
90005254:	d0f0      	beq.n	90005238 <HAL_RCC_OscConfig+0x478>
90005256:	e04f      	b.n	900052f8 <HAL_RCC_OscConfig+0x538>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
90005258:	4b0c      	ldr	r3, [pc, #48]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000525a:	681b      	ldr	r3, [r3, #0]
9000525c:	4a0b      	ldr	r2, [pc, #44]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
9000525e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
90005262:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90005264:	f7fe fac2 	bl	900037ec <HAL_GetTick>
90005268:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
9000526a:	e008      	b.n	9000527e <HAL_RCC_OscConfig+0x4be>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
9000526c:	f7fe fabe 	bl	900037ec <HAL_GetTick>
90005270:	4602      	mov	r2, r0
90005272:	693b      	ldr	r3, [r7, #16]
90005274:	1ad3      	subs	r3, r2, r3
90005276:	2b02      	cmp	r3, #2
90005278:	d901      	bls.n	9000527e <HAL_RCC_OscConfig+0x4be>
          {
            return HAL_TIMEOUT;
9000527a:	2303      	movs	r3, #3
9000527c:	e03d      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
9000527e:	4b03      	ldr	r3, [pc, #12]	; (9000528c <HAL_RCC_OscConfig+0x4cc>)
90005280:	681b      	ldr	r3, [r3, #0]
90005282:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90005286:	2b00      	cmp	r3, #0
90005288:	d1f0      	bne.n	9000526c <HAL_RCC_OscConfig+0x4ac>
9000528a:	e035      	b.n	900052f8 <HAL_RCC_OscConfig+0x538>
9000528c:	40023800 	.word	0x40023800
90005290:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      pll_config = RCC->PLLCFGR;
90005294:	4b1b      	ldr	r3, [pc, #108]	; (90005304 <HAL_RCC_OscConfig+0x544>)
90005296:	685b      	ldr	r3, [r3, #4]
90005298:	60fb      	str	r3, [r7, #12]
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
9000529a:	687b      	ldr	r3, [r7, #4]
9000529c:	699b      	ldr	r3, [r3, #24]
9000529e:	2b01      	cmp	r3, #1
900052a0:	d028      	beq.n	900052f4 <HAL_RCC_OscConfig+0x534>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
900052a2:	68fb      	ldr	r3, [r7, #12]
900052a4:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
900052a8:	687b      	ldr	r3, [r7, #4]
900052aa:	69db      	ldr	r3, [r3, #28]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
900052ac:	429a      	cmp	r2, r3
900052ae:	d121      	bne.n	900052f4 <HAL_RCC_OscConfig+0x534>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
900052b0:	68fb      	ldr	r3, [r7, #12]
900052b2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
900052b6:	687b      	ldr	r3, [r7, #4]
900052b8:	6a1b      	ldr	r3, [r3, #32]
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
900052ba:	429a      	cmp	r2, r3
900052bc:	d11a      	bne.n	900052f4 <HAL_RCC_OscConfig+0x534>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
900052be:	68fa      	ldr	r2, [r7, #12]
900052c0:	f647 73c0 	movw	r3, #32704	; 0x7fc0
900052c4:	4013      	ands	r3, r2
900052c6:	687a      	ldr	r2, [r7, #4]
900052c8:	6a52      	ldr	r2, [r2, #36]	; 0x24
900052ca:	0192      	lsls	r2, r2, #6
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
900052cc:	4293      	cmp	r3, r2
900052ce:	d111      	bne.n	900052f4 <HAL_RCC_OscConfig+0x534>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
900052d0:	68fb      	ldr	r3, [r7, #12]
900052d2:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
900052d6:	687b      	ldr	r3, [r7, #4]
900052d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900052da:	085b      	lsrs	r3, r3, #1
900052dc:	3b01      	subs	r3, #1
900052de:	041b      	lsls	r3, r3, #16
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
900052e0:	429a      	cmp	r2, r3
900052e2:	d107      	bne.n	900052f4 <HAL_RCC_OscConfig+0x534>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
900052e4:	68fb      	ldr	r3, [r7, #12]
900052e6:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
900052ea:	687b      	ldr	r3, [r7, #4]
900052ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900052ee:	061b      	lsls	r3, r3, #24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
900052f0:	429a      	cmp	r2, r3
900052f2:	d001      	beq.n	900052f8 <HAL_RCC_OscConfig+0x538>
#endif
      {
        return HAL_ERROR;
900052f4:	2301      	movs	r3, #1
900052f6:	e000      	b.n	900052fa <HAL_RCC_OscConfig+0x53a>
      }
    }
  }
  return HAL_OK;
900052f8:	2300      	movs	r3, #0
}
900052fa:	4618      	mov	r0, r3
900052fc:	3718      	adds	r7, #24
900052fe:	46bd      	mov	sp, r7
90005300:	bd80      	pop	{r7, pc}
90005302:	bf00      	nop
90005304:	40023800 	.word	0x40023800

90005308 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
90005308:	b580      	push	{r7, lr}
9000530a:	b084      	sub	sp, #16
9000530c:	af00      	add	r7, sp, #0
9000530e:	6078      	str	r0, [r7, #4]
90005310:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
90005312:	2300      	movs	r3, #0
90005314:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
90005316:	687b      	ldr	r3, [r7, #4]
90005318:	2b00      	cmp	r3, #0
9000531a:	d101      	bne.n	90005320 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
9000531c:	2301      	movs	r3, #1
9000531e:	e0d0      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
90005320:	4b6a      	ldr	r3, [pc, #424]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
90005322:	681b      	ldr	r3, [r3, #0]
90005324:	f003 030f 	and.w	r3, r3, #15
90005328:	683a      	ldr	r2, [r7, #0]
9000532a:	429a      	cmp	r2, r3
9000532c:	d910      	bls.n	90005350 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
9000532e:	4b67      	ldr	r3, [pc, #412]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
90005330:	681b      	ldr	r3, [r3, #0]
90005332:	f023 020f 	bic.w	r2, r3, #15
90005336:	4965      	ldr	r1, [pc, #404]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
90005338:	683b      	ldr	r3, [r7, #0]
9000533a:	4313      	orrs	r3, r2
9000533c:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
9000533e:	4b63      	ldr	r3, [pc, #396]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
90005340:	681b      	ldr	r3, [r3, #0]
90005342:	f003 030f 	and.w	r3, r3, #15
90005346:	683a      	ldr	r2, [r7, #0]
90005348:	429a      	cmp	r2, r3
9000534a:	d001      	beq.n	90005350 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
9000534c:	2301      	movs	r3, #1
9000534e:	e0b8      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
90005350:	687b      	ldr	r3, [r7, #4]
90005352:	681b      	ldr	r3, [r3, #0]
90005354:	f003 0302 	and.w	r3, r3, #2
90005358:	2b00      	cmp	r3, #0
9000535a:	d020      	beq.n	9000539e <HAL_RCC_ClockConfig+0x96>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
9000535c:	687b      	ldr	r3, [r7, #4]
9000535e:	681b      	ldr	r3, [r3, #0]
90005360:	f003 0304 	and.w	r3, r3, #4
90005364:	2b00      	cmp	r3, #0
90005366:	d005      	beq.n	90005374 <HAL_RCC_ClockConfig+0x6c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
90005368:	4b59      	ldr	r3, [pc, #356]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
9000536a:	689b      	ldr	r3, [r3, #8]
9000536c:	4a58      	ldr	r2, [pc, #352]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
9000536e:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
90005372:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
90005374:	687b      	ldr	r3, [r7, #4]
90005376:	681b      	ldr	r3, [r3, #0]
90005378:	f003 0308 	and.w	r3, r3, #8
9000537c:	2b00      	cmp	r3, #0
9000537e:	d005      	beq.n	9000538c <HAL_RCC_ClockConfig+0x84>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
90005380:	4b53      	ldr	r3, [pc, #332]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
90005382:	689b      	ldr	r3, [r3, #8]
90005384:	4a52      	ldr	r2, [pc, #328]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
90005386:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
9000538a:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
9000538c:	4b50      	ldr	r3, [pc, #320]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
9000538e:	689b      	ldr	r3, [r3, #8]
90005390:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
90005394:	687b      	ldr	r3, [r7, #4]
90005396:	689b      	ldr	r3, [r3, #8]
90005398:	494d      	ldr	r1, [pc, #308]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
9000539a:	4313      	orrs	r3, r2
9000539c:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
9000539e:	687b      	ldr	r3, [r7, #4]
900053a0:	681b      	ldr	r3, [r3, #0]
900053a2:	f003 0301 	and.w	r3, r3, #1
900053a6:	2b00      	cmp	r3, #0
900053a8:	d040      	beq.n	9000542c <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
900053aa:	687b      	ldr	r3, [r7, #4]
900053ac:	685b      	ldr	r3, [r3, #4]
900053ae:	2b01      	cmp	r3, #1
900053b0:	d107      	bne.n	900053c2 <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
900053b2:	4b47      	ldr	r3, [pc, #284]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
900053b4:	681b      	ldr	r3, [r3, #0]
900053b6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
900053ba:	2b00      	cmp	r3, #0
900053bc:	d115      	bne.n	900053ea <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
900053be:	2301      	movs	r3, #1
900053c0:	e07f      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
900053c2:	687b      	ldr	r3, [r7, #4]
900053c4:	685b      	ldr	r3, [r3, #4]
900053c6:	2b02      	cmp	r3, #2
900053c8:	d107      	bne.n	900053da <HAL_RCC_ClockConfig+0xd2>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
900053ca:	4b41      	ldr	r3, [pc, #260]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
900053cc:	681b      	ldr	r3, [r3, #0]
900053ce:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
900053d2:	2b00      	cmp	r3, #0
900053d4:	d109      	bne.n	900053ea <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
900053d6:	2301      	movs	r3, #1
900053d8:	e073      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
900053da:	4b3d      	ldr	r3, [pc, #244]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
900053dc:	681b      	ldr	r3, [r3, #0]
900053de:	f003 0302 	and.w	r3, r3, #2
900053e2:	2b00      	cmp	r3, #0
900053e4:	d101      	bne.n	900053ea <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
900053e6:	2301      	movs	r3, #1
900053e8:	e06b      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
900053ea:	4b39      	ldr	r3, [pc, #228]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
900053ec:	689b      	ldr	r3, [r3, #8]
900053ee:	f023 0203 	bic.w	r2, r3, #3
900053f2:	687b      	ldr	r3, [r7, #4]
900053f4:	685b      	ldr	r3, [r3, #4]
900053f6:	4936      	ldr	r1, [pc, #216]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
900053f8:	4313      	orrs	r3, r2
900053fa:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
900053fc:	f7fe f9f6 	bl	900037ec <HAL_GetTick>
90005400:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
90005402:	e00a      	b.n	9000541a <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
90005404:	f7fe f9f2 	bl	900037ec <HAL_GetTick>
90005408:	4602      	mov	r2, r0
9000540a:	68fb      	ldr	r3, [r7, #12]
9000540c:	1ad3      	subs	r3, r2, r3
9000540e:	f241 3288 	movw	r2, #5000	; 0x1388
90005412:	4293      	cmp	r3, r2
90005414:	d901      	bls.n	9000541a <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
90005416:	2303      	movs	r3, #3
90005418:	e053      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
9000541a:	4b2d      	ldr	r3, [pc, #180]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
9000541c:	689b      	ldr	r3, [r3, #8]
9000541e:	f003 020c 	and.w	r2, r3, #12
90005422:	687b      	ldr	r3, [r7, #4]
90005424:	685b      	ldr	r3, [r3, #4]
90005426:	009b      	lsls	r3, r3, #2
90005428:	429a      	cmp	r2, r3
9000542a:	d1eb      	bne.n	90005404 <HAL_RCC_ClockConfig+0xfc>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
9000542c:	4b27      	ldr	r3, [pc, #156]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
9000542e:	681b      	ldr	r3, [r3, #0]
90005430:	f003 030f 	and.w	r3, r3, #15
90005434:	683a      	ldr	r2, [r7, #0]
90005436:	429a      	cmp	r2, r3
90005438:	d210      	bcs.n	9000545c <HAL_RCC_ClockConfig+0x154>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
9000543a:	4b24      	ldr	r3, [pc, #144]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
9000543c:	681b      	ldr	r3, [r3, #0]
9000543e:	f023 020f 	bic.w	r2, r3, #15
90005442:	4922      	ldr	r1, [pc, #136]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
90005444:	683b      	ldr	r3, [r7, #0]
90005446:	4313      	orrs	r3, r2
90005448:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
9000544a:	4b20      	ldr	r3, [pc, #128]	; (900054cc <HAL_RCC_ClockConfig+0x1c4>)
9000544c:	681b      	ldr	r3, [r3, #0]
9000544e:	f003 030f 	and.w	r3, r3, #15
90005452:	683a      	ldr	r2, [r7, #0]
90005454:	429a      	cmp	r2, r3
90005456:	d001      	beq.n	9000545c <HAL_RCC_ClockConfig+0x154>
    {
      return HAL_ERROR;
90005458:	2301      	movs	r3, #1
9000545a:	e032      	b.n	900054c2 <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
9000545c:	687b      	ldr	r3, [r7, #4]
9000545e:	681b      	ldr	r3, [r3, #0]
90005460:	f003 0304 	and.w	r3, r3, #4
90005464:	2b00      	cmp	r3, #0
90005466:	d008      	beq.n	9000547a <HAL_RCC_ClockConfig+0x172>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
90005468:	4b19      	ldr	r3, [pc, #100]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
9000546a:	689b      	ldr	r3, [r3, #8]
9000546c:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
90005470:	687b      	ldr	r3, [r7, #4]
90005472:	68db      	ldr	r3, [r3, #12]
90005474:	4916      	ldr	r1, [pc, #88]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
90005476:	4313      	orrs	r3, r2
90005478:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
9000547a:	687b      	ldr	r3, [r7, #4]
9000547c:	681b      	ldr	r3, [r3, #0]
9000547e:	f003 0308 	and.w	r3, r3, #8
90005482:	2b00      	cmp	r3, #0
90005484:	d009      	beq.n	9000549a <HAL_RCC_ClockConfig+0x192>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
90005486:	4b12      	ldr	r3, [pc, #72]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
90005488:	689b      	ldr	r3, [r3, #8]
9000548a:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
9000548e:	687b      	ldr	r3, [r7, #4]
90005490:	691b      	ldr	r3, [r3, #16]
90005492:	00db      	lsls	r3, r3, #3
90005494:	490e      	ldr	r1, [pc, #56]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
90005496:	4313      	orrs	r3, r2
90005498:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
9000549a:	f000 f821 	bl	900054e0 <HAL_RCC_GetSysClockFreq>
9000549e:	4602      	mov	r2, r0
900054a0:	4b0b      	ldr	r3, [pc, #44]	; (900054d0 <HAL_RCC_ClockConfig+0x1c8>)
900054a2:	689b      	ldr	r3, [r3, #8]
900054a4:	091b      	lsrs	r3, r3, #4
900054a6:	f003 030f 	and.w	r3, r3, #15
900054aa:	490a      	ldr	r1, [pc, #40]	; (900054d4 <HAL_RCC_ClockConfig+0x1cc>)
900054ac:	5ccb      	ldrb	r3, [r1, r3]
900054ae:	fa22 f303 	lsr.w	r3, r2, r3
900054b2:	4a09      	ldr	r2, [pc, #36]	; (900054d8 <HAL_RCC_ClockConfig+0x1d0>)
900054b4:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
900054b6:	4b09      	ldr	r3, [pc, #36]	; (900054dc <HAL_RCC_ClockConfig+0x1d4>)
900054b8:	681b      	ldr	r3, [r3, #0]
900054ba:	4618      	mov	r0, r3
900054bc:	f7fe f952 	bl	90003764 <HAL_InitTick>

  return HAL_OK;
900054c0:	2300      	movs	r3, #0
}
900054c2:	4618      	mov	r0, r3
900054c4:	3710      	adds	r7, #16
900054c6:	46bd      	mov	sp, r7
900054c8:	bd80      	pop	{r7, pc}
900054ca:	bf00      	nop
900054cc:	40023c00 	.word	0x40023c00
900054d0:	40023800 	.word	0x40023800
900054d4:	90006f34 	.word	0x90006f34
900054d8:	20000000 	.word	0x20000000
900054dc:	20000038 	.word	0x20000038

900054e0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
900054e0:	b5b0      	push	{r4, r5, r7, lr}
900054e2:	b084      	sub	sp, #16
900054e4:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
900054e6:	2100      	movs	r1, #0
900054e8:	6079      	str	r1, [r7, #4]
900054ea:	2100      	movs	r1, #0
900054ec:	60f9      	str	r1, [r7, #12]
900054ee:	2100      	movs	r1, #0
900054f0:	6039      	str	r1, [r7, #0]
  uint32_t sysclockfreq = 0;
900054f2:	2100      	movs	r1, #0
900054f4:	60b9      	str	r1, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
900054f6:	4952      	ldr	r1, [pc, #328]	; (90005640 <HAL_RCC_GetSysClockFreq+0x160>)
900054f8:	6889      	ldr	r1, [r1, #8]
900054fa:	f001 010c 	and.w	r1, r1, #12
900054fe:	2908      	cmp	r1, #8
90005500:	d00d      	beq.n	9000551e <HAL_RCC_GetSysClockFreq+0x3e>
90005502:	2908      	cmp	r1, #8
90005504:	f200 8094 	bhi.w	90005630 <HAL_RCC_GetSysClockFreq+0x150>
90005508:	2900      	cmp	r1, #0
9000550a:	d002      	beq.n	90005512 <HAL_RCC_GetSysClockFreq+0x32>
9000550c:	2904      	cmp	r1, #4
9000550e:	d003      	beq.n	90005518 <HAL_RCC_GetSysClockFreq+0x38>
90005510:	e08e      	b.n	90005630 <HAL_RCC_GetSysClockFreq+0x150>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
90005512:	4b4c      	ldr	r3, [pc, #304]	; (90005644 <HAL_RCC_GetSysClockFreq+0x164>)
90005514:	60bb      	str	r3, [r7, #8]
      break;
90005516:	e08e      	b.n	90005636 <HAL_RCC_GetSysClockFreq+0x156>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
90005518:	4b4b      	ldr	r3, [pc, #300]	; (90005648 <HAL_RCC_GetSysClockFreq+0x168>)
9000551a:	60bb      	str	r3, [r7, #8]
      break;
9000551c:	e08b      	b.n	90005636 <HAL_RCC_GetSysClockFreq+0x156>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
9000551e:	4948      	ldr	r1, [pc, #288]	; (90005640 <HAL_RCC_GetSysClockFreq+0x160>)
90005520:	6849      	ldr	r1, [r1, #4]
90005522:	f001 013f 	and.w	r1, r1, #63	; 0x3f
90005526:	6079      	str	r1, [r7, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
90005528:	4945      	ldr	r1, [pc, #276]	; (90005640 <HAL_RCC_GetSysClockFreq+0x160>)
9000552a:	6849      	ldr	r1, [r1, #4]
9000552c:	f401 0180 	and.w	r1, r1, #4194304	; 0x400000
90005530:	2900      	cmp	r1, #0
90005532:	d024      	beq.n	9000557e <HAL_RCC_GetSysClockFreq+0x9e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
90005534:	4942      	ldr	r1, [pc, #264]	; (90005640 <HAL_RCC_GetSysClockFreq+0x160>)
90005536:	6849      	ldr	r1, [r1, #4]
90005538:	0989      	lsrs	r1, r1, #6
9000553a:	4608      	mov	r0, r1
9000553c:	f04f 0100 	mov.w	r1, #0
90005540:	f240 14ff 	movw	r4, #511	; 0x1ff
90005544:	f04f 0500 	mov.w	r5, #0
90005548:	ea00 0204 	and.w	r2, r0, r4
9000554c:	ea01 0305 	and.w	r3, r1, r5
90005550:	493d      	ldr	r1, [pc, #244]	; (90005648 <HAL_RCC_GetSysClockFreq+0x168>)
90005552:	fb01 f003 	mul.w	r0, r1, r3
90005556:	2100      	movs	r1, #0
90005558:	fb01 f102 	mul.w	r1, r1, r2
9000555c:	1844      	adds	r4, r0, r1
9000555e:	493a      	ldr	r1, [pc, #232]	; (90005648 <HAL_RCC_GetSysClockFreq+0x168>)
90005560:	fba2 0101 	umull	r0, r1, r2, r1
90005564:	1863      	adds	r3, r4, r1
90005566:	4619      	mov	r1, r3
90005568:	687b      	ldr	r3, [r7, #4]
9000556a:	461a      	mov	r2, r3
9000556c:	f04f 0300 	mov.w	r3, #0
90005570:	f7fa fe4a 	bl	90000208 <__aeabi_uldivmod>
90005574:	4602      	mov	r2, r0
90005576:	460b      	mov	r3, r1
90005578:	4613      	mov	r3, r2
9000557a:	60fb      	str	r3, [r7, #12]
9000557c:	e04a      	b.n	90005614 <HAL_RCC_GetSysClockFreq+0x134>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
9000557e:	4b30      	ldr	r3, [pc, #192]	; (90005640 <HAL_RCC_GetSysClockFreq+0x160>)
90005580:	685b      	ldr	r3, [r3, #4]
90005582:	099b      	lsrs	r3, r3, #6
90005584:	461a      	mov	r2, r3
90005586:	f04f 0300 	mov.w	r3, #0
9000558a:	f240 10ff 	movw	r0, #511	; 0x1ff
9000558e:	f04f 0100 	mov.w	r1, #0
90005592:	ea02 0400 	and.w	r4, r2, r0
90005596:	ea03 0501 	and.w	r5, r3, r1
9000559a:	4620      	mov	r0, r4
9000559c:	4629      	mov	r1, r5
9000559e:	f04f 0200 	mov.w	r2, #0
900055a2:	f04f 0300 	mov.w	r3, #0
900055a6:	014b      	lsls	r3, r1, #5
900055a8:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
900055ac:	0142      	lsls	r2, r0, #5
900055ae:	4610      	mov	r0, r2
900055b0:	4619      	mov	r1, r3
900055b2:	1b00      	subs	r0, r0, r4
900055b4:	eb61 0105 	sbc.w	r1, r1, r5
900055b8:	f04f 0200 	mov.w	r2, #0
900055bc:	f04f 0300 	mov.w	r3, #0
900055c0:	018b      	lsls	r3, r1, #6
900055c2:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
900055c6:	0182      	lsls	r2, r0, #6
900055c8:	1a12      	subs	r2, r2, r0
900055ca:	eb63 0301 	sbc.w	r3, r3, r1
900055ce:	f04f 0000 	mov.w	r0, #0
900055d2:	f04f 0100 	mov.w	r1, #0
900055d6:	00d9      	lsls	r1, r3, #3
900055d8:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
900055dc:	00d0      	lsls	r0, r2, #3
900055de:	4602      	mov	r2, r0
900055e0:	460b      	mov	r3, r1
900055e2:	1912      	adds	r2, r2, r4
900055e4:	eb45 0303 	adc.w	r3, r5, r3
900055e8:	f04f 0000 	mov.w	r0, #0
900055ec:	f04f 0100 	mov.w	r1, #0
900055f0:	0299      	lsls	r1, r3, #10
900055f2:	ea41 5192 	orr.w	r1, r1, r2, lsr #22
900055f6:	0290      	lsls	r0, r2, #10
900055f8:	4602      	mov	r2, r0
900055fa:	460b      	mov	r3, r1
900055fc:	4610      	mov	r0, r2
900055fe:	4619      	mov	r1, r3
90005600:	687b      	ldr	r3, [r7, #4]
90005602:	461a      	mov	r2, r3
90005604:	f04f 0300 	mov.w	r3, #0
90005608:	f7fa fdfe 	bl	90000208 <__aeabi_uldivmod>
9000560c:	4602      	mov	r2, r0
9000560e:	460b      	mov	r3, r1
90005610:	4613      	mov	r3, r2
90005612:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
90005614:	4b0a      	ldr	r3, [pc, #40]	; (90005640 <HAL_RCC_GetSysClockFreq+0x160>)
90005616:	685b      	ldr	r3, [r3, #4]
90005618:	0c1b      	lsrs	r3, r3, #16
9000561a:	f003 0303 	and.w	r3, r3, #3
9000561e:	3301      	adds	r3, #1
90005620:	005b      	lsls	r3, r3, #1
90005622:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco / pllp;
90005624:	68fa      	ldr	r2, [r7, #12]
90005626:	683b      	ldr	r3, [r7, #0]
90005628:	fbb2 f3f3 	udiv	r3, r2, r3
9000562c:	60bb      	str	r3, [r7, #8]
      break;
9000562e:	e002      	b.n	90005636 <HAL_RCC_GetSysClockFreq+0x156>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
90005630:	4b04      	ldr	r3, [pc, #16]	; (90005644 <HAL_RCC_GetSysClockFreq+0x164>)
90005632:	60bb      	str	r3, [r7, #8]
      break;
90005634:	bf00      	nop
    }
  }
  return sysclockfreq;
90005636:	68bb      	ldr	r3, [r7, #8]
}
90005638:	4618      	mov	r0, r3
9000563a:	3710      	adds	r7, #16
9000563c:	46bd      	mov	sp, r7
9000563e:	bdb0      	pop	{r4, r5, r7, pc}
90005640:	40023800 	.word	0x40023800
90005644:	00f42400 	.word	0x00f42400
90005648:	017d7840 	.word	0x017d7840

9000564c <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
9000564c:	b580      	push	{r7, lr}
9000564e:	b088      	sub	sp, #32
90005650:	af00      	add	r7, sp, #0
90005652:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
90005654:	2300      	movs	r3, #0
90005656:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg0 = 0;
90005658:	2300      	movs	r3, #0
9000565a:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg1 = 0;
9000565c:	2300      	movs	r3, #0
9000565e:	60fb      	str	r3, [r7, #12]
  uint32_t plli2sused = 0;
90005660:	2300      	movs	r3, #0
90005662:	61fb      	str	r3, [r7, #28]
  uint32_t pllsaiused = 0;
90005664:	2300      	movs	r3, #0
90005666:	61bb      	str	r3, [r7, #24]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
90005668:	687b      	ldr	r3, [r7, #4]
9000566a:	681b      	ldr	r3, [r3, #0]
9000566c:	f003 0301 	and.w	r3, r3, #1
90005670:	2b00      	cmp	r3, #0
90005672:	d012      	beq.n	9000569a <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
90005674:	4b69      	ldr	r3, [pc, #420]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
90005676:	689b      	ldr	r3, [r3, #8]
90005678:	4a68      	ldr	r2, [pc, #416]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
9000567a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
9000567e:	6093      	str	r3, [r2, #8]
90005680:	4b66      	ldr	r3, [pc, #408]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
90005682:	689a      	ldr	r2, [r3, #8]
90005684:	687b      	ldr	r3, [r7, #4]
90005686:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90005688:	4964      	ldr	r1, [pc, #400]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
9000568a:	4313      	orrs	r3, r2
9000568c:	608b      	str	r3, [r1, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
9000568e:	687b      	ldr	r3, [r7, #4]
90005690:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90005692:	2b00      	cmp	r3, #0
90005694:	d101      	bne.n	9000569a <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      plli2sused = 1;
90005696:	2301      	movs	r3, #1
90005698:	61fb      	str	r3, [r7, #28]
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
9000569a:	687b      	ldr	r3, [r7, #4]
9000569c:	681b      	ldr	r3, [r3, #0]
9000569e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
900056a2:	2b00      	cmp	r3, #0
900056a4:	d017      	beq.n	900056d6 <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
900056a6:	4b5d      	ldr	r3, [pc, #372]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900056a8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
900056ac:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
900056b0:	687b      	ldr	r3, [r7, #4]
900056b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
900056b4:	4959      	ldr	r1, [pc, #356]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900056b6:	4313      	orrs	r3, r2
900056b8:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
900056bc:	687b      	ldr	r3, [r7, #4]
900056be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
900056c0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
900056c4:	d101      	bne.n	900056ca <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      plli2sused = 1;
900056c6:	2301      	movs	r3, #1
900056c8:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
900056ca:	687b      	ldr	r3, [r7, #4]
900056cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
900056ce:	2b00      	cmp	r3, #0
900056d0:	d101      	bne.n	900056d6 <HAL_RCCEx_PeriphCLKConfig+0x8a>
    {
      pllsaiused = 1;
900056d2:	2301      	movs	r3, #1
900056d4:	61bb      	str	r3, [r7, #24]
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
900056d6:	687b      	ldr	r3, [r7, #4]
900056d8:	681b      	ldr	r3, [r3, #0]
900056da:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
900056de:	2b00      	cmp	r3, #0
900056e0:	d017      	beq.n	90005712 <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
900056e2:	4b4e      	ldr	r3, [pc, #312]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900056e4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
900056e8:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
900056ec:	687b      	ldr	r3, [r7, #4]
900056ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900056f0:	494a      	ldr	r1, [pc, #296]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900056f2:	4313      	orrs	r3, r2
900056f4:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
900056f8:	687b      	ldr	r3, [r7, #4]
900056fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900056fc:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90005700:	d101      	bne.n	90005706 <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      plli2sused = 1;
90005702:	2301      	movs	r3, #1
90005704:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
90005706:	687b      	ldr	r3, [r7, #4]
90005708:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000570a:	2b00      	cmp	r3, #0
9000570c:	d101      	bne.n	90005712 <HAL_RCCEx_PeriphCLKConfig+0xc6>
    {
      pllsaiused = 1;
9000570e:	2301      	movs	r3, #1
90005710:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
90005712:	687b      	ldr	r3, [r7, #4]
90005714:	681b      	ldr	r3, [r3, #0]
90005716:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
9000571a:	2b00      	cmp	r3, #0
9000571c:	d001      	beq.n	90005722 <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
      plli2sused = 1;
9000571e:	2301      	movs	r3, #1
90005720:	61fb      	str	r3, [r7, #28]
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
90005722:	687b      	ldr	r3, [r7, #4]
90005724:	681b      	ldr	r3, [r3, #0]
90005726:	f003 0320 	and.w	r3, r3, #32
9000572a:	2b00      	cmp	r3, #0
9000572c:	f000 808b 	beq.w	90005846 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
90005730:	4b3a      	ldr	r3, [pc, #232]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
90005732:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90005734:	4a39      	ldr	r2, [pc, #228]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
90005736:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
9000573a:	6413      	str	r3, [r2, #64]	; 0x40
9000573c:	4b37      	ldr	r3, [pc, #220]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
9000573e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90005740:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90005744:	60bb      	str	r3, [r7, #8]
90005746:	68bb      	ldr	r3, [r7, #8]

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
90005748:	4b35      	ldr	r3, [pc, #212]	; (90005820 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
9000574a:	681b      	ldr	r3, [r3, #0]
9000574c:	4a34      	ldr	r2, [pc, #208]	; (90005820 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
9000574e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90005752:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90005754:	f7fe f84a 	bl	900037ec <HAL_GetTick>
90005758:	6178      	str	r0, [r7, #20]

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
9000575a:	e008      	b.n	9000576e <HAL_RCCEx_PeriphCLKConfig+0x122>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
9000575c:	f7fe f846 	bl	900037ec <HAL_GetTick>
90005760:	4602      	mov	r2, r0
90005762:	697b      	ldr	r3, [r7, #20]
90005764:	1ad3      	subs	r3, r2, r3
90005766:	2b64      	cmp	r3, #100	; 0x64
90005768:	d901      	bls.n	9000576e <HAL_RCCEx_PeriphCLKConfig+0x122>
      {
        return HAL_TIMEOUT;
9000576a:	2303      	movs	r3, #3
9000576c:	e357      	b.n	90005e1e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
9000576e:	4b2c      	ldr	r3, [pc, #176]	; (90005820 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
90005770:	681b      	ldr	r3, [r3, #0]
90005772:	f403 7380 	and.w	r3, r3, #256	; 0x100
90005776:	2b00      	cmp	r3, #0
90005778:	d0f0      	beq.n	9000575c <HAL_RCCEx_PeriphCLKConfig+0x110>
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
9000577a:	4b28      	ldr	r3, [pc, #160]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
9000577c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000577e:	f403 7340 	and.w	r3, r3, #768	; 0x300
90005782:	613b      	str	r3, [r7, #16]

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
90005784:	693b      	ldr	r3, [r7, #16]
90005786:	2b00      	cmp	r3, #0
90005788:	d035      	beq.n	900057f6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
9000578a:	687b      	ldr	r3, [r7, #4]
9000578c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000578e:	f403 7340 	and.w	r3, r3, #768	; 0x300
90005792:	693a      	ldr	r2, [r7, #16]
90005794:	429a      	cmp	r2, r3
90005796:	d02e      	beq.n	900057f6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
90005798:	4b20      	ldr	r3, [pc, #128]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
9000579a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000579c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
900057a0:	613b      	str	r3, [r7, #16]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
900057a2:	4b1e      	ldr	r3, [pc, #120]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900057a6:	4a1d      	ldr	r2, [pc, #116]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057a8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900057ac:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
900057ae:	4b1b      	ldr	r3, [pc, #108]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900057b2:	4a1a      	ldr	r2, [pc, #104]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057b4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
900057b8:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
900057ba:	4a18      	ldr	r2, [pc, #96]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057bc:	693b      	ldr	r3, [r7, #16]
900057be:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
900057c0:	4b16      	ldr	r3, [pc, #88]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900057c4:	f003 0301 	and.w	r3, r3, #1
900057c8:	2b01      	cmp	r3, #1
900057ca:	d114      	bne.n	900057f6 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
900057cc:	f7fe f80e 	bl	900037ec <HAL_GetTick>
900057d0:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
900057d2:	e00a      	b.n	900057ea <HAL_RCCEx_PeriphCLKConfig+0x19e>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
900057d4:	f7fe f80a 	bl	900037ec <HAL_GetTick>
900057d8:	4602      	mov	r2, r0
900057da:	697b      	ldr	r3, [r7, #20]
900057dc:	1ad3      	subs	r3, r2, r3
900057de:	f241 3288 	movw	r2, #5000	; 0x1388
900057e2:	4293      	cmp	r3, r2
900057e4:	d901      	bls.n	900057ea <HAL_RCCEx_PeriphCLKConfig+0x19e>
          {
            return HAL_TIMEOUT;
900057e6:	2303      	movs	r3, #3
900057e8:	e319      	b.n	90005e1e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
900057ea:	4b0c      	ldr	r3, [pc, #48]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
900057ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900057ee:	f003 0302 	and.w	r3, r3, #2
900057f2:	2b00      	cmp	r3, #0
900057f4:	d0ee      	beq.n	900057d4 <HAL_RCCEx_PeriphCLKConfig+0x188>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
900057f6:	687b      	ldr	r3, [r7, #4]
900057f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900057fa:	f403 7340 	and.w	r3, r3, #768	; 0x300
900057fe:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
90005802:	d111      	bne.n	90005828 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
90005804:	4b05      	ldr	r3, [pc, #20]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
90005806:	689b      	ldr	r3, [r3, #8]
90005808:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
9000580c:	687b      	ldr	r3, [r7, #4]
9000580e:	6b19      	ldr	r1, [r3, #48]	; 0x30
90005810:	4b04      	ldr	r3, [pc, #16]	; (90005824 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
90005812:	400b      	ands	r3, r1
90005814:	4901      	ldr	r1, [pc, #4]	; (9000581c <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
90005816:	4313      	orrs	r3, r2
90005818:	608b      	str	r3, [r1, #8]
9000581a:	e00b      	b.n	90005834 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
9000581c:	40023800 	.word	0x40023800
90005820:	40007000 	.word	0x40007000
90005824:	0ffffcff 	.word	0x0ffffcff
90005828:	4bb1      	ldr	r3, [pc, #708]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000582a:	689b      	ldr	r3, [r3, #8]
9000582c:	4ab0      	ldr	r2, [pc, #704]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000582e:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
90005832:	6093      	str	r3, [r2, #8]
90005834:	4bae      	ldr	r3, [pc, #696]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005836:	6f1a      	ldr	r2, [r3, #112]	; 0x70
90005838:	687b      	ldr	r3, [r7, #4]
9000583a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000583c:	f3c3 030b 	ubfx	r3, r3, #0, #12
90005840:	49ab      	ldr	r1, [pc, #684]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005842:	4313      	orrs	r3, r2
90005844:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
90005846:	687b      	ldr	r3, [r7, #4]
90005848:	681b      	ldr	r3, [r3, #0]
9000584a:	f003 0310 	and.w	r3, r3, #16
9000584e:	2b00      	cmp	r3, #0
90005850:	d010      	beq.n	90005874 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
90005852:	4ba7      	ldr	r3, [pc, #668]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005854:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005858:	4aa5      	ldr	r2, [pc, #660]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000585a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
9000585e:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
90005862:	4ba3      	ldr	r3, [pc, #652]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005864:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
90005868:	687b      	ldr	r3, [r7, #4]
9000586a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000586c:	49a0      	ldr	r1, [pc, #640]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000586e:	4313      	orrs	r3, r2
90005870:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
90005874:	687b      	ldr	r3, [r7, #4]
90005876:	681b      	ldr	r3, [r3, #0]
90005878:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
9000587c:	2b00      	cmp	r3, #0
9000587e:	d00a      	beq.n	90005896 <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
90005880:	4b9b      	ldr	r3, [pc, #620]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005882:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005886:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
9000588a:	687b      	ldr	r3, [r7, #4]
9000588c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000588e:	4998      	ldr	r1, [pc, #608]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005890:	4313      	orrs	r3, r2
90005892:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
90005896:	687b      	ldr	r3, [r7, #4]
90005898:	681b      	ldr	r3, [r3, #0]
9000589a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
9000589e:	2b00      	cmp	r3, #0
900058a0:	d00a      	beq.n	900058b8 <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
900058a2:	4b93      	ldr	r3, [pc, #588]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900058a4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
900058a8:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
900058ac:	687b      	ldr	r3, [r7, #4]
900058ae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
900058b0:	498f      	ldr	r1, [pc, #572]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900058b2:	4313      	orrs	r3, r2
900058b4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
900058b8:	687b      	ldr	r3, [r7, #4]
900058ba:	681b      	ldr	r3, [r3, #0]
900058bc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
900058c0:	2b00      	cmp	r3, #0
900058c2:	d00a      	beq.n	900058da <HAL_RCCEx_PeriphCLKConfig+0x28e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
900058c4:	4b8a      	ldr	r3, [pc, #552]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900058c6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
900058ca:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
900058ce:	687b      	ldr	r3, [r7, #4]
900058d0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
900058d2:	4987      	ldr	r1, [pc, #540]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900058d4:	4313      	orrs	r3, r2
900058d6:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
900058da:	687b      	ldr	r3, [r7, #4]
900058dc:	681b      	ldr	r3, [r3, #0]
900058de:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
900058e2:	2b00      	cmp	r3, #0
900058e4:	d00a      	beq.n	900058fc <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
900058e6:	4b82      	ldr	r3, [pc, #520]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900058e8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
900058ec:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
900058f0:	687b      	ldr	r3, [r7, #4]
900058f2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900058f4:	497e      	ldr	r1, [pc, #504]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900058f6:	4313      	orrs	r3, r2
900058f8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
900058fc:	687b      	ldr	r3, [r7, #4]
900058fe:	681b      	ldr	r3, [r3, #0]
90005900:	f003 0340 	and.w	r3, r3, #64	; 0x40
90005904:	2b00      	cmp	r3, #0
90005906:	d00a      	beq.n	9000591e <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
90005908:	4b79      	ldr	r3, [pc, #484]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000590a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
9000590e:	f023 0203 	bic.w	r2, r3, #3
90005912:	687b      	ldr	r3, [r7, #4]
90005914:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90005916:	4976      	ldr	r1, [pc, #472]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005918:	4313      	orrs	r3, r2
9000591a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
9000591e:	687b      	ldr	r3, [r7, #4]
90005920:	681b      	ldr	r3, [r3, #0]
90005922:	f003 0380 	and.w	r3, r3, #128	; 0x80
90005926:	2b00      	cmp	r3, #0
90005928:	d00a      	beq.n	90005940 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
9000592a:	4b71      	ldr	r3, [pc, #452]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000592c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005930:	f023 020c 	bic.w	r2, r3, #12
90005934:	687b      	ldr	r3, [r7, #4]
90005936:	6c9b      	ldr	r3, [r3, #72]	; 0x48
90005938:	496d      	ldr	r1, [pc, #436]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000593a:	4313      	orrs	r3, r2
9000593c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
90005940:	687b      	ldr	r3, [r7, #4]
90005942:	681b      	ldr	r3, [r3, #0]
90005944:	f403 7380 	and.w	r3, r3, #256	; 0x100
90005948:	2b00      	cmp	r3, #0
9000594a:	d00a      	beq.n	90005962 <HAL_RCCEx_PeriphCLKConfig+0x316>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
9000594c:	4b68      	ldr	r3, [pc, #416]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000594e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005952:	f023 0230 	bic.w	r2, r3, #48	; 0x30
90005956:	687b      	ldr	r3, [r7, #4]
90005958:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000595a:	4965      	ldr	r1, [pc, #404]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000595c:	4313      	orrs	r3, r2
9000595e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
90005962:	687b      	ldr	r3, [r7, #4]
90005964:	681b      	ldr	r3, [r3, #0]
90005966:	f403 7300 	and.w	r3, r3, #512	; 0x200
9000596a:	2b00      	cmp	r3, #0
9000596c:	d00a      	beq.n	90005984 <HAL_RCCEx_PeriphCLKConfig+0x338>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
9000596e:	4b60      	ldr	r3, [pc, #384]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005970:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005974:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
90005978:	687b      	ldr	r3, [r7, #4]
9000597a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9000597c:	495c      	ldr	r1, [pc, #368]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
9000597e:	4313      	orrs	r3, r2
90005980:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
90005984:	687b      	ldr	r3, [r7, #4]
90005986:	681b      	ldr	r3, [r3, #0]
90005988:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9000598c:	2b00      	cmp	r3, #0
9000598e:	d00a      	beq.n	900059a6 <HAL_RCCEx_PeriphCLKConfig+0x35a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
90005990:	4b57      	ldr	r3, [pc, #348]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005992:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005996:	f423 7240 	bic.w	r2, r3, #768	; 0x300
9000599a:	687b      	ldr	r3, [r7, #4]
9000599c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000599e:	4954      	ldr	r1, [pc, #336]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900059a0:	4313      	orrs	r3, r2
900059a2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
900059a6:	687b      	ldr	r3, [r7, #4]
900059a8:	681b      	ldr	r3, [r3, #0]
900059aa:	f403 6300 	and.w	r3, r3, #2048	; 0x800
900059ae:	2b00      	cmp	r3, #0
900059b0:	d00a      	beq.n	900059c8 <HAL_RCCEx_PeriphCLKConfig+0x37c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
900059b2:	4b4f      	ldr	r3, [pc, #316]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900059b4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
900059b8:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
900059bc:	687b      	ldr	r3, [r7, #4]
900059be:	6d9b      	ldr	r3, [r3, #88]	; 0x58
900059c0:	494b      	ldr	r1, [pc, #300]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900059c2:	4313      	orrs	r3, r2
900059c4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
900059c8:	687b      	ldr	r3, [r7, #4]
900059ca:	681b      	ldr	r3, [r3, #0]
900059cc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
900059d0:	2b00      	cmp	r3, #0
900059d2:	d00a      	beq.n	900059ea <HAL_RCCEx_PeriphCLKConfig+0x39e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
900059d4:	4b46      	ldr	r3, [pc, #280]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900059d6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
900059da:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
900059de:	687b      	ldr	r3, [r7, #4]
900059e0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
900059e2:	4943      	ldr	r1, [pc, #268]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900059e4:	4313      	orrs	r3, r2
900059e6:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
900059ea:	687b      	ldr	r3, [r7, #4]
900059ec:	681b      	ldr	r3, [r3, #0]
900059ee:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
900059f2:	2b00      	cmp	r3, #0
900059f4:	d00a      	beq.n	90005a0c <HAL_RCCEx_PeriphCLKConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
900059f6:	4b3e      	ldr	r3, [pc, #248]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
900059f8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
900059fc:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
90005a00:	687b      	ldr	r3, [r7, #4]
90005a02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
90005a04:	493a      	ldr	r1, [pc, #232]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a06:	4313      	orrs	r3, r2
90005a08:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
90005a0c:	687b      	ldr	r3, [r7, #4]
90005a0e:	681b      	ldr	r3, [r3, #0]
90005a10:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90005a14:	2b00      	cmp	r3, #0
90005a16:	d00a      	beq.n	90005a2e <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
90005a18:	4b35      	ldr	r3, [pc, #212]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a1a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005a1e:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
90005a22:	687b      	ldr	r3, [r7, #4]
90005a24:	6f9b      	ldr	r3, [r3, #120]	; 0x78
90005a26:	4932      	ldr	r1, [pc, #200]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a28:	4313      	orrs	r3, r2
90005a2a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
90005a2e:	687b      	ldr	r3, [r7, #4]
90005a30:	681b      	ldr	r3, [r3, #0]
90005a32:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
90005a36:	2b00      	cmp	r3, #0
90005a38:	d011      	beq.n	90005a5e <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
90005a3a:	4b2d      	ldr	r3, [pc, #180]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a3c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005a40:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
90005a44:	687b      	ldr	r3, [r7, #4]
90005a46:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90005a48:	4929      	ldr	r1, [pc, #164]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a4a:	4313      	orrs	r3, r2
90005a4c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
90005a50:	687b      	ldr	r3, [r7, #4]
90005a52:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90005a54:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90005a58:	d101      	bne.n	90005a5e <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      pllsaiused = 1;
90005a5a:	2301      	movs	r3, #1
90005a5c:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
90005a5e:	687b      	ldr	r3, [r7, #4]
90005a60:	681b      	ldr	r3, [r3, #0]
90005a62:	f003 0308 	and.w	r3, r3, #8
90005a66:	2b00      	cmp	r3, #0
90005a68:	d001      	beq.n	90005a6e <HAL_RCCEx_PeriphCLKConfig+0x422>
  {
    pllsaiused = 1;
90005a6a:	2301      	movs	r3, #1
90005a6c:	61bb      	str	r3, [r7, #24]
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
90005a6e:	687b      	ldr	r3, [r7, #4]
90005a70:	681b      	ldr	r3, [r3, #0]
90005a72:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
90005a76:	2b00      	cmp	r3, #0
90005a78:	d00a      	beq.n	90005a90 <HAL_RCCEx_PeriphCLKConfig+0x444>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
90005a7a:	4b1d      	ldr	r3, [pc, #116]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a7c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005a80:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
90005a84:	687b      	ldr	r3, [r7, #4]
90005a86:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90005a88:	4919      	ldr	r1, [pc, #100]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a8a:	4313      	orrs	r3, r2
90005a8c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
90005a90:	687b      	ldr	r3, [r7, #4]
90005a92:	681b      	ldr	r3, [r3, #0]
90005a94:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
90005a98:	2b00      	cmp	r3, #0
90005a9a:	d00b      	beq.n	90005ab4 <HAL_RCCEx_PeriphCLKConfig+0x468>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
90005a9c:	4b14      	ldr	r3, [pc, #80]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005a9e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005aa2:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
90005aa6:	687b      	ldr	r3, [r7, #4]
90005aa8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90005aac:	4910      	ldr	r1, [pc, #64]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005aae:	4313      	orrs	r3, r2
90005ab0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
90005ab4:	69fb      	ldr	r3, [r7, #28]
90005ab6:	2b01      	cmp	r3, #1
90005ab8:	d006      	beq.n	90005ac8 <HAL_RCCEx_PeriphCLKConfig+0x47c>
90005aba:	687b      	ldr	r3, [r7, #4]
90005abc:	681b      	ldr	r3, [r3, #0]
90005abe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90005ac2:	2b00      	cmp	r3, #0
90005ac4:	f000 80d9 	beq.w	90005c7a <HAL_RCCEx_PeriphCLKConfig+0x62e>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
90005ac8:	4b09      	ldr	r3, [pc, #36]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005aca:	681b      	ldr	r3, [r3, #0]
90005acc:	4a08      	ldr	r2, [pc, #32]	; (90005af0 <HAL_RCCEx_PeriphCLKConfig+0x4a4>)
90005ace:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
90005ad2:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90005ad4:	f7fd fe8a 	bl	900037ec <HAL_GetTick>
90005ad8:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
90005ada:	e00b      	b.n	90005af4 <HAL_RCCEx_PeriphCLKConfig+0x4a8>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
90005adc:	f7fd fe86 	bl	900037ec <HAL_GetTick>
90005ae0:	4602      	mov	r2, r0
90005ae2:	697b      	ldr	r3, [r7, #20]
90005ae4:	1ad3      	subs	r3, r2, r3
90005ae6:	2b64      	cmp	r3, #100	; 0x64
90005ae8:	d904      	bls.n	90005af4 <HAL_RCCEx_PeriphCLKConfig+0x4a8>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
90005aea:	2303      	movs	r3, #3
90005aec:	e197      	b.n	90005e1e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
90005aee:	bf00      	nop
90005af0:	40023800 	.word	0x40023800
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
90005af4:	4b6c      	ldr	r3, [pc, #432]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005af6:	681b      	ldr	r3, [r3, #0]
90005af8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90005afc:	2b00      	cmp	r3, #0
90005afe:	d1ed      	bne.n	90005adc <HAL_RCCEx_PeriphCLKConfig+0x490>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
90005b00:	687b      	ldr	r3, [r7, #4]
90005b02:	681b      	ldr	r3, [r3, #0]
90005b04:	f003 0301 	and.w	r3, r3, #1
90005b08:	2b00      	cmp	r3, #0
90005b0a:	d021      	beq.n	90005b50 <HAL_RCCEx_PeriphCLKConfig+0x504>
90005b0c:	687b      	ldr	r3, [r7, #4]
90005b0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90005b10:	2b00      	cmp	r3, #0
90005b12:	d11d      	bne.n	90005b50 <HAL_RCCEx_PeriphCLKConfig+0x504>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
90005b14:	4b64      	ldr	r3, [pc, #400]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005b16:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005b1a:	0c1b      	lsrs	r3, r3, #16
90005b1c:	f003 0303 	and.w	r3, r3, #3
90005b20:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
90005b22:	4b61      	ldr	r3, [pc, #388]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005b24:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005b28:	0e1b      	lsrs	r3, r3, #24
90005b2a:	f003 030f 	and.w	r3, r3, #15
90005b2e:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
90005b30:	687b      	ldr	r3, [r7, #4]
90005b32:	685b      	ldr	r3, [r3, #4]
90005b34:	019a      	lsls	r2, r3, #6
90005b36:	693b      	ldr	r3, [r7, #16]
90005b38:	041b      	lsls	r3, r3, #16
90005b3a:	431a      	orrs	r2, r3
90005b3c:	68fb      	ldr	r3, [r7, #12]
90005b3e:	061b      	lsls	r3, r3, #24
90005b40:	431a      	orrs	r2, r3
90005b42:	687b      	ldr	r3, [r7, #4]
90005b44:	689b      	ldr	r3, [r3, #8]
90005b46:	071b      	lsls	r3, r3, #28
90005b48:	4957      	ldr	r1, [pc, #348]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005b4a:	4313      	orrs	r3, r2
90005b4c:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
90005b50:	687b      	ldr	r3, [r7, #4]
90005b52:	681b      	ldr	r3, [r3, #0]
90005b54:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
90005b58:	2b00      	cmp	r3, #0
90005b5a:	d004      	beq.n	90005b66 <HAL_RCCEx_PeriphCLKConfig+0x51a>
90005b5c:	687b      	ldr	r3, [r7, #4]
90005b5e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
90005b60:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
90005b64:	d00a      	beq.n	90005b7c <HAL_RCCEx_PeriphCLKConfig+0x530>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
90005b66:	687b      	ldr	r3, [r7, #4]
90005b68:	681b      	ldr	r3, [r3, #0]
90005b6a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
90005b6e:	2b00      	cmp	r3, #0
90005b70:	d02e      	beq.n	90005bd0 <HAL_RCCEx_PeriphCLKConfig+0x584>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
90005b72:	687b      	ldr	r3, [r7, #4]
90005b74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90005b76:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90005b7a:	d129      	bne.n	90005bd0 <HAL_RCCEx_PeriphCLKConfig+0x584>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
90005b7c:	4b4a      	ldr	r3, [pc, #296]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005b7e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005b82:	0c1b      	lsrs	r3, r3, #16
90005b84:	f003 0303 	and.w	r3, r3, #3
90005b88:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
90005b8a:	4b47      	ldr	r3, [pc, #284]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005b8c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005b90:	0f1b      	lsrs	r3, r3, #28
90005b92:	f003 0307 	and.w	r3, r3, #7
90005b96:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
90005b98:	687b      	ldr	r3, [r7, #4]
90005b9a:	685b      	ldr	r3, [r3, #4]
90005b9c:	019a      	lsls	r2, r3, #6
90005b9e:	693b      	ldr	r3, [r7, #16]
90005ba0:	041b      	lsls	r3, r3, #16
90005ba2:	431a      	orrs	r2, r3
90005ba4:	687b      	ldr	r3, [r7, #4]
90005ba6:	68db      	ldr	r3, [r3, #12]
90005ba8:	061b      	lsls	r3, r3, #24
90005baa:	431a      	orrs	r2, r3
90005bac:	68fb      	ldr	r3, [r7, #12]
90005bae:	071b      	lsls	r3, r3, #28
90005bb0:	493d      	ldr	r1, [pc, #244]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005bb2:	4313      	orrs	r3, r2
90005bb4:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
90005bb8:	4b3b      	ldr	r3, [pc, #236]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005bba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005bbe:	f023 021f 	bic.w	r2, r3, #31
90005bc2:	687b      	ldr	r3, [r7, #4]
90005bc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90005bc6:	3b01      	subs	r3, #1
90005bc8:	4937      	ldr	r1, [pc, #220]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005bca:	4313      	orrs	r3, r2
90005bcc:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
90005bd0:	687b      	ldr	r3, [r7, #4]
90005bd2:	681b      	ldr	r3, [r3, #0]
90005bd4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
90005bd8:	2b00      	cmp	r3, #0
90005bda:	d01d      	beq.n	90005c18 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
90005bdc:	4b32      	ldr	r3, [pc, #200]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005bde:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005be2:	0e1b      	lsrs	r3, r3, #24
90005be4:	f003 030f 	and.w	r3, r3, #15
90005be8:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
90005bea:	4b2f      	ldr	r3, [pc, #188]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005bec:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005bf0:	0f1b      	lsrs	r3, r3, #28
90005bf2:	f003 0307 	and.w	r3, r3, #7
90005bf6:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
90005bf8:	687b      	ldr	r3, [r7, #4]
90005bfa:	685b      	ldr	r3, [r3, #4]
90005bfc:	019a      	lsls	r2, r3, #6
90005bfe:	687b      	ldr	r3, [r7, #4]
90005c00:	691b      	ldr	r3, [r3, #16]
90005c02:	041b      	lsls	r3, r3, #16
90005c04:	431a      	orrs	r2, r3
90005c06:	693b      	ldr	r3, [r7, #16]
90005c08:	061b      	lsls	r3, r3, #24
90005c0a:	431a      	orrs	r2, r3
90005c0c:	68fb      	ldr	r3, [r7, #12]
90005c0e:	071b      	lsls	r3, r3, #28
90005c10:	4925      	ldr	r1, [pc, #148]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c12:	4313      	orrs	r3, r2
90005c14:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
90005c18:	687b      	ldr	r3, [r7, #4]
90005c1a:	681b      	ldr	r3, [r3, #0]
90005c1c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90005c20:	2b00      	cmp	r3, #0
90005c22:	d011      	beq.n	90005c48 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
90005c24:	687b      	ldr	r3, [r7, #4]
90005c26:	685b      	ldr	r3, [r3, #4]
90005c28:	019a      	lsls	r2, r3, #6
90005c2a:	687b      	ldr	r3, [r7, #4]
90005c2c:	691b      	ldr	r3, [r3, #16]
90005c2e:	041b      	lsls	r3, r3, #16
90005c30:	431a      	orrs	r2, r3
90005c32:	687b      	ldr	r3, [r7, #4]
90005c34:	68db      	ldr	r3, [r3, #12]
90005c36:	061b      	lsls	r3, r3, #24
90005c38:	431a      	orrs	r2, r3
90005c3a:	687b      	ldr	r3, [r7, #4]
90005c3c:	689b      	ldr	r3, [r3, #8]
90005c3e:	071b      	lsls	r3, r3, #28
90005c40:	4919      	ldr	r1, [pc, #100]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c42:	4313      	orrs	r3, r2
90005c44:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
90005c48:	4b17      	ldr	r3, [pc, #92]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c4a:	681b      	ldr	r3, [r3, #0]
90005c4c:	4a16      	ldr	r2, [pc, #88]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c4e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
90005c52:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90005c54:	f7fd fdca 	bl	900037ec <HAL_GetTick>
90005c58:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
90005c5a:	e008      	b.n	90005c6e <HAL_RCCEx_PeriphCLKConfig+0x622>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
90005c5c:	f7fd fdc6 	bl	900037ec <HAL_GetTick>
90005c60:	4602      	mov	r2, r0
90005c62:	697b      	ldr	r3, [r7, #20]
90005c64:	1ad3      	subs	r3, r2, r3
90005c66:	2b64      	cmp	r3, #100	; 0x64
90005c68:	d901      	bls.n	90005c6e <HAL_RCCEx_PeriphCLKConfig+0x622>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
90005c6a:	2303      	movs	r3, #3
90005c6c:	e0d7      	b.n	90005e1e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
90005c6e:	4b0e      	ldr	r3, [pc, #56]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c70:	681b      	ldr	r3, [r3, #0]
90005c72:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90005c76:	2b00      	cmp	r3, #0
90005c78:	d0f0      	beq.n	90005c5c <HAL_RCCEx_PeriphCLKConfig+0x610>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
90005c7a:	69bb      	ldr	r3, [r7, #24]
90005c7c:	2b01      	cmp	r3, #1
90005c7e:	f040 80cd 	bne.w	90005e1c <HAL_RCCEx_PeriphCLKConfig+0x7d0>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
90005c82:	4b09      	ldr	r3, [pc, #36]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c84:	681b      	ldr	r3, [r3, #0]
90005c86:	4a08      	ldr	r2, [pc, #32]	; (90005ca8 <HAL_RCCEx_PeriphCLKConfig+0x65c>)
90005c88:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
90005c8c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90005c8e:	f7fd fdad 	bl	900037ec <HAL_GetTick>
90005c92:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
90005c94:	e00a      	b.n	90005cac <HAL_RCCEx_PeriphCLKConfig+0x660>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
90005c96:	f7fd fda9 	bl	900037ec <HAL_GetTick>
90005c9a:	4602      	mov	r2, r0
90005c9c:	697b      	ldr	r3, [r7, #20]
90005c9e:	1ad3      	subs	r3, r2, r3
90005ca0:	2b64      	cmp	r3, #100	; 0x64
90005ca2:	d903      	bls.n	90005cac <HAL_RCCEx_PeriphCLKConfig+0x660>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
90005ca4:	2303      	movs	r3, #3
90005ca6:	e0ba      	b.n	90005e1e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
90005ca8:	40023800 	.word	0x40023800
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
90005cac:	4b5e      	ldr	r3, [pc, #376]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005cae:	681b      	ldr	r3, [r3, #0]
90005cb0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90005cb4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90005cb8:	d0ed      	beq.n	90005c96 <HAL_RCCEx_PeriphCLKConfig+0x64a>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
90005cba:	687b      	ldr	r3, [r7, #4]
90005cbc:	681b      	ldr	r3, [r3, #0]
90005cbe:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
90005cc2:	2b00      	cmp	r3, #0
90005cc4:	d003      	beq.n	90005cce <HAL_RCCEx_PeriphCLKConfig+0x682>
90005cc6:	687b      	ldr	r3, [r7, #4]
90005cc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
90005cca:	2b00      	cmp	r3, #0
90005ccc:	d009      	beq.n	90005ce2 <HAL_RCCEx_PeriphCLKConfig+0x696>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
90005cce:	687b      	ldr	r3, [r7, #4]
90005cd0:	681b      	ldr	r3, [r3, #0]
90005cd2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
90005cd6:	2b00      	cmp	r3, #0
90005cd8:	d02e      	beq.n	90005d38 <HAL_RCCEx_PeriphCLKConfig+0x6ec>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
90005cda:	687b      	ldr	r3, [r7, #4]
90005cdc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90005cde:	2b00      	cmp	r3, #0
90005ce0:	d12a      	bne.n	90005d38 <HAL_RCCEx_PeriphCLKConfig+0x6ec>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
90005ce2:	4b51      	ldr	r3, [pc, #324]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005ce4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005ce8:	0c1b      	lsrs	r3, r3, #16
90005cea:	f003 0303 	and.w	r3, r3, #3
90005cee:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
90005cf0:	4b4d      	ldr	r3, [pc, #308]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005cf2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005cf6:	0f1b      	lsrs	r3, r3, #28
90005cf8:	f003 0307 	and.w	r3, r3, #7
90005cfc:	60fb      	str	r3, [r7, #12]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
90005cfe:	687b      	ldr	r3, [r7, #4]
90005d00:	695b      	ldr	r3, [r3, #20]
90005d02:	019a      	lsls	r2, r3, #6
90005d04:	693b      	ldr	r3, [r7, #16]
90005d06:	041b      	lsls	r3, r3, #16
90005d08:	431a      	orrs	r2, r3
90005d0a:	687b      	ldr	r3, [r7, #4]
90005d0c:	699b      	ldr	r3, [r3, #24]
90005d0e:	061b      	lsls	r3, r3, #24
90005d10:	431a      	orrs	r2, r3
90005d12:	68fb      	ldr	r3, [r7, #12]
90005d14:	071b      	lsls	r3, r3, #28
90005d16:	4944      	ldr	r1, [pc, #272]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d18:	4313      	orrs	r3, r2
90005d1a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
90005d1e:	4b42      	ldr	r3, [pc, #264]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d20:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005d24:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
90005d28:	687b      	ldr	r3, [r7, #4]
90005d2a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90005d2c:	3b01      	subs	r3, #1
90005d2e:	021b      	lsls	r3, r3, #8
90005d30:	493d      	ldr	r1, [pc, #244]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d32:	4313      	orrs	r3, r2
90005d34:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
90005d38:	687b      	ldr	r3, [r7, #4]
90005d3a:	681b      	ldr	r3, [r3, #0]
90005d3c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
90005d40:	2b00      	cmp	r3, #0
90005d42:	d022      	beq.n	90005d8a <HAL_RCCEx_PeriphCLKConfig+0x73e>
90005d44:	687b      	ldr	r3, [r7, #4]
90005d46:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90005d48:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90005d4c:	d11d      	bne.n	90005d8a <HAL_RCCEx_PeriphCLKConfig+0x73e>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
90005d4e:	4b36      	ldr	r3, [pc, #216]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d50:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005d54:	0e1b      	lsrs	r3, r3, #24
90005d56:	f003 030f 	and.w	r3, r3, #15
90005d5a:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
90005d5c:	4b32      	ldr	r3, [pc, #200]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d5e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005d62:	0f1b      	lsrs	r3, r3, #28
90005d64:	f003 0307 	and.w	r3, r3, #7
90005d68:	60fb      	str	r3, [r7, #12]

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
90005d6a:	687b      	ldr	r3, [r7, #4]
90005d6c:	695b      	ldr	r3, [r3, #20]
90005d6e:	019a      	lsls	r2, r3, #6
90005d70:	687b      	ldr	r3, [r7, #4]
90005d72:	6a1b      	ldr	r3, [r3, #32]
90005d74:	041b      	lsls	r3, r3, #16
90005d76:	431a      	orrs	r2, r3
90005d78:	693b      	ldr	r3, [r7, #16]
90005d7a:	061b      	lsls	r3, r3, #24
90005d7c:	431a      	orrs	r2, r3
90005d7e:	68fb      	ldr	r3, [r7, #12]
90005d80:	071b      	lsls	r3, r3, #28
90005d82:	4929      	ldr	r1, [pc, #164]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d84:	4313      	orrs	r3, r2
90005d86:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
90005d8a:	687b      	ldr	r3, [r7, #4]
90005d8c:	681b      	ldr	r3, [r3, #0]
90005d8e:	f003 0308 	and.w	r3, r3, #8
90005d92:	2b00      	cmp	r3, #0
90005d94:	d028      	beq.n	90005de8 <HAL_RCCEx_PeriphCLKConfig+0x79c>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
90005d96:	4b24      	ldr	r3, [pc, #144]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005d98:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005d9c:	0e1b      	lsrs	r3, r3, #24
90005d9e:	f003 030f 	and.w	r3, r3, #15
90005da2:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
90005da4:	4b20      	ldr	r3, [pc, #128]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005da6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005daa:	0c1b      	lsrs	r3, r3, #16
90005dac:	f003 0303 	and.w	r3, r3, #3
90005db0:	60fb      	str	r3, [r7, #12]

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
90005db2:	687b      	ldr	r3, [r7, #4]
90005db4:	695b      	ldr	r3, [r3, #20]
90005db6:	019a      	lsls	r2, r3, #6
90005db8:	68fb      	ldr	r3, [r7, #12]
90005dba:	041b      	lsls	r3, r3, #16
90005dbc:	431a      	orrs	r2, r3
90005dbe:	693b      	ldr	r3, [r7, #16]
90005dc0:	061b      	lsls	r3, r3, #24
90005dc2:	431a      	orrs	r2, r3
90005dc4:	687b      	ldr	r3, [r7, #4]
90005dc6:	69db      	ldr	r3, [r3, #28]
90005dc8:	071b      	lsls	r3, r3, #28
90005dca:	4917      	ldr	r1, [pc, #92]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005dcc:	4313      	orrs	r3, r2
90005dce:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
90005dd2:	4b15      	ldr	r3, [pc, #84]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005dd4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005dd8:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
90005ddc:	687b      	ldr	r3, [r7, #4]
90005dde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90005de0:	4911      	ldr	r1, [pc, #68]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005de2:	4313      	orrs	r3, r2
90005de4:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
90005de8:	4b0f      	ldr	r3, [pc, #60]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005dea:	681b      	ldr	r3, [r3, #0]
90005dec:	4a0e      	ldr	r2, [pc, #56]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005dee:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90005df2:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
90005df4:	f7fd fcfa 	bl	900037ec <HAL_GetTick>
90005df8:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
90005dfa:	e008      	b.n	90005e0e <HAL_RCCEx_PeriphCLKConfig+0x7c2>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
90005dfc:	f7fd fcf6 	bl	900037ec <HAL_GetTick>
90005e00:	4602      	mov	r2, r0
90005e02:	697b      	ldr	r3, [r7, #20]
90005e04:	1ad3      	subs	r3, r2, r3
90005e06:	2b64      	cmp	r3, #100	; 0x64
90005e08:	d901      	bls.n	90005e0e <HAL_RCCEx_PeriphCLKConfig+0x7c2>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
90005e0a:	2303      	movs	r3, #3
90005e0c:	e007      	b.n	90005e1e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
90005e0e:	4b06      	ldr	r3, [pc, #24]	; (90005e28 <HAL_RCCEx_PeriphCLKConfig+0x7dc>)
90005e10:	681b      	ldr	r3, [r3, #0]
90005e12:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90005e16:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90005e1a:	d1ef      	bne.n	90005dfc <HAL_RCCEx_PeriphCLKConfig+0x7b0>
      }
    }
  }
  return HAL_OK;
90005e1c:	2300      	movs	r3, #0
}
90005e1e:	4618      	mov	r0, r3
90005e20:	3720      	adds	r7, #32
90005e22:	46bd      	mov	sp, r7
90005e24:	bd80      	pop	{r7, pc}
90005e26:	bf00      	nop
90005e28:	40023800 	.word	0x40023800

90005e2c <HAL_RCCEx_GetPeriphCLKConfig>:
  *         RCC configuration registers.
  * @param  PeriphClkInit pointer to the configured RCC_PeriphCLKInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
90005e2c:	b480      	push	{r7}
90005e2e:	b085      	sub	sp, #20
90005e30:	af00      	add	r7, sp, #0
90005e32:	6078      	str	r0, [r7, #4]
  uint32_t tempreg = 0;
90005e34:	2300      	movs	r3, #0
90005e36:	60fb      	str	r3, [r7, #12]
                                        RCC_PERIPHCLK_USART6   | RCC_PERIPHCLK_UART7    |\
                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
                                        RCC_PERIPHCLK_CLK48    | RCC_PERIPHCLK_SDMMC2   |\
                                        RCC_PERIPHCLK_DFSDM1   | RCC_PERIPHCLK_DFSDM1_AUDIO;
#else
  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S      | RCC_PERIPHCLK_LPTIM1   |\
90005e38:	687b      	ldr	r3, [r7, #4]
90005e3a:	4a80      	ldr	r2, [pc, #512]	; (9000603c <HAL_RCCEx_GetPeriphCLKConfig+0x210>)
90005e3c:	601a      	str	r2, [r3, #0]
                                        RCC_PERIPHCLK_UART8    | RCC_PERIPHCLK_SDMMC1   |\
                                        RCC_PERIPHCLK_CLK48;
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /* Get the PLLI2S Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
90005e3e:	4b80      	ldr	r3, [pc, #512]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005e40:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005e44:	099b      	lsrs	r3, r3, #6
90005e46:	f3c3 0208 	ubfx	r2, r3, #0, #9
90005e4a:	687b      	ldr	r3, [r7, #4]
90005e4c:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLLI2S.PLLI2SP = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
90005e4e:	4b7c      	ldr	r3, [pc, #496]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005e50:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005e54:	0c1b      	lsrs	r3, r3, #16
90005e56:	f003 0203 	and.w	r2, r3, #3
90005e5a:	687b      	ldr	r3, [r7, #4]
90005e5c:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
90005e5e:	4b78      	ldr	r3, [pc, #480]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005e60:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005e64:	0e1b      	lsrs	r3, r3, #24
90005e66:	f003 020f 	and.w	r2, r3, #15
90005e6a:	687b      	ldr	r3, [r7, #4]
90005e6c:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
90005e6e:	4b74      	ldr	r3, [pc, #464]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005e70:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90005e74:	0f1b      	lsrs	r3, r3, #28
90005e76:	f003 0207 	and.w	r2, r3, #7
90005e7a:	687b      	ldr	r3, [r7, #4]
90005e7c:	609a      	str	r2, [r3, #8]

  /* Get the PLLSAI Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);
90005e7e:	4b70      	ldr	r3, [pc, #448]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005e80:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005e84:	099b      	lsrs	r3, r3, #6
90005e86:	f3c3 0208 	ubfx	r2, r3, #0, #9
90005e8a:	687b      	ldr	r3, [r7, #4]
90005e8c:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLLSAI.PLLSAIP = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
90005e8e:	4b6c      	ldr	r3, [pc, #432]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005e90:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005e94:	0c1b      	lsrs	r3, r3, #16
90005e96:	f003 0203 	and.w	r2, r3, #3
90005e9a:	687b      	ldr	r3, [r7, #4]
90005e9c:	621a      	str	r2, [r3, #32]
  PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
90005e9e:	4b68      	ldr	r3, [pc, #416]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005ea0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005ea4:	0e1b      	lsrs	r3, r3, #24
90005ea6:	f003 020f 	and.w	r2, r3, #15
90005eaa:	687b      	ldr	r3, [r7, #4]
90005eac:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
90005eae:	4b64      	ldr	r3, [pc, #400]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005eb0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90005eb4:	0f1b      	lsrs	r3, r3, #28
90005eb6:	f003 0207 	and.w	r2, r3, #7
90005eba:	687b      	ldr	r3, [r7, #4]
90005ebc:	61da      	str	r2, [r3, #28]

  /* Get the PLLSAI/PLLI2S division factors -------------------------------------------*/
  PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) >> RCC_DCKCFGR1_PLLI2SDIVQ_Pos);
90005ebe:	4b60      	ldr	r3, [pc, #384]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005ec0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005ec4:	f003 021f 	and.w	r2, r3, #31
90005ec8:	687b      	ldr	r3, [r7, #4]
90005eca:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> RCC_DCKCFGR1_PLLSAIDIVQ_Pos);
90005ecc:	4b5c      	ldr	r3, [pc, #368]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005ece:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005ed2:	0a1b      	lsrs	r3, r3, #8
90005ed4:	f003 021f 	and.w	r2, r3, #31
90005ed8:	687b      	ldr	r3, [r7, #4]
90005eda:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLLSAIDivR = (uint32_t)((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVR) >> RCC_DCKCFGR1_PLLSAIDIVR_Pos);
90005edc:	4b58      	ldr	r3, [pc, #352]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005ede:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005ee2:	0c1b      	lsrs	r3, r3, #16
90005ee4:	f003 0203 	and.w	r2, r3, #3
90005ee8:	687b      	ldr	r3, [r7, #4]
90005eea:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Get the SAI1 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection = __HAL_RCC_GET_SAI1_SOURCE();
90005eec:	4b54      	ldr	r3, [pc, #336]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005eee:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005ef2:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
90005ef6:	687b      	ldr	r3, [r7, #4]
90005ef8:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the SAI2 clock configuration ----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection = __HAL_RCC_GET_SAI2_SOURCE();
90005efa:	4b51      	ldr	r3, [pc, #324]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005efc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90005f00:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
90005f04:	687b      	ldr	r3, [r7, #4]
90005f06:	641a      	str	r2, [r3, #64]	; 0x40

  /* Get the I2S clock configuration ------------------------------------------*/
  PeriphClkInit->I2sClockSelection = __HAL_RCC_GET_I2SCLKSOURCE();
90005f08:	4b4d      	ldr	r3, [pc, #308]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f0a:	689b      	ldr	r3, [r3, #8]
90005f0c:	f403 0200 	and.w	r2, r3, #8388608	; 0x800000
90005f10:	687b      	ldr	r3, [r7, #4]
90005f12:	635a      	str	r2, [r3, #52]	; 0x34

  /* Get the I2C1 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
90005f14:	4b4a      	ldr	r3, [pc, #296]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f16:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f1a:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
90005f1e:	687b      	ldr	r3, [r7, #4]
90005f20:	665a      	str	r2, [r3, #100]	; 0x64

  /* Get the I2C2 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection = __HAL_RCC_GET_I2C2_SOURCE();
90005f22:	4b47      	ldr	r3, [pc, #284]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f24:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f28:	f403 2240 	and.w	r2, r3, #786432	; 0xc0000
90005f2c:	687b      	ldr	r3, [r7, #4]
90005f2e:	669a      	str	r2, [r3, #104]	; 0x68

  /* Get the I2C3 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection = __HAL_RCC_GET_I2C3_SOURCE();
90005f30:	4b43      	ldr	r3, [pc, #268]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f32:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f36:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
90005f3a:	687b      	ldr	r3, [r7, #4]
90005f3c:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Get the I2C4 clock configuration ------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection = __HAL_RCC_GET_I2C4_SOURCE();
90005f3e:	4b40      	ldr	r3, [pc, #256]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f40:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f44:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
90005f48:	687b      	ldr	r3, [r7, #4]
90005f4a:	671a      	str	r2, [r3, #112]	; 0x70

  /* Get the USART1 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
90005f4c:	4b3c      	ldr	r3, [pc, #240]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f4e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f52:	f003 0203 	and.w	r2, r3, #3
90005f56:	687b      	ldr	r3, [r7, #4]
90005f58:	645a      	str	r2, [r3, #68]	; 0x44

  /* Get the USART2 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
90005f5a:	4b39      	ldr	r3, [pc, #228]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f5c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f60:	f003 020c 	and.w	r2, r3, #12
90005f64:	687b      	ldr	r3, [r7, #4]
90005f66:	649a      	str	r2, [r3, #72]	; 0x48

  /* Get the USART3 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
90005f68:	4b35      	ldr	r3, [pc, #212]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f6a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f6e:	f003 0230 	and.w	r2, r3, #48	; 0x30
90005f72:	687b      	ldr	r3, [r7, #4]
90005f74:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Get the UART4 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection = __HAL_RCC_GET_UART4_SOURCE();
90005f76:	4b32      	ldr	r3, [pc, #200]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f78:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f7c:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
90005f80:	687b      	ldr	r3, [r7, #4]
90005f82:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the UART5 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection = __HAL_RCC_GET_UART5_SOURCE();
90005f84:	4b2e      	ldr	r3, [pc, #184]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f86:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f8a:	f403 7240 	and.w	r2, r3, #768	; 0x300
90005f8e:	687b      	ldr	r3, [r7, #4]
90005f90:	655a      	str	r2, [r3, #84]	; 0x54

  /* Get the USART6 clock configuration ------------------------------------------*/
  PeriphClkInit->Usart6ClockSelection = __HAL_RCC_GET_USART6_SOURCE();
90005f92:	4b2b      	ldr	r3, [pc, #172]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005f94:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005f98:	f403 6240 	and.w	r2, r3, #3072	; 0xc00
90005f9c:	687b      	ldr	r3, [r7, #4]
90005f9e:	659a      	str	r2, [r3, #88]	; 0x58

  /* Get the UART7 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart7ClockSelection = __HAL_RCC_GET_UART7_SOURCE();
90005fa0:	4b27      	ldr	r3, [pc, #156]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005fa2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005fa6:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
90005faa:	687b      	ldr	r3, [r7, #4]
90005fac:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Get the UART8 clock configuration ------------------------------------------*/
  PeriphClkInit->Uart8ClockSelection = __HAL_RCC_GET_UART8_SOURCE();
90005fae:	4b24      	ldr	r3, [pc, #144]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005fb0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005fb4:	f403 4240 	and.w	r2, r3, #49152	; 0xc000
90005fb8:	687b      	ldr	r3, [r7, #4]
90005fba:	661a      	str	r2, [r3, #96]	; 0x60

  /* Get the LPTIM1 clock configuration ------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection = __HAL_RCC_GET_LPTIM1_SOURCE();
90005fbc:	4b20      	ldr	r3, [pc, #128]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005fbe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005fc2:	f003 7240 	and.w	r2, r3, #50331648	; 0x3000000
90005fc6:	687b      	ldr	r3, [r7, #4]
90005fc8:	675a      	str	r2, [r3, #116]	; 0x74

  /* Get the CEC clock configuration -----------------------------------------------*/
  PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
90005fca:	4b1d      	ldr	r3, [pc, #116]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005fcc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005fd0:	f003 6280 	and.w	r2, r3, #67108864	; 0x4000000
90005fd4:	687b      	ldr	r3, [r7, #4]
90005fd6:	679a      	str	r2, [r3, #120]	; 0x78

  /* Get the CK48 clock configuration -----------------------------------------------*/
  PeriphClkInit->Clk48ClockSelection = __HAL_RCC_GET_CLK48_SOURCE();
90005fd8:	4b19      	ldr	r3, [pc, #100]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005fda:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005fde:	f003 6200 	and.w	r2, r3, #134217728	; 0x8000000
90005fe2:	687b      	ldr	r3, [r7, #4]
90005fe4:	67da      	str	r2, [r3, #124]	; 0x7c

  /* Get the SDMMC1 clock configuration -----------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection = __HAL_RCC_GET_SDMMC1_SOURCE();
90005fe6:	4b16      	ldr	r3, [pc, #88]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005fe8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90005fec:	f003 5280 	and.w	r2, r3, #268435456	; 0x10000000
90005ff0:	687b      	ldr	r3, [r7, #4]
90005ff2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  /* Get the DFSDM AUDIO clock configuration -----------------------------------------------*/
  PeriphClkInit->Dfsdm1AudioClockSelection = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /* Get the RTC Clock configuration -----------------------------------------------*/
  tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
90005ff6:	4b12      	ldr	r3, [pc, #72]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90005ff8:	689b      	ldr	r3, [r3, #8]
90005ffa:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
90005ffe:	60fb      	str	r3, [r7, #12]
  PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
90006000:	4b0f      	ldr	r3, [pc, #60]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90006002:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90006004:	f403 7240 	and.w	r2, r3, #768	; 0x300
90006008:	68fb      	ldr	r3, [r7, #12]
9000600a:	431a      	orrs	r2, r3
9000600c:	687b      	ldr	r3, [r7, #4]
9000600e:	631a      	str	r2, [r3, #48]	; 0x30

  /* Get the TIM Prescaler configuration --------------------------------------------*/
  if ((RCC->DCKCFGR1 & RCC_DCKCFGR1_TIMPRE) == RESET)
90006010:	4b0b      	ldr	r3, [pc, #44]	; (90006040 <HAL_RCCEx_GetPeriphCLKConfig+0x214>)
90006012:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90006016:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
9000601a:	2b00      	cmp	r3, #0
9000601c:	d103      	bne.n	90006026 <HAL_RCCEx_GetPeriphCLKConfig+0x1fa>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
9000601e:	687b      	ldr	r3, [r7, #4]
90006020:	2200      	movs	r2, #0
90006022:	639a      	str	r2, [r3, #56]	; 0x38
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
90006024:	e003      	b.n	9000602e <HAL_RCCEx_GetPeriphCLKConfig+0x202>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
90006026:	687b      	ldr	r3, [r7, #4]
90006028:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
9000602c:	639a      	str	r2, [r3, #56]	; 0x38
}
9000602e:	bf00      	nop
90006030:	3714      	adds	r7, #20
90006032:	46bd      	mov	sp, r7
90006034:	f85d 7b04 	ldr.w	r7, [sp], #4
90006038:	4770      	bx	lr
9000603a:	bf00      	nop
9000603c:	00fffff1 	.word	0x00fffff1
90006040:	40023800 	.word	0x40023800

90006044 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock
  *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
90006044:	b480      	push	{r7}
90006046:	b087      	sub	sp, #28
90006048:	af00      	add	r7, sp, #0
9000604a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
9000604c:	2300      	movs	r3, #0
9000604e:	60fb      	str	r3, [r7, #12]
  /* This variable is used to store the SAI clock frequency (value in Hz) */
  uint32_t frequency = 0;
90006050:	2300      	movs	r3, #0
90006052:	617b      	str	r3, [r7, #20]
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
90006054:	2300      	movs	r3, #0
90006056:	613b      	str	r3, [r7, #16]
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;
90006058:	2300      	movs	r3, #0
9000605a:	60bb      	str	r3, [r7, #8]

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
9000605c:	687b      	ldr	r3, [r7, #4]
9000605e:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
90006062:	f040 808c 	bne.w	9000617e <HAL_RCCEx_GetPeriphCLKFreq+0x13a>
  {
    saiclocksource = RCC->DCKCFGR1;
90006066:	4b95      	ldr	r3, [pc, #596]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006068:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
9000606c:	60bb      	str	r3, [r7, #8]
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
9000606e:	68bb      	ldr	r3, [r7, #8]
90006070:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
90006074:	60bb      	str	r3, [r7, #8]
    switch (saiclocksource)
90006076:	68bb      	ldr	r3, [r7, #8]
90006078:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
9000607c:	d07c      	beq.n	90006178 <HAL_RCCEx_GetPeriphCLKFreq+0x134>
9000607e:	68bb      	ldr	r3, [r7, #8]
90006080:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90006084:	d87d      	bhi.n	90006182 <HAL_RCCEx_GetPeriphCLKFreq+0x13e>
90006086:	68bb      	ldr	r3, [r7, #8]
90006088:	2b00      	cmp	r3, #0
9000608a:	d004      	beq.n	90006096 <HAL_RCCEx_GetPeriphCLKFreq+0x52>
9000608c:	68bb      	ldr	r3, [r7, #8]
9000608e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
90006092:	d039      	beq.n	90006108 <HAL_RCCEx_GetPeriphCLKFreq+0xc4>
        break;
      }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
    default :
      {
        break;
90006094:	e075      	b.n	90006182 <HAL_RCCEx_GetPeriphCLKFreq+0x13e>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
90006096:	4b89      	ldr	r3, [pc, #548]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006098:	685b      	ldr	r3, [r3, #4]
9000609a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
9000609e:	2b00      	cmp	r3, #0
900060a0:	d108      	bne.n	900060b4 <HAL_RCCEx_GetPeriphCLKFreq+0x70>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
900060a2:	4b86      	ldr	r3, [pc, #536]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900060a4:	685b      	ldr	r3, [r3, #4]
900060a6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
900060aa:	4a85      	ldr	r2, [pc, #532]	; (900062c0 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
900060ac:	fbb2 f3f3 	udiv	r3, r2, r3
900060b0:	613b      	str	r3, [r7, #16]
900060b2:	e007      	b.n	900060c4 <HAL_RCCEx_GetPeriphCLKFreq+0x80>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
900060b4:	4b81      	ldr	r3, [pc, #516]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900060b6:	685b      	ldr	r3, [r3, #4]
900060b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
900060bc:	4a81      	ldr	r2, [pc, #516]	; (900062c4 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
900060be:	fbb2 f3f3 	udiv	r3, r2, r3
900060c2:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
900060c4:	4b7d      	ldr	r3, [pc, #500]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900060c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
900060ca:	0e1b      	lsrs	r3, r3, #24
900060cc:	f003 030f 	and.w	r3, r3, #15
900060d0:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
900060d2:	4b7a      	ldr	r3, [pc, #488]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900060d4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
900060d8:	099b      	lsrs	r3, r3, #6
900060da:	f3c3 0308 	ubfx	r3, r3, #0, #9
900060de:	693a      	ldr	r2, [r7, #16]
900060e0:	fb02 f203 	mul.w	r2, r2, r3
900060e4:	68fb      	ldr	r3, [r7, #12]
900060e6:	fbb2 f3f3 	udiv	r3, r2, r3
900060ea:	617b      	str	r3, [r7, #20]
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
900060ec:	4b73      	ldr	r3, [pc, #460]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900060ee:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
900060f2:	0a1b      	lsrs	r3, r3, #8
900060f4:	f003 031f 	and.w	r3, r3, #31
900060f8:	3301      	adds	r3, #1
900060fa:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
900060fc:	697a      	ldr	r2, [r7, #20]
900060fe:	68fb      	ldr	r3, [r7, #12]
90006100:	fbb2 f3f3 	udiv	r3, r2, r3
90006104:	617b      	str	r3, [r7, #20]
        break;
90006106:	e03d      	b.n	90006184 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
90006108:	4b6c      	ldr	r3, [pc, #432]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
9000610a:	685b      	ldr	r3, [r3, #4]
9000610c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90006110:	2b00      	cmp	r3, #0
90006112:	d108      	bne.n	90006126 <HAL_RCCEx_GetPeriphCLKFreq+0xe2>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
90006114:	4b69      	ldr	r3, [pc, #420]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006116:	685b      	ldr	r3, [r3, #4]
90006118:	f003 033f 	and.w	r3, r3, #63	; 0x3f
9000611c:	4a68      	ldr	r2, [pc, #416]	; (900062c0 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
9000611e:	fbb2 f3f3 	udiv	r3, r2, r3
90006122:	613b      	str	r3, [r7, #16]
90006124:	e007      	b.n	90006136 <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
90006126:	4b65      	ldr	r3, [pc, #404]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006128:	685b      	ldr	r3, [r3, #4]
9000612a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
9000612e:	4a65      	ldr	r2, [pc, #404]	; (900062c4 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
90006130:	fbb2 f3f3 	udiv	r3, r2, r3
90006134:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
90006136:	4b61      	ldr	r3, [pc, #388]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006138:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
9000613c:	0e1b      	lsrs	r3, r3, #24
9000613e:	f003 030f 	and.w	r3, r3, #15
90006142:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
90006144:	4b5d      	ldr	r3, [pc, #372]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006146:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
9000614a:	099b      	lsrs	r3, r3, #6
9000614c:	f3c3 0308 	ubfx	r3, r3, #0, #9
90006150:	693a      	ldr	r2, [r7, #16]
90006152:	fb02 f203 	mul.w	r2, r2, r3
90006156:	68fb      	ldr	r3, [r7, #12]
90006158:	fbb2 f3f3 	udiv	r3, r2, r3
9000615c:	617b      	str	r3, [r7, #20]
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
9000615e:	4b57      	ldr	r3, [pc, #348]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006160:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90006164:	f003 031f 	and.w	r3, r3, #31
90006168:	3301      	adds	r3, #1
9000616a:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
9000616c:	697a      	ldr	r2, [r7, #20]
9000616e:	68fb      	ldr	r3, [r7, #12]
90006170:	fbb2 f3f3 	udiv	r3, r2, r3
90006174:	617b      	str	r3, [r7, #20]
        break;
90006176:	e005      	b.n	90006184 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
        frequency = EXTERNAL_CLOCK_VALUE;
90006178:	4b53      	ldr	r3, [pc, #332]	; (900062c8 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
9000617a:	617b      	str	r3, [r7, #20]
        break;
9000617c:	e002      	b.n	90006184 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
      }
    }
  }
9000617e:	bf00      	nop
90006180:	e000      	b.n	90006184 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
        break;
90006182:	bf00      	nop

  if (PeriphClk == RCC_PERIPHCLK_SAI2)
90006184:	687b      	ldr	r3, [r7, #4]
90006186:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
9000618a:	f040 808c 	bne.w	900062a6 <HAL_RCCEx_GetPeriphCLKFreq+0x262>
  {
    saiclocksource = RCC->DCKCFGR1;
9000618e:	4b4b      	ldr	r3, [pc, #300]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006190:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90006194:	60bb      	str	r3, [r7, #8]
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
90006196:	68bb      	ldr	r3, [r7, #8]
90006198:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
9000619c:	60bb      	str	r3, [r7, #8]
    switch (saiclocksource)
9000619e:	68bb      	ldr	r3, [r7, #8]
900061a0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
900061a4:	d07c      	beq.n	900062a0 <HAL_RCCEx_GetPeriphCLKFreq+0x25c>
900061a6:	68bb      	ldr	r3, [r7, #8]
900061a8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
900061ac:	d87d      	bhi.n	900062aa <HAL_RCCEx_GetPeriphCLKFreq+0x266>
900061ae:	68bb      	ldr	r3, [r7, #8]
900061b0:	2b00      	cmp	r3, #0
900061b2:	d004      	beq.n	900061be <HAL_RCCEx_GetPeriphCLKFreq+0x17a>
900061b4:	68bb      	ldr	r3, [r7, #8]
900061b6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
900061ba:	d039      	beq.n	90006230 <HAL_RCCEx_GetPeriphCLKFreq+0x1ec>
        break;
      }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
    default :
      {
        break;
900061bc:	e075      	b.n	900062aa <HAL_RCCEx_GetPeriphCLKFreq+0x266>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
900061be:	4b3f      	ldr	r3, [pc, #252]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900061c0:	685b      	ldr	r3, [r3, #4]
900061c2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
900061c6:	2b00      	cmp	r3, #0
900061c8:	d108      	bne.n	900061dc <HAL_RCCEx_GetPeriphCLKFreq+0x198>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
900061ca:	4b3c      	ldr	r3, [pc, #240]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900061cc:	685b      	ldr	r3, [r3, #4]
900061ce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
900061d2:	4a3b      	ldr	r2, [pc, #236]	; (900062c0 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
900061d4:	fbb2 f3f3 	udiv	r3, r2, r3
900061d8:	613b      	str	r3, [r7, #16]
900061da:	e007      	b.n	900061ec <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
900061dc:	4b37      	ldr	r3, [pc, #220]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900061de:	685b      	ldr	r3, [r3, #4]
900061e0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
900061e4:	4a37      	ldr	r2, [pc, #220]	; (900062c4 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
900061e6:	fbb2 f3f3 	udiv	r3, r2, r3
900061ea:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
900061ec:	4b33      	ldr	r3, [pc, #204]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900061ee:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
900061f2:	0e1b      	lsrs	r3, r3, #24
900061f4:	f003 030f 	and.w	r3, r3, #15
900061f8:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
900061fa:	4b30      	ldr	r3, [pc, #192]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
900061fc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90006200:	099b      	lsrs	r3, r3, #6
90006202:	f3c3 0308 	ubfx	r3, r3, #0, #9
90006206:	693a      	ldr	r2, [r7, #16]
90006208:	fb02 f203 	mul.w	r2, r2, r3
9000620c:	68fb      	ldr	r3, [r7, #12]
9000620e:	fbb2 f3f3 	udiv	r3, r2, r3
90006212:	617b      	str	r3, [r7, #20]
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
90006214:	4b29      	ldr	r3, [pc, #164]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006216:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
9000621a:	0a1b      	lsrs	r3, r3, #8
9000621c:	f003 031f 	and.w	r3, r3, #31
90006220:	3301      	adds	r3, #1
90006222:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
90006224:	697a      	ldr	r2, [r7, #20]
90006226:	68fb      	ldr	r3, [r7, #12]
90006228:	fbb2 f3f3 	udiv	r3, r2, r3
9000622c:	617b      	str	r3, [r7, #20]
        break;
9000622e:	e03d      	b.n	900062ac <HAL_RCCEx_GetPeriphCLKFreq+0x268>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
90006230:	4b22      	ldr	r3, [pc, #136]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006232:	685b      	ldr	r3, [r3, #4]
90006234:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90006238:	2b00      	cmp	r3, #0
9000623a:	d108      	bne.n	9000624e <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
9000623c:	4b1f      	ldr	r3, [pc, #124]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
9000623e:	685b      	ldr	r3, [r3, #4]
90006240:	f003 033f 	and.w	r3, r3, #63	; 0x3f
90006244:	4a1e      	ldr	r2, [pc, #120]	; (900062c0 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
90006246:	fbb2 f3f3 	udiv	r3, r2, r3
9000624a:	613b      	str	r3, [r7, #16]
9000624c:	e007      	b.n	9000625e <HAL_RCCEx_GetPeriphCLKFreq+0x21a>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
9000624e:	4b1b      	ldr	r3, [pc, #108]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006250:	685b      	ldr	r3, [r3, #4]
90006252:	f003 033f 	and.w	r3, r3, #63	; 0x3f
90006256:	4a1b      	ldr	r2, [pc, #108]	; (900062c4 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
90006258:	fbb2 f3f3 	udiv	r3, r2, r3
9000625c:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
9000625e:	4b17      	ldr	r3, [pc, #92]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006260:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90006264:	0e1b      	lsrs	r3, r3, #24
90006266:	f003 030f 	and.w	r3, r3, #15
9000626a:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
9000626c:	4b13      	ldr	r3, [pc, #76]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
9000626e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90006272:	099b      	lsrs	r3, r3, #6
90006274:	f3c3 0308 	ubfx	r3, r3, #0, #9
90006278:	693a      	ldr	r2, [r7, #16]
9000627a:	fb02 f203 	mul.w	r2, r2, r3
9000627e:	68fb      	ldr	r3, [r7, #12]
90006280:	fbb2 f3f3 	udiv	r3, r2, r3
90006284:	617b      	str	r3, [r7, #20]
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
90006286:	4b0d      	ldr	r3, [pc, #52]	; (900062bc <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
90006288:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
9000628c:	f003 031f 	and.w	r3, r3, #31
90006290:	3301      	adds	r3, #1
90006292:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
90006294:	697a      	ldr	r2, [r7, #20]
90006296:	68fb      	ldr	r3, [r7, #12]
90006298:	fbb2 f3f3 	udiv	r3, r2, r3
9000629c:	617b      	str	r3, [r7, #20]
        break;
9000629e:	e005      	b.n	900062ac <HAL_RCCEx_GetPeriphCLKFreq+0x268>
        frequency = EXTERNAL_CLOCK_VALUE;
900062a0:	4b09      	ldr	r3, [pc, #36]	; (900062c8 <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
900062a2:	617b      	str	r3, [r7, #20]
        break;
900062a4:	e002      	b.n	900062ac <HAL_RCCEx_GetPeriphCLKFreq+0x268>
      }
    }
  }
900062a6:	bf00      	nop
900062a8:	e000      	b.n	900062ac <HAL_RCCEx_GetPeriphCLKFreq+0x268>
        break;
900062aa:	bf00      	nop

  return frequency;
900062ac:	697b      	ldr	r3, [r7, #20]
}
900062ae:	4618      	mov	r0, r3
900062b0:	371c      	adds	r7, #28
900062b2:	46bd      	mov	sp, r7
900062b4:	f85d 7b04 	ldr.w	r7, [sp], #4
900062b8:	4770      	bx	lr
900062ba:	bf00      	nop
900062bc:	40023800 	.word	0x40023800
900062c0:	00f42400 	.word	0x00f42400
900062c4:	017d7840 	.word	0x017d7840
900062c8:	00bb8000 	.word	0x00bb8000

900062cc <HAL_SAI_Init>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
{
900062cc:	b580      	push	{r7, lr}
900062ce:	b088      	sub	sp, #32
900062d0:	af00      	add	r7, sp, #0
900062d2:	6078      	str	r0, [r7, #4]
  uint32_t tmpregisterGCR = 0;
900062d4:	2300      	movs	r3, #0
900062d6:	61fb      	str	r3, [r7, #28]
  uint32_t ckstr_bits = 0;
900062d8:	2300      	movs	r3, #0
900062da:	61bb      	str	r3, [r7, #24]
  uint32_t syncen_bits = 0;
900062dc:	2300      	movs	r3, #0
900062de:	617b      	str	r3, [r7, #20]

  /* Check the SAI handle allocation */
  if (hsai == NULL)
900062e0:	687b      	ldr	r3, [r7, #4]
900062e2:	2b00      	cmp	r3, #0
900062e4:	d101      	bne.n	900062ea <HAL_SAI_Init+0x1e>
  {
    return HAL_ERROR;
900062e6:	2301      	movs	r3, #1
900062e8:	e156      	b.n	90006598 <HAL_SAI_Init+0x2cc>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  if (hsai->State == HAL_SAI_STATE_RESET)
900062ea:	687b      	ldr	r3, [r7, #4]
900062ec:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
900062f0:	b2db      	uxtb	r3, r3
900062f2:	2b00      	cmp	r3, #0
900062f4:	d106      	bne.n	90006304 <HAL_SAI_Init+0x38>
  {
    /* Allocate lock resource and initialize it */
    hsai->Lock = HAL_UNLOCKED;
900062f6:	687b      	ldr	r3, [r7, #4]
900062f8:	2200      	movs	r2, #0
900062fa:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
      hsai->MspInitCallback = HAL_SAI_MspInit;
    }
    hsai->MspInitCallback(hsai);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_SAI_MspInit(hsai);
900062fe:	6878      	ldr	r0, [r7, #4]
90006300:	f000 f997 	bl	90006632 <HAL_SAI_MspInit>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
  }

  hsai->State = HAL_SAI_STATE_BUSY;
90006304:	687b      	ldr	r3, [r7, #4]
90006306:	2202      	movs	r2, #2
90006308:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

  /* Disable the selected SAI peripheral */
  SAI_Disable(hsai);
9000630c:	6878      	ldr	r0, [r7, #4]
9000630e:	f000 fb27 	bl	90006960 <SAI_Disable>

  /* SAI Block Synchro Configuration -----------------------------------------*/
  /* This setting must be done with both audio block (A & B) disabled         */
  switch (hsai->Init.SynchroExt)
90006312:	687b      	ldr	r3, [r7, #4]
90006314:	68db      	ldr	r3, [r3, #12]
90006316:	2b02      	cmp	r3, #2
90006318:	d00c      	beq.n	90006334 <HAL_SAI_Init+0x68>
9000631a:	2b02      	cmp	r3, #2
9000631c:	d80d      	bhi.n	9000633a <HAL_SAI_Init+0x6e>
9000631e:	2b00      	cmp	r3, #0
90006320:	d002      	beq.n	90006328 <HAL_SAI_Init+0x5c>
90006322:	2b01      	cmp	r3, #1
90006324:	d003      	beq.n	9000632e <HAL_SAI_Init+0x62>
      break;
    case SAI_SYNCEXT_OUTBLOCKB_ENABLE :
      tmpregisterGCR = SAI_GCR_SYNCOUT_1;
      break;
    default:
      break;
90006326:	e008      	b.n	9000633a <HAL_SAI_Init+0x6e>
      tmpregisterGCR = 0;
90006328:	2300      	movs	r3, #0
9000632a:	61fb      	str	r3, [r7, #28]
      break;
9000632c:	e006      	b.n	9000633c <HAL_SAI_Init+0x70>
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
9000632e:	2310      	movs	r3, #16
90006330:	61fb      	str	r3, [r7, #28]
      break;
90006332:	e003      	b.n	9000633c <HAL_SAI_Init+0x70>
      tmpregisterGCR = SAI_GCR_SYNCOUT_1;
90006334:	2320      	movs	r3, #32
90006336:	61fb      	str	r3, [r7, #28]
      break;
90006338:	e000      	b.n	9000633c <HAL_SAI_Init+0x70>
      break;
9000633a:	bf00      	nop
  }

  switch (hsai->Init.Synchro)
9000633c:	687b      	ldr	r3, [r7, #4]
9000633e:	689b      	ldr	r3, [r3, #8]
90006340:	2b03      	cmp	r3, #3
90006342:	d81e      	bhi.n	90006382 <HAL_SAI_Init+0xb6>
90006344:	a201      	add	r2, pc, #4	; (adr r2, 9000634c <HAL_SAI_Init+0x80>)
90006346:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000634a:	bf00      	nop
9000634c:	9000635d 	.word	0x9000635d
90006350:	90006363 	.word	0x90006363
90006354:	9000636b 	.word	0x9000636b
90006358:	90006373 	.word	0x90006373
  {
    case SAI_ASYNCHRONOUS :
    {
      syncen_bits = 0;
9000635c:	2300      	movs	r3, #0
9000635e:	617b      	str	r3, [r7, #20]
    }
    break;
90006360:	e010      	b.n	90006384 <HAL_SAI_Init+0xb8>
    case SAI_SYNCHRONOUS :
    {
      syncen_bits = SAI_xCR1_SYNCEN_0;
90006362:	f44f 6380 	mov.w	r3, #1024	; 0x400
90006366:	617b      	str	r3, [r7, #20]
    }
    break;
90006368:	e00c      	b.n	90006384 <HAL_SAI_Init+0xb8>
    case SAI_SYNCHRONOUS_EXT_SAI1 :
    {
      syncen_bits = SAI_xCR1_SYNCEN_1;
9000636a:	f44f 6300 	mov.w	r3, #2048	; 0x800
9000636e:	617b      	str	r3, [r7, #20]
    }
    break;
90006370:	e008      	b.n	90006384 <HAL_SAI_Init+0xb8>
    case SAI_SYNCHRONOUS_EXT_SAI2 :
    {
      syncen_bits = SAI_xCR1_SYNCEN_1;
90006372:	f44f 6300 	mov.w	r3, #2048	; 0x800
90006376:	617b      	str	r3, [r7, #20]
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
90006378:	69fb      	ldr	r3, [r7, #28]
9000637a:	f043 0301 	orr.w	r3, r3, #1
9000637e:	61fb      	str	r3, [r7, #28]
    }
    break;
90006380:	e000      	b.n	90006384 <HAL_SAI_Init+0xb8>
    default:
      break;
90006382:	bf00      	nop
  }

  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
90006384:	687b      	ldr	r3, [r7, #4]
90006386:	681b      	ldr	r3, [r3, #0]
90006388:	4a85      	ldr	r2, [pc, #532]	; (900065a0 <HAL_SAI_Init+0x2d4>)
9000638a:	4293      	cmp	r3, r2
9000638c:	d004      	beq.n	90006398 <HAL_SAI_Init+0xcc>
9000638e:	687b      	ldr	r3, [r7, #4]
90006390:	681b      	ldr	r3, [r3, #0]
90006392:	4a84      	ldr	r2, [pc, #528]	; (900065a4 <HAL_SAI_Init+0x2d8>)
90006394:	4293      	cmp	r3, r2
90006396:	d103      	bne.n	900063a0 <HAL_SAI_Init+0xd4>
  {
    SAI1->GCR = tmpregisterGCR;
90006398:	4a83      	ldr	r2, [pc, #524]	; (900065a8 <HAL_SAI_Init+0x2dc>)
9000639a:	69fb      	ldr	r3, [r7, #28]
9000639c:	6013      	str	r3, [r2, #0]
9000639e:	e002      	b.n	900063a6 <HAL_SAI_Init+0xda>
  }
  else
  {
    SAI2->GCR = tmpregisterGCR;
900063a0:	4a82      	ldr	r2, [pc, #520]	; (900065ac <HAL_SAI_Init+0x2e0>)
900063a2:	69fb      	ldr	r3, [r7, #28]
900063a4:	6013      	str	r3, [r2, #0]
  }

  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
900063a6:	687b      	ldr	r3, [r7, #4]
900063a8:	69db      	ldr	r3, [r3, #28]
900063aa:	2b00      	cmp	r3, #0
900063ac:	d04c      	beq.n	90006448 <HAL_SAI_Init+0x17c>
  {
    uint32_t freq = 0;
900063ae:	2300      	movs	r3, #0
900063b0:	613b      	str	r3, [r7, #16]
    uint32_t tmpval;

    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
900063b2:	687b      	ldr	r3, [r7, #4]
900063b4:	681b      	ldr	r3, [r3, #0]
900063b6:	4a7a      	ldr	r2, [pc, #488]	; (900065a0 <HAL_SAI_Init+0x2d4>)
900063b8:	4293      	cmp	r3, r2
900063ba:	d004      	beq.n	900063c6 <HAL_SAI_Init+0xfa>
900063bc:	687b      	ldr	r3, [r7, #4]
900063be:	681b      	ldr	r3, [r3, #0]
900063c0:	4a78      	ldr	r2, [pc, #480]	; (900065a4 <HAL_SAI_Init+0x2d8>)
900063c2:	4293      	cmp	r3, r2
900063c4:	d104      	bne.n	900063d0 <HAL_SAI_Init+0x104>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
900063c6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
900063ca:	f7ff fe3b 	bl	90006044 <HAL_RCCEx_GetPeriphCLKFreq>
900063ce:	6138      	str	r0, [r7, #16]
    }
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
900063d0:	687b      	ldr	r3, [r7, #4]
900063d2:	681b      	ldr	r3, [r3, #0]
900063d4:	4a76      	ldr	r2, [pc, #472]	; (900065b0 <HAL_SAI_Init+0x2e4>)
900063d6:	4293      	cmp	r3, r2
900063d8:	d004      	beq.n	900063e4 <HAL_SAI_Init+0x118>
900063da:	687b      	ldr	r3, [r7, #4]
900063dc:	681b      	ldr	r3, [r3, #0]
900063de:	4a75      	ldr	r2, [pc, #468]	; (900065b4 <HAL_SAI_Init+0x2e8>)
900063e0:	4293      	cmp	r3, r2
900063e2:	d104      	bne.n	900063ee <HAL_SAI_Init+0x122>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
900063e4:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
900063e8:	f7ff fe2c 	bl	90006044 <HAL_RCCEx_GetPeriphCLKFreq>
900063ec:	6138      	str	r0, [r7, #16]
    /* Configure Master Clock using the following formula :
       MCLK_x = SAI_CK_x / (MCKDIV[3:0] * 2) with MCLK_x = 256 * FS
       FS = SAI_CK_x / (MCKDIV[3:0] * 2) * 256
       MCKDIV[3:0] = SAI_CK_x / FS * 512 */
    /* (freq x 10) to keep Significant digits */
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
900063ee:	693a      	ldr	r2, [r7, #16]
900063f0:	4613      	mov	r3, r2
900063f2:	009b      	lsls	r3, r3, #2
900063f4:	4413      	add	r3, r2
900063f6:	005b      	lsls	r3, r3, #1
900063f8:	461a      	mov	r2, r3
900063fa:	687b      	ldr	r3, [r7, #4]
900063fc:	69db      	ldr	r3, [r3, #28]
900063fe:	025b      	lsls	r3, r3, #9
90006400:	fbb2 f3f3 	udiv	r3, r2, r3
90006404:	60fb      	str	r3, [r7, #12]
    hsai->Init.Mckdiv = tmpval / 10;
90006406:	68fb      	ldr	r3, [r7, #12]
90006408:	4a6b      	ldr	r2, [pc, #428]	; (900065b8 <HAL_SAI_Init+0x2ec>)
9000640a:	fba2 2303 	umull	r2, r3, r2, r3
9000640e:	08da      	lsrs	r2, r3, #3
90006410:	687b      	ldr	r3, [r7, #4]
90006412:	621a      	str	r2, [r3, #32]

    /* Round result to the nearest integer */
    if ((tmpval % 10) > 8)
90006414:	68f9      	ldr	r1, [r7, #12]
90006416:	4b68      	ldr	r3, [pc, #416]	; (900065b8 <HAL_SAI_Init+0x2ec>)
90006418:	fba3 2301 	umull	r2, r3, r3, r1
9000641c:	08da      	lsrs	r2, r3, #3
9000641e:	4613      	mov	r3, r2
90006420:	009b      	lsls	r3, r3, #2
90006422:	4413      	add	r3, r2
90006424:	005b      	lsls	r3, r3, #1
90006426:	1aca      	subs	r2, r1, r3
90006428:	2a08      	cmp	r2, #8
9000642a:	d904      	bls.n	90006436 <HAL_SAI_Init+0x16a>
    {
      hsai->Init.Mckdiv += 1;
9000642c:	687b      	ldr	r3, [r7, #4]
9000642e:	6a1b      	ldr	r3, [r3, #32]
90006430:	1c5a      	adds	r2, r3, #1
90006432:	687b      	ldr	r3, [r7, #4]
90006434:	621a      	str	r2, [r3, #32]
    }

    /* For SPDIF protocol, SAI shall provide a bit clock twice faster the symbol-rate */
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
90006436:	687b      	ldr	r3, [r7, #4]
90006438:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000643a:	2b04      	cmp	r3, #4
9000643c:	d104      	bne.n	90006448 <HAL_SAI_Init+0x17c>
    {
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
9000643e:	687b      	ldr	r3, [r7, #4]
90006440:	6a1b      	ldr	r3, [r3, #32]
90006442:	085a      	lsrs	r2, r3, #1
90006444:	687b      	ldr	r3, [r7, #4]
90006446:	621a      	str	r2, [r3, #32]
  }
  /* Check the SAI Block master clock divider parameter */
  assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(hsai->Init.Mckdiv));

  /* Compute CKSTR bits of SAI CR1 according ClockStrobing and AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
90006448:	687b      	ldr	r3, [r7, #4]
9000644a:	685b      	ldr	r3, [r3, #4]
9000644c:	2b00      	cmp	r3, #0
9000644e:	d003      	beq.n	90006458 <HAL_SAI_Init+0x18c>
90006450:	687b      	ldr	r3, [r7, #4]
90006452:	685b      	ldr	r3, [r3, #4]
90006454:	2b02      	cmp	r3, #2
90006456:	d109      	bne.n	9000646c <HAL_SAI_Init+0x1a0>
  {
    /* Transmit */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
90006458:	687b      	ldr	r3, [r7, #4]
9000645a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000645c:	2b01      	cmp	r3, #1
9000645e:	d101      	bne.n	90006464 <HAL_SAI_Init+0x198>
90006460:	2300      	movs	r3, #0
90006462:	e001      	b.n	90006468 <HAL_SAI_Init+0x19c>
90006464:	f44f 7300 	mov.w	r3, #512	; 0x200
90006468:	61bb      	str	r3, [r7, #24]
9000646a:	e008      	b.n	9000647e <HAL_SAI_Init+0x1b2>
  }
  else
  {
    /* Receive */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
9000646c:	687b      	ldr	r3, [r7, #4]
9000646e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
90006470:	2b01      	cmp	r3, #1
90006472:	d102      	bne.n	9000647a <HAL_SAI_Init+0x1ae>
90006474:	f44f 7300 	mov.w	r3, #512	; 0x200
90006478:	e000      	b.n	9000647c <HAL_SAI_Init+0x1b0>
9000647a:	2300      	movs	r3, #0
9000647c:	61bb      	str	r3, [r7, #24]
  }

  /* SAI Block Configuration -------------------------------------------------*/
  /* SAI CR1 Configuration */
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
9000647e:	687b      	ldr	r3, [r7, #4]
90006480:	681b      	ldr	r3, [r3, #0]
90006482:	6819      	ldr	r1, [r3, #0]
90006484:	687b      	ldr	r3, [r7, #4]
90006486:	681a      	ldr	r2, [r3, #0]
90006488:	4b4c      	ldr	r3, [pc, #304]	; (900065bc <HAL_SAI_Init+0x2f0>)
9000648a:	400b      	ands	r3, r1
9000648c:	6013      	str	r3, [r2, #0]
                           SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN | \
                           SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
                           SAI_xCR1_NODIV | SAI_xCR1_MCKDIV);

  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
9000648e:	687b      	ldr	r3, [r7, #4]
90006490:	681b      	ldr	r3, [r3, #0]
90006492:	6819      	ldr	r1, [r3, #0]
90006494:	687b      	ldr	r3, [r7, #4]
90006496:	685a      	ldr	r2, [r3, #4]
90006498:	687b      	ldr	r3, [r7, #4]
9000649a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9000649c:	431a      	orrs	r2, r3
                          hsai->Init.DataSize | hsai->Init.FirstBit  |           \
9000649e:	687b      	ldr	r3, [r7, #4]
900064a0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
900064a2:	431a      	orrs	r2, r3
                          hsai->Init.DataSize | hsai->Init.FirstBit  |           \
900064a4:	687b      	ldr	r3, [r7, #4]
900064a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900064a8:	431a      	orrs	r2, r3
900064aa:	69bb      	ldr	r3, [r7, #24]
900064ac:	431a      	orrs	r2, r3
                          ckstr_bits | syncen_bits |                               \
900064ae:	697b      	ldr	r3, [r7, #20]
900064b0:	431a      	orrs	r2, r3
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
900064b2:	687b      	ldr	r3, [r7, #4]
900064b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                          ckstr_bits | syncen_bits |                               \
900064b6:	431a      	orrs	r2, r3
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
900064b8:	687b      	ldr	r3, [r7, #4]
900064ba:	691b      	ldr	r3, [r3, #16]
900064bc:	431a      	orrs	r2, r3
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
900064be:	687b      	ldr	r3, [r7, #4]
900064c0:	695b      	ldr	r3, [r3, #20]
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
900064c2:	431a      	orrs	r2, r3
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
900064c4:	687b      	ldr	r3, [r7, #4]
900064c6:	6a1b      	ldr	r3, [r3, #32]
900064c8:	051b      	lsls	r3, r3, #20
900064ca:	431a      	orrs	r2, r3
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
900064cc:	687b      	ldr	r3, [r7, #4]
900064ce:	681b      	ldr	r3, [r3, #0]
900064d0:	430a      	orrs	r2, r1
900064d2:	601a      	str	r2, [r3, #0]

  /* SAI CR2 Configuration */
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
900064d4:	687b      	ldr	r3, [r7, #4]
900064d6:	681b      	ldr	r3, [r3, #0]
900064d8:	6859      	ldr	r1, [r3, #4]
900064da:	687b      	ldr	r3, [r7, #4]
900064dc:	681a      	ldr	r2, [r3, #0]
900064de:	4b38      	ldr	r3, [pc, #224]	; (900065c0 <HAL_SAI_Init+0x2f4>)
900064e0:	400b      	ands	r3, r1
900064e2:	6053      	str	r3, [r2, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
900064e4:	687b      	ldr	r3, [r7, #4]
900064e6:	681b      	ldr	r3, [r3, #0]
900064e8:	6859      	ldr	r1, [r3, #4]
900064ea:	687b      	ldr	r3, [r7, #4]
900064ec:	699a      	ldr	r2, [r3, #24]
900064ee:	687b      	ldr	r3, [r7, #4]
900064f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900064f2:	431a      	orrs	r2, r3
900064f4:	687b      	ldr	r3, [r7, #4]
900064f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900064f8:	431a      	orrs	r2, r3
900064fa:	687b      	ldr	r3, [r7, #4]
900064fc:	681b      	ldr	r3, [r3, #0]
900064fe:	430a      	orrs	r2, r1
90006500:	605a      	str	r2, [r3, #4]

  /* SAI Frame Configuration -----------------------------------------*/
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
90006502:	687b      	ldr	r3, [r7, #4]
90006504:	681b      	ldr	r3, [r3, #0]
90006506:	6899      	ldr	r1, [r3, #8]
90006508:	687b      	ldr	r3, [r7, #4]
9000650a:	681a      	ldr	r2, [r3, #0]
9000650c:	4b2d      	ldr	r3, [pc, #180]	; (900065c4 <HAL_SAI_Init+0x2f8>)
9000650e:	400b      	ands	r3, r1
90006510:	6093      	str	r3, [r2, #8]
                             SAI_xFRCR_FSPOL | SAI_xFRCR_FSOFF));
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
90006512:	687b      	ldr	r3, [r7, #4]
90006514:	681b      	ldr	r3, [r3, #0]
90006516:	6899      	ldr	r1, [r3, #8]
90006518:	687b      	ldr	r3, [r7, #4]
9000651a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000651c:	1e5a      	subs	r2, r3, #1
                           hsai->FrameInit.FSOffset |
9000651e:	687b      	ldr	r3, [r7, #4]
90006520:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
90006522:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSDefinition |
90006524:	687b      	ldr	r3, [r7, #4]
90006526:	6c9b      	ldr	r3, [r3, #72]	; 0x48
                           hsai->FrameInit.FSOffset |
90006528:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSPolarity   |
9000652a:	687b      	ldr	r3, [r7, #4]
9000652c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
                           hsai->FrameInit.FSDefinition |
9000652e:	431a      	orrs	r2, r3
                           ((hsai->FrameInit.ActiveFrameLength - 1) << 8));
90006530:	687b      	ldr	r3, [r7, #4]
90006532:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90006534:	3b01      	subs	r3, #1
90006536:	021b      	lsls	r3, r3, #8
                           hsai->FrameInit.FSPolarity   |
90006538:	431a      	orrs	r2, r3
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
9000653a:	687b      	ldr	r3, [r7, #4]
9000653c:	681b      	ldr	r3, [r3, #0]
9000653e:	430a      	orrs	r2, r1
90006540:	609a      	str	r2, [r3, #8]

  /* SAI Block_x SLOT Configuration ------------------------------------------*/
  /* This register has no meaning in AC 97 and SPDIF audio protocol */
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
90006542:	687b      	ldr	r3, [r7, #4]
90006544:	681b      	ldr	r3, [r3, #0]
90006546:	68d9      	ldr	r1, [r3, #12]
90006548:	687b      	ldr	r3, [r7, #4]
9000654a:	681a      	ldr	r2, [r3, #0]
9000654c:	f24f 0320 	movw	r3, #61472	; 0xf020
90006550:	400b      	ands	r3, r1
90006552:	60d3      	str	r3, [r2, #12]
                              SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN));

  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
90006554:	687b      	ldr	r3, [r7, #4]
90006556:	681b      	ldr	r3, [r3, #0]
90006558:	68d9      	ldr	r1, [r3, #12]
9000655a:	687b      	ldr	r3, [r7, #4]
9000655c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
9000655e:	687b      	ldr	r3, [r7, #4]
90006560:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90006562:	431a      	orrs	r2, r3
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
90006564:	687b      	ldr	r3, [r7, #4]
90006566:	6e1b      	ldr	r3, [r3, #96]	; 0x60
90006568:	041b      	lsls	r3, r3, #16
9000656a:	431a      	orrs	r2, r3
9000656c:	687b      	ldr	r3, [r7, #4]
9000656e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
90006570:	3b01      	subs	r3, #1
90006572:	021b      	lsls	r3, r3, #8
90006574:	431a      	orrs	r2, r3
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
90006576:	687b      	ldr	r3, [r7, #4]
90006578:	681b      	ldr	r3, [r3, #0]
9000657a:	430a      	orrs	r2, r1
9000657c:	60da      	str	r2, [r3, #12]

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
9000657e:	687b      	ldr	r3, [r7, #4]
90006580:	2200      	movs	r2, #0
90006582:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_READY;
90006586:	687b      	ldr	r3, [r7, #4]
90006588:	2201      	movs	r2, #1
9000658a:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

  /* Release Lock */
  __HAL_UNLOCK(hsai);
9000658e:	687b      	ldr	r3, [r7, #4]
90006590:	2200      	movs	r2, #0
90006592:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
90006596:	2300      	movs	r3, #0
}
90006598:	4618      	mov	r0, r3
9000659a:	3720      	adds	r7, #32
9000659c:	46bd      	mov	sp, r7
9000659e:	bd80      	pop	{r7, pc}
900065a0:	40015804 	.word	0x40015804
900065a4:	40015824 	.word	0x40015824
900065a8:	40015800 	.word	0x40015800
900065ac:	40015c00 	.word	0x40015c00
900065b0:	40015c04 	.word	0x40015c04
900065b4:	40015c24 	.word	0x40015c24
900065b8:	cccccccd 	.word	0xcccccccd
900065bc:	ff05c010 	.word	0xff05c010
900065c0:	ffff1ff0 	.word	0xffff1ff0
900065c4:	fff88000 	.word	0xfff88000

900065c8 <HAL_SAI_DeInit>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_DeInit(SAI_HandleTypeDef *hsai)
{
900065c8:	b580      	push	{r7, lr}
900065ca:	b082      	sub	sp, #8
900065cc:	af00      	add	r7, sp, #0
900065ce:	6078      	str	r0, [r7, #4]
  /* Check the SAI handle allocation */
  if (hsai == NULL)
900065d0:	687b      	ldr	r3, [r7, #4]
900065d2:	2b00      	cmp	r3, #0
900065d4:	d101      	bne.n	900065da <HAL_SAI_DeInit+0x12>
  {
    return HAL_ERROR;
900065d6:	2301      	movs	r3, #1
900065d8:	e027      	b.n	9000662a <HAL_SAI_DeInit+0x62>
  }

  hsai->State = HAL_SAI_STATE_BUSY;
900065da:	687b      	ldr	r3, [r7, #4]
900065dc:	2202      	movs	r2, #2
900065de:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

  /* Disabled All interrupt and clear all the flag */
  hsai->Instance->IMR = 0;
900065e2:	687b      	ldr	r3, [r7, #4]
900065e4:	681b      	ldr	r3, [r3, #0]
900065e6:	2200      	movs	r2, #0
900065e8:	611a      	str	r2, [r3, #16]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
900065ea:	687b      	ldr	r3, [r7, #4]
900065ec:	681b      	ldr	r3, [r3, #0]
900065ee:	f04f 32ff 	mov.w	r2, #4294967295
900065f2:	619a      	str	r2, [r3, #24]

  /* Disable the SAI */
  SAI_Disable(hsai);
900065f4:	6878      	ldr	r0, [r7, #4]
900065f6:	f000 f9b3 	bl	90006960 <SAI_Disable>

  /* Flush the fifo */
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
900065fa:	687b      	ldr	r3, [r7, #4]
900065fc:	681b      	ldr	r3, [r3, #0]
900065fe:	685a      	ldr	r2, [r3, #4]
90006600:	687b      	ldr	r3, [r7, #4]
90006602:	681b      	ldr	r3, [r3, #0]
90006604:	f042 0208 	orr.w	r2, r2, #8
90006608:	605a      	str	r2, [r3, #4]
  {
    hsai->MspDeInitCallback = HAL_SAI_MspDeInit;
  }
  hsai->MspDeInitCallback(hsai);
#else
  HAL_SAI_MspDeInit(hsai);
9000660a:	6878      	ldr	r0, [r7, #4]
9000660c:	f000 f81b 	bl	90006646 <HAL_SAI_MspDeInit>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
90006610:	687b      	ldr	r3, [r7, #4]
90006612:	2200      	movs	r2, #0
90006614:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_RESET;
90006618:	687b      	ldr	r3, [r7, #4]
9000661a:	2200      	movs	r2, #0
9000661c:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

  /* Release Lock */
  __HAL_UNLOCK(hsai);
90006620:	687b      	ldr	r3, [r7, #4]
90006622:	2200      	movs	r2, #0
90006624:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
90006628:	2300      	movs	r3, #0
}
9000662a:	4618      	mov	r0, r3
9000662c:	3708      	adds	r7, #8
9000662e:	46bd      	mov	sp, r7
90006630:	bd80      	pop	{r7, pc}

90006632 <HAL_SAI_MspInit>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_MspInit(SAI_HandleTypeDef *hsai)
{
90006632:	b480      	push	{r7}
90006634:	b083      	sub	sp, #12
90006636:	af00      	add	r7, sp, #0
90006638:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_MspInit could be implemented in the user file
   */
}
9000663a:	bf00      	nop
9000663c:	370c      	adds	r7, #12
9000663e:	46bd      	mov	sp, r7
90006640:	f85d 7b04 	ldr.w	r7, [sp], #4
90006644:	4770      	bx	lr

90006646 <HAL_SAI_MspDeInit>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_MspDeInit(SAI_HandleTypeDef *hsai)
{
90006646:	b480      	push	{r7}
90006648:	b083      	sub	sp, #12
9000664a:	af00      	add	r7, sp, #0
9000664c:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_MspDeInit could be implemented in the user file
   */
}
9000664e:	bf00      	nop
90006650:	370c      	adds	r7, #12
90006652:	46bd      	mov	sp, r7
90006654:	f85d 7b04 	ldr.w	r7, [sp], #4
90006658:	4770      	bx	lr
	...

9000665c <HAL_SAI_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Transmit_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
{
9000665c:	b580      	push	{r7, lr}
9000665e:	b086      	sub	sp, #24
90006660:	af00      	add	r7, sp, #0
90006662:	60f8      	str	r0, [r7, #12]
90006664:	60b9      	str	r1, [r7, #8]
90006666:	4613      	mov	r3, r2
90006668:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart = HAL_GetTick();
9000666a:	f7fd f8bf 	bl	900037ec <HAL_GetTick>
9000666e:	6178      	str	r0, [r7, #20]

  if ((pData == NULL) || (Size == 0))
90006670:	68bb      	ldr	r3, [r7, #8]
90006672:	2b00      	cmp	r3, #0
90006674:	d002      	beq.n	9000667c <HAL_SAI_Transmit_DMA+0x20>
90006676:	88fb      	ldrh	r3, [r7, #6]
90006678:	2b00      	cmp	r3, #0
9000667a:	d101      	bne.n	90006680 <HAL_SAI_Transmit_DMA+0x24>
  {
    return  HAL_ERROR;
9000667c:	2301      	movs	r3, #1
9000667e:	e093      	b.n	900067a8 <HAL_SAI_Transmit_DMA+0x14c>
  }

  if (hsai->State == HAL_SAI_STATE_READY)
90006680:	68fb      	ldr	r3, [r7, #12]
90006682:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
90006686:	b2db      	uxtb	r3, r3
90006688:	2b01      	cmp	r3, #1
9000668a:	f040 808c 	bne.w	900067a6 <HAL_SAI_Transmit_DMA+0x14a>
  {
    /* Process Locked */
    __HAL_LOCK(hsai);
9000668e:	68fb      	ldr	r3, [r7, #12]
90006690:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
90006694:	2b01      	cmp	r3, #1
90006696:	d101      	bne.n	9000669c <HAL_SAI_Transmit_DMA+0x40>
90006698:	2302      	movs	r3, #2
9000669a:	e085      	b.n	900067a8 <HAL_SAI_Transmit_DMA+0x14c>
9000669c:	68fb      	ldr	r3, [r7, #12]
9000669e:	2201      	movs	r2, #1
900066a0:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    hsai->pBuffPtr = pData;
900066a4:	68fb      	ldr	r3, [r7, #12]
900066a6:	68ba      	ldr	r2, [r7, #8]
900066a8:	665a      	str	r2, [r3, #100]	; 0x64
    hsai->XferSize = Size;
900066aa:	68fb      	ldr	r3, [r7, #12]
900066ac:	88fa      	ldrh	r2, [r7, #6]
900066ae:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    hsai->XferCount = Size;
900066b2:	68fb      	ldr	r3, [r7, #12]
900066b4:	88fa      	ldrh	r2, [r7, #6]
900066b6:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
900066ba:	68fb      	ldr	r3, [r7, #12]
900066bc:	2200      	movs	r2, #0
900066be:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_TX;
900066c2:	68fb      	ldr	r3, [r7, #12]
900066c4:	2212      	movs	r2, #18
900066c6:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

    /* Set the SAI Tx DMA Half transfer complete callback */
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
900066ca:	68fb      	ldr	r3, [r7, #12]
900066cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
900066ce:	4a38      	ldr	r2, [pc, #224]	; (900067b0 <HAL_SAI_Transmit_DMA+0x154>)
900066d0:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the SAI TxDMA transfer complete callback */
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
900066d2:	68fb      	ldr	r3, [r7, #12]
900066d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
900066d6:	4a37      	ldr	r2, [pc, #220]	; (900067b4 <HAL_SAI_Transmit_DMA+0x158>)
900066d8:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA error callback */
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
900066da:	68fb      	ldr	r3, [r7, #12]
900066dc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
900066de:	4a36      	ldr	r2, [pc, #216]	; (900067b8 <HAL_SAI_Transmit_DMA+0x15c>)
900066e0:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA Tx abort callback */
    hsai->hdmatx->XferAbortCallback = NULL;
900066e2:	68fb      	ldr	r3, [r7, #12]
900066e4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
900066e6:	2200      	movs	r2, #0
900066e8:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the Tx DMA Stream */
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
900066ea:	68fb      	ldr	r3, [r7, #12]
900066ec:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
900066ee:	68fb      	ldr	r3, [r7, #12]
900066f0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
900066f2:	4619      	mov	r1, r3
900066f4:	68fb      	ldr	r3, [r7, #12]
900066f6:	681b      	ldr	r3, [r3, #0]
900066f8:	331c      	adds	r3, #28
900066fa:	461a      	mov	r2, r3
900066fc:	68fb      	ldr	r3, [r7, #12]
900066fe:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
90006702:	f7fd fac1 	bl	90003c88 <HAL_DMA_Start_IT>
90006706:	4603      	mov	r3, r0
90006708:	2b00      	cmp	r3, #0
9000670a:	d005      	beq.n	90006718 <HAL_SAI_Transmit_DMA+0xbc>
    {
      __HAL_UNLOCK(hsai);
9000670c:	68fb      	ldr	r3, [r7, #12]
9000670e:	2200      	movs	r2, #0
90006710:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
      return  HAL_ERROR;
90006714:	2301      	movs	r3, #1
90006716:	e047      	b.n	900067a8 <HAL_SAI_Transmit_DMA+0x14c>
    }

    /* Enable the interrupts for error handling */
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
90006718:	2100      	movs	r1, #0
9000671a:	68f8      	ldr	r0, [r7, #12]
9000671c:	f000 f8ea 	bl	900068f4 <SAI_InterruptFlag>
90006720:	4601      	mov	r1, r0
90006722:	68fb      	ldr	r3, [r7, #12]
90006724:	681b      	ldr	r3, [r3, #0]
90006726:	691a      	ldr	r2, [r3, #16]
90006728:	68fb      	ldr	r3, [r7, #12]
9000672a:	681b      	ldr	r3, [r3, #0]
9000672c:	430a      	orrs	r2, r1
9000672e:	611a      	str	r2, [r3, #16]

    /* Enable SAI Tx DMA Request */
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
90006730:	68fb      	ldr	r3, [r7, #12]
90006732:	681b      	ldr	r3, [r3, #0]
90006734:	681a      	ldr	r2, [r3, #0]
90006736:	68fb      	ldr	r3, [r7, #12]
90006738:	681b      	ldr	r3, [r3, #0]
9000673a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
9000673e:	601a      	str	r2, [r3, #0]

    /* Wait until FIFO is not empty */
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
90006740:	e015      	b.n	9000676e <HAL_SAI_Transmit_DMA+0x112>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
90006742:	f7fd f853 	bl	900037ec <HAL_GetTick>
90006746:	4602      	mov	r2, r0
90006748:	697b      	ldr	r3, [r7, #20]
9000674a:	1ad3      	subs	r3, r2, r3
9000674c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
90006750:	d90d      	bls.n	9000676e <HAL_SAI_Transmit_DMA+0x112>
      {
        /* Update error code */
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
90006752:	68fb      	ldr	r3, [r7, #12]
90006754:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90006758:	f043 0240 	orr.w	r2, r3, #64	; 0x40
9000675c:	68fb      	ldr	r3, [r7, #12]
9000675e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

        /* Process Unlocked */
        __HAL_UNLOCK(hsai);
90006762:	68fb      	ldr	r3, [r7, #12]
90006764:	2200      	movs	r2, #0
90006766:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

        return HAL_TIMEOUT;
9000676a:	2303      	movs	r3, #3
9000676c:	e01c      	b.n	900067a8 <HAL_SAI_Transmit_DMA+0x14c>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
9000676e:	68fb      	ldr	r3, [r7, #12]
90006770:	681b      	ldr	r3, [r3, #0]
90006772:	695b      	ldr	r3, [r3, #20]
90006774:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
90006778:	2b00      	cmp	r3, #0
9000677a:	d0e2      	beq.n	90006742 <HAL_SAI_Transmit_DMA+0xe6>
      }
    }

    /* Check if the SAI is already enabled */
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
9000677c:	68fb      	ldr	r3, [r7, #12]
9000677e:	681b      	ldr	r3, [r3, #0]
90006780:	681b      	ldr	r3, [r3, #0]
90006782:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90006786:	2b00      	cmp	r3, #0
90006788:	d107      	bne.n	9000679a <HAL_SAI_Transmit_DMA+0x13e>
    {
      /* Enable SAI peripheral */
      __HAL_SAI_ENABLE(hsai);
9000678a:	68fb      	ldr	r3, [r7, #12]
9000678c:	681b      	ldr	r3, [r3, #0]
9000678e:	681a      	ldr	r2, [r3, #0]
90006790:	68fb      	ldr	r3, [r7, #12]
90006792:	681b      	ldr	r3, [r3, #0]
90006794:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90006798:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hsai);
9000679a:	68fb      	ldr	r3, [r7, #12]
9000679c:	2200      	movs	r2, #0
9000679e:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    return HAL_OK;
900067a2:	2300      	movs	r3, #0
900067a4:	e000      	b.n	900067a8 <HAL_SAI_Transmit_DMA+0x14c>
  }
  else
  {
    return HAL_BUSY;
900067a6:	2302      	movs	r3, #2
  }
}
900067a8:	4618      	mov	r0, r3
900067aa:	3718      	adds	r7, #24
900067ac:	46bd      	mov	sp, r7
900067ae:	bd80      	pop	{r7, pc}
900067b0:	90006a31 	.word	0x90006a31
900067b4:	900069d1 	.word	0x900069d1
900067b8:	90006ac9 	.word	0x90006ac9

900067bc <HAL_SAI_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Receive_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
{
900067bc:	b580      	push	{r7, lr}
900067be:	b084      	sub	sp, #16
900067c0:	af00      	add	r7, sp, #0
900067c2:	60f8      	str	r0, [r7, #12]
900067c4:	60b9      	str	r1, [r7, #8]
900067c6:	4613      	mov	r3, r2
900067c8:	80fb      	strh	r3, [r7, #6]

  if ((pData == NULL) || (Size == 0))
900067ca:	68bb      	ldr	r3, [r7, #8]
900067cc:	2b00      	cmp	r3, #0
900067ce:	d002      	beq.n	900067d6 <HAL_SAI_Receive_DMA+0x1a>
900067d0:	88fb      	ldrh	r3, [r7, #6]
900067d2:	2b00      	cmp	r3, #0
900067d4:	d101      	bne.n	900067da <HAL_SAI_Receive_DMA+0x1e>
  {
    return  HAL_ERROR;
900067d6:	2301      	movs	r3, #1
900067d8:	e074      	b.n	900068c4 <HAL_SAI_Receive_DMA+0x108>
  }

  if (hsai->State == HAL_SAI_STATE_READY)
900067da:	68fb      	ldr	r3, [r7, #12]
900067dc:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
900067e0:	b2db      	uxtb	r3, r3
900067e2:	2b01      	cmp	r3, #1
900067e4:	d16d      	bne.n	900068c2 <HAL_SAI_Receive_DMA+0x106>
  {
    /* Process Locked */
    __HAL_LOCK(hsai);
900067e6:	68fb      	ldr	r3, [r7, #12]
900067e8:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
900067ec:	2b01      	cmp	r3, #1
900067ee:	d101      	bne.n	900067f4 <HAL_SAI_Receive_DMA+0x38>
900067f0:	2302      	movs	r3, #2
900067f2:	e067      	b.n	900068c4 <HAL_SAI_Receive_DMA+0x108>
900067f4:	68fb      	ldr	r3, [r7, #12]
900067f6:	2201      	movs	r2, #1
900067f8:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    hsai->pBuffPtr = pData;
900067fc:	68fb      	ldr	r3, [r7, #12]
900067fe:	68ba      	ldr	r2, [r7, #8]
90006800:	665a      	str	r2, [r3, #100]	; 0x64
    hsai->XferSize = Size;
90006802:	68fb      	ldr	r3, [r7, #12]
90006804:	88fa      	ldrh	r2, [r7, #6]
90006806:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    hsai->XferCount = Size;
9000680a:	68fb      	ldr	r3, [r7, #12]
9000680c:	88fa      	ldrh	r2, [r7, #6]
9000680e:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
90006812:	68fb      	ldr	r3, [r7, #12]
90006814:	2200      	movs	r2, #0
90006816:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_RX;
9000681a:	68fb      	ldr	r3, [r7, #12]
9000681c:	2222      	movs	r2, #34	; 0x22
9000681e:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

    /* Set the SAI Rx DMA Half transfer complete callback */
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
90006822:	68fb      	ldr	r3, [r7, #12]
90006824:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90006826:	4a29      	ldr	r2, [pc, #164]	; (900068cc <HAL_SAI_Receive_DMA+0x110>)
90006828:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the SAI Rx DMA transfer complete callback */
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
9000682a:	68fb      	ldr	r3, [r7, #12]
9000682c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000682e:	4a28      	ldr	r2, [pc, #160]	; (900068d0 <HAL_SAI_Receive_DMA+0x114>)
90006830:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA error callback */
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
90006832:	68fb      	ldr	r3, [r7, #12]
90006834:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90006836:	4a27      	ldr	r2, [pc, #156]	; (900068d4 <HAL_SAI_Receive_DMA+0x118>)
90006838:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA Rx abort callback */
    hsai->hdmarx->XferAbortCallback = NULL;
9000683a:	68fb      	ldr	r3, [r7, #12]
9000683c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000683e:	2200      	movs	r2, #0
90006840:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the Rx DMA Stream */
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
90006842:	68fb      	ldr	r3, [r7, #12]
90006844:	6f18      	ldr	r0, [r3, #112]	; 0x70
90006846:	68fb      	ldr	r3, [r7, #12]
90006848:	681b      	ldr	r3, [r3, #0]
9000684a:	331c      	adds	r3, #28
9000684c:	4619      	mov	r1, r3
9000684e:	68fb      	ldr	r3, [r7, #12]
90006850:	6e5b      	ldr	r3, [r3, #100]	; 0x64
90006852:	461a      	mov	r2, r3
90006854:	68fb      	ldr	r3, [r7, #12]
90006856:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
9000685a:	f7fd fa15 	bl	90003c88 <HAL_DMA_Start_IT>
9000685e:	4603      	mov	r3, r0
90006860:	2b00      	cmp	r3, #0
90006862:	d005      	beq.n	90006870 <HAL_SAI_Receive_DMA+0xb4>
    {
      __HAL_UNLOCK(hsai);
90006864:	68fb      	ldr	r3, [r7, #12]
90006866:	2200      	movs	r2, #0
90006868:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
      return  HAL_ERROR;
9000686c:	2301      	movs	r3, #1
9000686e:	e029      	b.n	900068c4 <HAL_SAI_Receive_DMA+0x108>
    }

    /* Enable the interrupts for error handling */
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
90006870:	2100      	movs	r1, #0
90006872:	68f8      	ldr	r0, [r7, #12]
90006874:	f000 f83e 	bl	900068f4 <SAI_InterruptFlag>
90006878:	4601      	mov	r1, r0
9000687a:	68fb      	ldr	r3, [r7, #12]
9000687c:	681b      	ldr	r3, [r3, #0]
9000687e:	691a      	ldr	r2, [r3, #16]
90006880:	68fb      	ldr	r3, [r7, #12]
90006882:	681b      	ldr	r3, [r3, #0]
90006884:	430a      	orrs	r2, r1
90006886:	611a      	str	r2, [r3, #16]

    /* Enable SAI Rx DMA Request */
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
90006888:	68fb      	ldr	r3, [r7, #12]
9000688a:	681b      	ldr	r3, [r3, #0]
9000688c:	681a      	ldr	r2, [r3, #0]
9000688e:	68fb      	ldr	r3, [r7, #12]
90006890:	681b      	ldr	r3, [r3, #0]
90006892:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
90006896:	601a      	str	r2, [r3, #0]

    /* Check if the SAI is already enabled */
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
90006898:	68fb      	ldr	r3, [r7, #12]
9000689a:	681b      	ldr	r3, [r3, #0]
9000689c:	681b      	ldr	r3, [r3, #0]
9000689e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
900068a2:	2b00      	cmp	r3, #0
900068a4:	d107      	bne.n	900068b6 <HAL_SAI_Receive_DMA+0xfa>
    {
      /* Enable SAI peripheral */
      __HAL_SAI_ENABLE(hsai);
900068a6:	68fb      	ldr	r3, [r7, #12]
900068a8:	681b      	ldr	r3, [r3, #0]
900068aa:	681a      	ldr	r2, [r3, #0]
900068ac:	68fb      	ldr	r3, [r7, #12]
900068ae:	681b      	ldr	r3, [r3, #0]
900068b0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900068b4:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hsai);
900068b6:	68fb      	ldr	r3, [r7, #12]
900068b8:	2200      	movs	r2, #0
900068ba:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

    return HAL_OK;
900068be:	2300      	movs	r3, #0
900068c0:	e000      	b.n	900068c4 <HAL_SAI_Receive_DMA+0x108>
  }
  else
  {
    return HAL_BUSY;
900068c2:	2302      	movs	r3, #2
  }
}
900068c4:	4618      	mov	r0, r3
900068c6:	3710      	adds	r7, #16
900068c8:	46bd      	mov	sp, r7
900068ca:	bd80      	pop	{r7, pc}
900068cc:	90006aad 	.word	0x90006aad
900068d0:	90006a4d 	.word	0x90006a4d
900068d4:	90006ac9 	.word	0x90006ac9

900068d8 <HAL_SAI_GetState>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval HAL state
  */
HAL_SAI_StateTypeDef HAL_SAI_GetState(SAI_HandleTypeDef *hsai)
{
900068d8:	b480      	push	{r7}
900068da:	b083      	sub	sp, #12
900068dc:	af00      	add	r7, sp, #0
900068de:	6078      	str	r0, [r7, #4]
  return hsai->State;
900068e0:	687b      	ldr	r3, [r7, #4]
900068e2:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
900068e6:	b2db      	uxtb	r3, r3
}
900068e8:	4618      	mov	r0, r3
900068ea:	370c      	adds	r7, #12
900068ec:	46bd      	mov	sp, r7
900068ee:	f85d 7b04 	ldr.w	r7, [sp], #4
900068f2:	4770      	bx	lr

900068f4 <SAI_InterruptFlag>:
  *                the configuration information for SAI module.
  * @param  mode SAI_MODE_DMA or SAI_MODE_IT
  * @retval the list of the IT flag to enable
 */
static uint32_t SAI_InterruptFlag(SAI_HandleTypeDef *hsai, uint32_t mode)
{
900068f4:	b480      	push	{r7}
900068f6:	b085      	sub	sp, #20
900068f8:	af00      	add	r7, sp, #0
900068fa:	6078      	str	r0, [r7, #4]
900068fc:	6039      	str	r1, [r7, #0]
  uint32_t tmpIT = SAI_IT_OVRUDR;
900068fe:	2301      	movs	r3, #1
90006900:	60fb      	str	r3, [r7, #12]

  if (mode == SAI_MODE_IT)
90006902:	683b      	ldr	r3, [r7, #0]
90006904:	2b01      	cmp	r3, #1
90006906:	d103      	bne.n	90006910 <SAI_InterruptFlag+0x1c>
  {
    tmpIT |= SAI_IT_FREQ;
90006908:	68fb      	ldr	r3, [r7, #12]
9000690a:	f043 0308 	orr.w	r3, r3, #8
9000690e:	60fb      	str	r3, [r7, #12]
  }

  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
90006910:	687b      	ldr	r3, [r7, #4]
90006912:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90006914:	2b08      	cmp	r3, #8
90006916:	d10b      	bne.n	90006930 <SAI_InterruptFlag+0x3c>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
90006918:	687b      	ldr	r3, [r7, #4]
9000691a:	685b      	ldr	r3, [r3, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
9000691c:	2b03      	cmp	r3, #3
9000691e:	d003      	beq.n	90006928 <SAI_InterruptFlag+0x34>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
90006920:	687b      	ldr	r3, [r7, #4]
90006922:	685b      	ldr	r3, [r3, #4]
90006924:	2b01      	cmp	r3, #1
90006926:	d103      	bne.n	90006930 <SAI_InterruptFlag+0x3c>
  {
    tmpIT |= SAI_IT_CNRDY;
90006928:	68fb      	ldr	r3, [r7, #12]
9000692a:	f043 0310 	orr.w	r3, r3, #16
9000692e:	60fb      	str	r3, [r7, #12]
  }

  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
90006930:	687b      	ldr	r3, [r7, #4]
90006932:	685b      	ldr	r3, [r3, #4]
90006934:	2b03      	cmp	r3, #3
90006936:	d003      	beq.n	90006940 <SAI_InterruptFlag+0x4c>
90006938:	687b      	ldr	r3, [r7, #4]
9000693a:	685b      	ldr	r3, [r3, #4]
9000693c:	2b02      	cmp	r3, #2
9000693e:	d104      	bne.n	9000694a <SAI_InterruptFlag+0x56>
  {
    tmpIT |= SAI_IT_AFSDET | SAI_IT_LFSDET;
90006940:	68fb      	ldr	r3, [r7, #12]
90006942:	f043 0360 	orr.w	r3, r3, #96	; 0x60
90006946:	60fb      	str	r3, [r7, #12]
90006948:	e003      	b.n	90006952 <SAI_InterruptFlag+0x5e>
  }
  else
  {
    /* hsai has been configured in master mode */
    tmpIT |= SAI_IT_WCKCFG;
9000694a:	68fb      	ldr	r3, [r7, #12]
9000694c:	f043 0304 	orr.w	r3, r3, #4
90006950:	60fb      	str	r3, [r7, #12]
  }
  return tmpIT;
90006952:	68fb      	ldr	r3, [r7, #12]
}
90006954:	4618      	mov	r0, r3
90006956:	3714      	adds	r7, #20
90006958:	46bd      	mov	sp, r7
9000695a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000695e:	4770      	bx	lr

90006960 <SAI_Disable>:
  * @param  hsai  pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
90006960:	b480      	push	{r7}
90006962:	b085      	sub	sp, #20
90006964:	af00      	add	r7, sp, #0
90006966:	6078      	str	r0, [r7, #4]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
90006968:	4b17      	ldr	r3, [pc, #92]	; (900069c8 <SAI_Disable+0x68>)
9000696a:	681b      	ldr	r3, [r3, #0]
9000696c:	4a17      	ldr	r2, [pc, #92]	; (900069cc <SAI_Disable+0x6c>)
9000696e:	fba2 2303 	umull	r2, r3, r2, r3
90006972:	0b1b      	lsrs	r3, r3, #12
90006974:	009b      	lsls	r3, r3, #2
90006976:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef status = HAL_OK;
90006978:	2300      	movs	r3, #0
9000697a:	72fb      	strb	r3, [r7, #11]

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
9000697c:	687b      	ldr	r3, [r7, #4]
9000697e:	681b      	ldr	r3, [r3, #0]
90006980:	681a      	ldr	r2, [r3, #0]
90006982:	687b      	ldr	r3, [r7, #4]
90006984:	681b      	ldr	r3, [r3, #0]
90006986:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
9000698a:	601a      	str	r2, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count-- == 0)
9000698c:	68fb      	ldr	r3, [r7, #12]
9000698e:	1e5a      	subs	r2, r3, #1
90006990:	60fa      	str	r2, [r7, #12]
90006992:	2b00      	cmp	r3, #0
90006994:	d10a      	bne.n	900069ac <SAI_Disable+0x4c>
    {
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
90006996:	687b      	ldr	r3, [r7, #4]
90006998:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
9000699c:	f043 0240 	orr.w	r2, r3, #64	; 0x40
900069a0:	687b      	ldr	r3, [r7, #4]
900069a2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      status = HAL_TIMEOUT;
900069a6:	2303      	movs	r3, #3
900069a8:	72fb      	strb	r3, [r7, #11]
      break;
900069aa:	e006      	b.n	900069ba <SAI_Disable+0x5a>
    }
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
900069ac:	687b      	ldr	r3, [r7, #4]
900069ae:	681b      	ldr	r3, [r3, #0]
900069b0:	681b      	ldr	r3, [r3, #0]
900069b2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
900069b6:	2b00      	cmp	r3, #0
900069b8:	d1e8      	bne.n	9000698c <SAI_Disable+0x2c>

  return status;
900069ba:	7afb      	ldrb	r3, [r7, #11]
}
900069bc:	4618      	mov	r0, r3
900069be:	3714      	adds	r7, #20
900069c0:	46bd      	mov	sp, r7
900069c2:	f85d 7b04 	ldr.w	r7, [sp], #4
900069c6:	4770      	bx	lr
900069c8:	20000000 	.word	0x20000000
900069cc:	95cbec1b 	.word	0x95cbec1b

900069d0 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
900069d0:	b580      	push	{r7, lr}
900069d2:	b084      	sub	sp, #16
900069d4:	af00      	add	r7, sp, #0
900069d6:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
900069d8:	687b      	ldr	r3, [r7, #4]
900069da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900069dc:	60fb      	str	r3, [r7, #12]

  if (hdma->Init.Mode != DMA_CIRCULAR)
900069de:	687b      	ldr	r3, [r7, #4]
900069e0:	69db      	ldr	r3, [r3, #28]
900069e2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900069e6:	d01c      	beq.n	90006a22 <SAI_DMATxCplt+0x52>
  {
    hsai->XferCount = 0;
900069e8:	68fb      	ldr	r3, [r7, #12]
900069ea:	2200      	movs	r2, #0
900069ec:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
900069f0:	68fb      	ldr	r3, [r7, #12]
900069f2:	681b      	ldr	r3, [r3, #0]
900069f4:	681a      	ldr	r2, [r3, #0]
900069f6:	68fb      	ldr	r3, [r7, #12]
900069f8:	681b      	ldr	r3, [r3, #0]
900069fa:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
900069fe:	601a      	str	r2, [r3, #0]

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
90006a00:	2100      	movs	r1, #0
90006a02:	68f8      	ldr	r0, [r7, #12]
90006a04:	f7ff ff76 	bl	900068f4 <SAI_InterruptFlag>
90006a08:	4603      	mov	r3, r0
90006a0a:	43d9      	mvns	r1, r3
90006a0c:	68fb      	ldr	r3, [r7, #12]
90006a0e:	681b      	ldr	r3, [r3, #0]
90006a10:	691a      	ldr	r2, [r3, #16]
90006a12:	68fb      	ldr	r3, [r7, #12]
90006a14:	681b      	ldr	r3, [r3, #0]
90006a16:	400a      	ands	r2, r1
90006a18:	611a      	str	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
90006a1a:	68fb      	ldr	r3, [r7, #12]
90006a1c:	2201      	movs	r2, #1
90006a1e:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
90006a22:	68f8      	ldr	r0, [r7, #12]
90006a24:	f7fc f926 	bl	90002c74 <HAL_SAI_TxCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
90006a28:	bf00      	nop
90006a2a:	3710      	adds	r7, #16
90006a2c:	46bd      	mov	sp, r7
90006a2e:	bd80      	pop	{r7, pc}

90006a30 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
90006a30:	b580      	push	{r7, lr}
90006a32:	b084      	sub	sp, #16
90006a34:	af00      	add	r7, sp, #0
90006a36:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90006a38:	687b      	ldr	r3, [r7, #4]
90006a3a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90006a3c:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
90006a3e:	68f8      	ldr	r0, [r7, #12]
90006a40:	f7fc f922 	bl	90002c88 <HAL_SAI_TxHalfCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
90006a44:	bf00      	nop
90006a46:	3710      	adds	r7, #16
90006a48:	46bd      	mov	sp, r7
90006a4a:	bd80      	pop	{r7, pc}

90006a4c <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
90006a4c:	b580      	push	{r7, lr}
90006a4e:	b084      	sub	sp, #16
90006a50:	af00      	add	r7, sp, #0
90006a52:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90006a54:	687b      	ldr	r3, [r7, #4]
90006a56:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90006a58:	60fb      	str	r3, [r7, #12]

  if (hdma->Init.Mode != DMA_CIRCULAR)
90006a5a:	687b      	ldr	r3, [r7, #4]
90006a5c:	69db      	ldr	r3, [r3, #28]
90006a5e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90006a62:	d01c      	beq.n	90006a9e <SAI_DMARxCplt+0x52>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
90006a64:	68fb      	ldr	r3, [r7, #12]
90006a66:	681b      	ldr	r3, [r3, #0]
90006a68:	681a      	ldr	r2, [r3, #0]
90006a6a:	68fb      	ldr	r3, [r7, #12]
90006a6c:	681b      	ldr	r3, [r3, #0]
90006a6e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
90006a72:	601a      	str	r2, [r3, #0]
    hsai->XferCount = 0;
90006a74:	68fb      	ldr	r3, [r7, #12]
90006a76:	2200      	movs	r2, #0
90006a78:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
90006a7c:	2100      	movs	r1, #0
90006a7e:	68f8      	ldr	r0, [r7, #12]
90006a80:	f7ff ff38 	bl	900068f4 <SAI_InterruptFlag>
90006a84:	4603      	mov	r3, r0
90006a86:	43d9      	mvns	r1, r3
90006a88:	68fb      	ldr	r3, [r7, #12]
90006a8a:	681b      	ldr	r3, [r3, #0]
90006a8c:	691a      	ldr	r2, [r3, #16]
90006a8e:	68fb      	ldr	r3, [r7, #12]
90006a90:	681b      	ldr	r3, [r3, #0]
90006a92:	400a      	ands	r2, r1
90006a94:	611a      	str	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
90006a96:	68fb      	ldr	r3, [r7, #12]
90006a98:	2201      	movs	r2, #1
90006a9a:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
90006a9e:	68f8      	ldr	r0, [r7, #12]
90006aa0:	f7fc fafa 	bl	90003098 <HAL_SAI_RxCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
90006aa4:	bf00      	nop
90006aa6:	3710      	adds	r7, #16
90006aa8:	46bd      	mov	sp, r7
90006aaa:	bd80      	pop	{r7, pc}

90006aac <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
90006aac:	b580      	push	{r7, lr}
90006aae:	b084      	sub	sp, #16
90006ab0:	af00      	add	r7, sp, #0
90006ab2:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90006ab4:	687b      	ldr	r3, [r7, #4]
90006ab6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90006ab8:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
90006aba:	68f8      	ldr	r0, [r7, #12]
90006abc:	f7fc faf6 	bl	900030ac <HAL_SAI_RxHalfCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
90006ac0:	bf00      	nop
90006ac2:	3710      	adds	r7, #16
90006ac4:	46bd      	mov	sp, r7
90006ac6:	bd80      	pop	{r7, pc}

90006ac8 <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
90006ac8:	b580      	push	{r7, lr}
90006aca:	b084      	sub	sp, #16
90006acc:	af00      	add	r7, sp, #0
90006ace:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90006ad0:	687b      	ldr	r3, [r7, #4]
90006ad2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90006ad4:	60fb      	str	r3, [r7, #12]

  /* Set SAI error code */
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
90006ad6:	68fb      	ldr	r3, [r7, #12]
90006ad8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90006adc:	f043 0280 	orr.w	r2, r3, #128	; 0x80
90006ae0:	68fb      	ldr	r3, [r7, #12]
90006ae2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  if ((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
90006ae6:	68fb      	ldr	r3, [r7, #12]
90006ae8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
90006aea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90006aec:	2b01      	cmp	r3, #1
90006aee:	d004      	beq.n	90006afa <SAI_DMAError+0x32>
90006af0:	68fb      	ldr	r3, [r7, #12]
90006af2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90006af4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90006af6:	2b01      	cmp	r3, #1
90006af8:	d112      	bne.n	90006b20 <SAI_DMAError+0x58>
  {
    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
90006afa:	68fb      	ldr	r3, [r7, #12]
90006afc:	681b      	ldr	r3, [r3, #0]
90006afe:	681a      	ldr	r2, [r3, #0]
90006b00:	68fb      	ldr	r3, [r7, #12]
90006b02:	681b      	ldr	r3, [r3, #0]
90006b04:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
90006b08:	601a      	str	r2, [r3, #0]

    /* Disable SAI peripheral */
    SAI_Disable(hsai);
90006b0a:	68f8      	ldr	r0, [r7, #12]
90006b0c:	f7ff ff28 	bl	90006960 <SAI_Disable>

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
90006b10:	68fb      	ldr	r3, [r7, #12]
90006b12:	2201      	movs	r2, #1
90006b14:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

    /* Initialize XferCount */
    hsai->XferCount = 0U;
90006b18:	68fb      	ldr	r3, [r7, #12]
90006b1a:	2200      	movs	r2, #0
90006b1c:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  }
  /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->ErrorCallback(hsai);
#else
  HAL_SAI_ErrorCallback(hsai);
90006b20:	68f8      	ldr	r0, [r7, #12]
90006b22:	f7fc f8bb 	bl	90002c9c <HAL_SAI_ErrorCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
90006b26:	bf00      	nop
90006b28:	3710      	adds	r7, #16
90006b2a:	46bd      	mov	sp, r7
90006b2c:	bd80      	pop	{r7, pc}

90006b2e <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
90006b2e:	b580      	push	{r7, lr}
90006b30:	b082      	sub	sp, #8
90006b32:	af00      	add	r7, sp, #0
90006b34:	6078      	str	r0, [r7, #4]
90006b36:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
90006b38:	687b      	ldr	r3, [r7, #4]
90006b3a:	2b00      	cmp	r3, #0
90006b3c:	d101      	bne.n	90006b42 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
90006b3e:	2301      	movs	r3, #1
90006b40:	e025      	b.n	90006b8e <HAL_SDRAM_Init+0x60>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
90006b42:	687b      	ldr	r3, [r7, #4]
90006b44:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
90006b48:	b2db      	uxtb	r3, r3
90006b4a:	2b00      	cmp	r3, #0
90006b4c:	d106      	bne.n	90006b5c <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
90006b4e:	687b      	ldr	r3, [r7, #4]
90006b50:	2200      	movs	r2, #0
90006b52:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
90006b56:	6878      	ldr	r0, [r7, #4]
90006b58:	f000 f81d 	bl	90006b96 <HAL_SDRAM_MspInit>
#endif
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
90006b5c:	687b      	ldr	r3, [r7, #4]
90006b5e:	2202      	movs	r2, #2
90006b60:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
90006b64:	687b      	ldr	r3, [r7, #4]
90006b66:	681a      	ldr	r2, [r3, #0]
90006b68:	687b      	ldr	r3, [r7, #4]
90006b6a:	3304      	adds	r3, #4
90006b6c:	4619      	mov	r1, r3
90006b6e:	4610      	mov	r0, r2
90006b70:	f000 f866 	bl	90006c40 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
90006b74:	687b      	ldr	r3, [r7, #4]
90006b76:	6818      	ldr	r0, [r3, #0]
90006b78:	687b      	ldr	r3, [r7, #4]
90006b7a:	685b      	ldr	r3, [r3, #4]
90006b7c:	461a      	mov	r2, r3
90006b7e:	6839      	ldr	r1, [r7, #0]
90006b80:	f000 f8d0 	bl	90006d24 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
90006b84:	687b      	ldr	r3, [r7, #4]
90006b86:	2201      	movs	r2, #1
90006b88:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
90006b8c:	2300      	movs	r3, #0
}
90006b8e:	4618      	mov	r0, r3
90006b90:	3708      	adds	r7, #8
90006b92:	46bd      	mov	sp, r7
90006b94:	bd80      	pop	{r7, pc}

90006b96 <HAL_SDRAM_MspInit>:
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
{
90006b96:	b480      	push	{r7}
90006b98:	b083      	sub	sp, #12
90006b9a:	af00      	add	r7, sp, #0
90006b9c:	6078      	str	r0, [r7, #4]
  UNUSED(hsdram);
 
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
90006b9e:	bf00      	nop
90006ba0:	370c      	adds	r7, #12
90006ba2:	46bd      	mov	sp, r7
90006ba4:	f85d 7b04 	ldr.w	r7, [sp], #4
90006ba8:	4770      	bx	lr

90006baa <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
90006baa:	b580      	push	{r7, lr}
90006bac:	b084      	sub	sp, #16
90006bae:	af00      	add	r7, sp, #0
90006bb0:	60f8      	str	r0, [r7, #12]
90006bb2:	60b9      	str	r1, [r7, #8]
90006bb4:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
90006bb6:	68fb      	ldr	r3, [r7, #12]
90006bb8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
90006bbc:	b2db      	uxtb	r3, r3
90006bbe:	2b02      	cmp	r3, #2
90006bc0:	d101      	bne.n	90006bc6 <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
90006bc2:	2302      	movs	r3, #2
90006bc4:	e018      	b.n	90006bf8 <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
90006bc6:	68fb      	ldr	r3, [r7, #12]
90006bc8:	2202      	movs	r2, #2
90006bca:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
90006bce:	68fb      	ldr	r3, [r7, #12]
90006bd0:	681b      	ldr	r3, [r3, #0]
90006bd2:	687a      	ldr	r2, [r7, #4]
90006bd4:	68b9      	ldr	r1, [r7, #8]
90006bd6:	4618      	mov	r0, r3
90006bd8:	f000 f924 	bl	90006e24 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
90006bdc:	68bb      	ldr	r3, [r7, #8]
90006bde:	681b      	ldr	r3, [r3, #0]
90006be0:	2b02      	cmp	r3, #2
90006be2:	d104      	bne.n	90006bee <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
90006be4:	68fb      	ldr	r3, [r7, #12]
90006be6:	2205      	movs	r2, #5
90006be8:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
90006bec:	e003      	b.n	90006bf6 <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
90006bee:	68fb      	ldr	r3, [r7, #12]
90006bf0:	2201      	movs	r2, #1
90006bf2:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
90006bf6:	2300      	movs	r3, #0
}
90006bf8:	4618      	mov	r0, r3
90006bfa:	3710      	adds	r7, #16
90006bfc:	46bd      	mov	sp, r7
90006bfe:	bd80      	pop	{r7, pc}

90006c00 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
90006c00:	b580      	push	{r7, lr}
90006c02:	b082      	sub	sp, #8
90006c04:	af00      	add	r7, sp, #0
90006c06:	6078      	str	r0, [r7, #4]
90006c08:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
90006c0a:	687b      	ldr	r3, [r7, #4]
90006c0c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
90006c10:	b2db      	uxtb	r3, r3
90006c12:	2b02      	cmp	r3, #2
90006c14:	d101      	bne.n	90006c1a <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
90006c16:	2302      	movs	r3, #2
90006c18:	e00e      	b.n	90006c38 <HAL_SDRAM_ProgramRefreshRate+0x38>
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
90006c1a:	687b      	ldr	r3, [r7, #4]
90006c1c:	2202      	movs	r2, #2
90006c1e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
90006c22:	687b      	ldr	r3, [r7, #4]
90006c24:	681b      	ldr	r3, [r3, #0]
90006c26:	6839      	ldr	r1, [r7, #0]
90006c28:	4618      	mov	r0, r3
90006c2a:	f000 f91f 	bl	90006e6c <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
90006c2e:	687b      	ldr	r3, [r7, #4]
90006c30:	2201      	movs	r2, #1
90006c32:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;   
90006c36:	2300      	movs	r3, #0
}
90006c38:	4618      	mov	r0, r3
90006c3a:	3708      	adds	r7, #8
90006c3c:	46bd      	mov	sp, r7
90006c3e:	bd80      	pop	{r7, pc}

90006c40 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
90006c40:	b480      	push	{r7}
90006c42:	b085      	sub	sp, #20
90006c44:	af00      	add	r7, sp, #0
90006c46:	6078      	str	r0, [r7, #4]
90006c48:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
90006c4a:	2300      	movs	r3, #0
90006c4c:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
90006c4e:	2300      	movs	r3, #0
90006c50:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
90006c52:	683b      	ldr	r3, [r7, #0]
90006c54:	681b      	ldr	r3, [r3, #0]
90006c56:	2b01      	cmp	r3, #1
90006c58:	d027      	beq.n	90006caa <FMC_SDRAM_Init+0x6a>
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
90006c5a:	687b      	ldr	r3, [r7, #4]
90006c5c:	681b      	ldr	r3, [r3, #0]
90006c5e:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
90006c60:	68fa      	ldr	r2, [r7, #12]
90006c62:	4b2f      	ldr	r3, [pc, #188]	; (90006d20 <FMC_SDRAM_Init+0xe0>)
90006c64:	4013      	ands	r3, r2
90006c66:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
90006c68:	683b      	ldr	r3, [r7, #0]
90006c6a:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
90006c6c:	683b      	ldr	r3, [r7, #0]
90006c6e:	689b      	ldr	r3, [r3, #8]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
90006c70:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
90006c72:	683b      	ldr	r3, [r7, #0]
90006c74:	68db      	ldr	r3, [r3, #12]
                        Init->RowBitsNumber      |\
90006c76:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
90006c78:	683b      	ldr	r3, [r7, #0]
90006c7a:	691b      	ldr	r3, [r3, #16]
                        Init->MemoryDataWidth    |\
90006c7c:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
90006c7e:	683b      	ldr	r3, [r7, #0]
90006c80:	695b      	ldr	r3, [r3, #20]
                        Init->InternalBankNumber |\
90006c82:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
90006c84:	683b      	ldr	r3, [r7, #0]
90006c86:	699b      	ldr	r3, [r3, #24]
                        Init->CASLatency         |\
90006c88:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
90006c8a:	683b      	ldr	r3, [r7, #0]
90006c8c:	69db      	ldr	r3, [r3, #28]
                        Init->WriteProtection    |\
90006c8e:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
90006c90:	683b      	ldr	r3, [r7, #0]
90006c92:	6a1b      	ldr	r3, [r3, #32]
                        Init->SDClockPeriod      |\
90006c94:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay
90006c96:	683b      	ldr	r3, [r7, #0]
90006c98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
90006c9a:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
90006c9c:	68fa      	ldr	r2, [r7, #12]
90006c9e:	4313      	orrs	r3, r2
90006ca0:	60fb      	str	r3, [r7, #12]
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
90006ca2:	687b      	ldr	r3, [r7, #4]
90006ca4:	68fa      	ldr	r2, [r7, #12]
90006ca6:	601a      	str	r2, [r3, #0]
90006ca8:	e032      	b.n	90006d10 <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
90006caa:	687b      	ldr	r3, [r7, #4]
90006cac:	681b      	ldr	r3, [r3, #0]
90006cae:	60fb      	str	r3, [r7, #12]
    
    /* Clear SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
90006cb0:	68fb      	ldr	r3, [r7, #12]
90006cb2:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
90006cb6:	60fb      	str	r3, [r7, #12]
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
90006cb8:	683b      	ldr	r3, [r7, #0]
90006cba:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
90006cbc:	683b      	ldr	r3, [r7, #0]
90006cbe:	6a1b      	ldr	r3, [r3, #32]
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
90006cc0:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay);
90006cc2:	683b      	ldr	r3, [r7, #0]
90006cc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
90006cc6:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
90006cc8:	68fa      	ldr	r2, [r7, #12]
90006cca:	4313      	orrs	r3, r2
90006ccc:	60fb      	str	r3, [r7, #12]
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
90006cce:	687b      	ldr	r3, [r7, #4]
90006cd0:	685b      	ldr	r3, [r3, #4]
90006cd2:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
90006cd4:	68ba      	ldr	r2, [r7, #8]
90006cd6:	4b12      	ldr	r3, [pc, #72]	; (90006d20 <FMC_SDRAM_Init+0xe0>)
90006cd8:	4013      	ands	r3, r2
90006cda:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
90006cdc:	683b      	ldr	r3, [r7, #0]
90006cde:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber       |\
90006ce0:	683b      	ldr	r3, [r7, #0]
90006ce2:	689b      	ldr	r3, [r3, #8]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
90006ce4:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth     |\
90006ce6:	683b      	ldr	r3, [r7, #0]
90006ce8:	68db      	ldr	r3, [r3, #12]
                       Init->RowBitsNumber       |\
90006cea:	431a      	orrs	r2, r3
                       Init->InternalBankNumber  |\
90006cec:	683b      	ldr	r3, [r7, #0]
90006cee:	691b      	ldr	r3, [r3, #16]
                       Init->MemoryDataWidth     |\
90006cf0:	431a      	orrs	r2, r3
                       Init->CASLatency          |\
90006cf2:	683b      	ldr	r3, [r7, #0]
90006cf4:	695b      	ldr	r3, [r3, #20]
                       Init->InternalBankNumber  |\
90006cf6:	431a      	orrs	r2, r3
                       Init->WriteProtection);
90006cf8:	683b      	ldr	r3, [r7, #0]
90006cfa:	699b      	ldr	r3, [r3, #24]
                       Init->CASLatency          |\
90006cfc:	4313      	orrs	r3, r2
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
90006cfe:	68ba      	ldr	r2, [r7, #8]
90006d00:	4313      	orrs	r3, r2
90006d02:	60bb      	str	r3, [r7, #8]

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
90006d04:	687b      	ldr	r3, [r7, #4]
90006d06:	68fa      	ldr	r2, [r7, #12]
90006d08:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
90006d0a:	687b      	ldr	r3, [r7, #4]
90006d0c:	68ba      	ldr	r2, [r7, #8]
90006d0e:	605a      	str	r2, [r3, #4]
  }
  
  return HAL_OK;
90006d10:	2300      	movs	r3, #0
}
90006d12:	4618      	mov	r0, r3
90006d14:	3714      	adds	r7, #20
90006d16:	46bd      	mov	sp, r7
90006d18:	f85d 7b04 	ldr.w	r7, [sp], #4
90006d1c:	4770      	bx	lr
90006d1e:	bf00      	nop
90006d20:	ffff8000 	.word	0xffff8000

90006d24 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
90006d24:	b480      	push	{r7}
90006d26:	b087      	sub	sp, #28
90006d28:	af00      	add	r7, sp, #0
90006d2a:	60f8      	str	r0, [r7, #12]
90006d2c:	60b9      	str	r1, [r7, #8]
90006d2e:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
90006d30:	2300      	movs	r3, #0
90006d32:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
90006d34:	2300      	movs	r3, #0
90006d36:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
90006d38:	687b      	ldr	r3, [r7, #4]
90006d3a:	2b01      	cmp	r3, #1
90006d3c:	d02e      	beq.n	90006d9c <FMC_SDRAM_Timing_Init+0x78>
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
90006d3e:	68fb      	ldr	r3, [r7, #12]
90006d40:	689b      	ldr	r3, [r3, #8]
90006d42:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
90006d44:	697b      	ldr	r3, [r7, #20]
90006d46:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
90006d4a:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90006d4c:	68bb      	ldr	r3, [r7, #8]
90006d4e:	681b      	ldr	r3, [r3, #0]
90006d50:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
90006d52:	68bb      	ldr	r3, [r7, #8]
90006d54:	685b      	ldr	r3, [r3, #4]
90006d56:	3b01      	subs	r3, #1
90006d58:	011b      	lsls	r3, r3, #4
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90006d5a:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
90006d5c:	68bb      	ldr	r3, [r7, #8]
90006d5e:	689b      	ldr	r3, [r3, #8]
90006d60:	3b01      	subs	r3, #1
90006d62:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
90006d64:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
90006d66:	68bb      	ldr	r3, [r7, #8]
90006d68:	68db      	ldr	r3, [r3, #12]
90006d6a:	3b01      	subs	r3, #1
90006d6c:	031b      	lsls	r3, r3, #12
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
90006d6e:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
90006d70:	68bb      	ldr	r3, [r7, #8]
90006d72:	691b      	ldr	r3, [r3, #16]
90006d74:	3b01      	subs	r3, #1
90006d76:	041b      	lsls	r3, r3, #16
                       (((Timing->RowCycleDelay)-1) << 12)       |\
90006d78:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
90006d7a:	68bb      	ldr	r3, [r7, #8]
90006d7c:	695b      	ldr	r3, [r3, #20]
90006d7e:	3b01      	subs	r3, #1
90006d80:	051b      	lsls	r3, r3, #20
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
90006d82:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1) << 24));
90006d84:	68bb      	ldr	r3, [r7, #8]
90006d86:	699b      	ldr	r3, [r3, #24]
90006d88:	3b01      	subs	r3, #1
90006d8a:	061b      	lsls	r3, r3, #24
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90006d8c:	4313      	orrs	r3, r2
90006d8e:	697a      	ldr	r2, [r7, #20]
90006d90:	4313      	orrs	r3, r2
90006d92:	617b      	str	r3, [r7, #20]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
90006d94:	68fb      	ldr	r3, [r7, #12]
90006d96:	697a      	ldr	r2, [r7, #20]
90006d98:	609a      	str	r2, [r3, #8]
90006d9a:	e039      	b.n	90006e10 <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
90006d9c:	68fb      	ldr	r3, [r7, #12]
90006d9e:	689b      	ldr	r3, [r3, #8]
90006da0:	617b      	str	r3, [r7, #20]
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
90006da2:	697a      	ldr	r2, [r7, #20]
90006da4:	4b1e      	ldr	r3, [pc, #120]	; (90006e20 <FMC_SDRAM_Timing_Init+0xfc>)
90006da6:	4013      	ands	r3, r2
90006da8:	617b      	str	r3, [r7, #20]
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
90006daa:	68bb      	ldr	r3, [r7, #8]
90006dac:	68db      	ldr	r3, [r3, #12]
90006dae:	3b01      	subs	r3, #1
90006db0:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
90006db2:	68bb      	ldr	r3, [r7, #8]
90006db4:	695b      	ldr	r3, [r3, #20]
90006db6:	3b01      	subs	r3, #1
90006db8:	051b      	lsls	r3, r3, #20
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
90006dba:	4313      	orrs	r3, r2
90006dbc:	697a      	ldr	r2, [r7, #20]
90006dbe:	4313      	orrs	r3, r2
90006dc0:	617b      	str	r3, [r7, #20]
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
90006dc2:	68fb      	ldr	r3, [r7, #12]
90006dc4:	68db      	ldr	r3, [r3, #12]
90006dc6:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
90006dc8:	693b      	ldr	r3, [r7, #16]
90006dca:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
90006dce:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90006dd0:	68bb      	ldr	r3, [r7, #8]
90006dd2:	681b      	ldr	r3, [r3, #0]
90006dd4:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
90006dd6:	68bb      	ldr	r3, [r7, #8]
90006dd8:	685b      	ldr	r3, [r3, #4]
90006dda:	3b01      	subs	r3, #1
90006ddc:	011b      	lsls	r3, r3, #4
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90006dde:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
90006de0:	68bb      	ldr	r3, [r7, #8]
90006de2:	689b      	ldr	r3, [r3, #8]
90006de4:	3b01      	subs	r3, #1
90006de6:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
90006de8:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
90006dea:	68bb      	ldr	r3, [r7, #8]
90006dec:	691b      	ldr	r3, [r3, #16]
90006dee:	3b01      	subs	r3, #1
90006df0:	041b      	lsls	r3, r3, #16
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
90006df2:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1) << 24));   
90006df4:	68bb      	ldr	r3, [r7, #8]
90006df6:	699b      	ldr	r3, [r3, #24]
90006df8:	3b01      	subs	r3, #1
90006dfa:	061b      	lsls	r3, r3, #24
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
90006dfc:	4313      	orrs	r3, r2
90006dfe:	693a      	ldr	r2, [r7, #16]
90006e00:	4313      	orrs	r3, r2
90006e02:	613b      	str	r3, [r7, #16]

    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
90006e04:	68fb      	ldr	r3, [r7, #12]
90006e06:	697a      	ldr	r2, [r7, #20]
90006e08:	609a      	str	r2, [r3, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
90006e0a:	68fb      	ldr	r3, [r7, #12]
90006e0c:	693a      	ldr	r2, [r7, #16]
90006e0e:	60da      	str	r2, [r3, #12]
  }
  
  return HAL_OK;
90006e10:	2300      	movs	r3, #0
}
90006e12:	4618      	mov	r0, r3
90006e14:	371c      	adds	r7, #28
90006e16:	46bd      	mov	sp, r7
90006e18:	f85d 7b04 	ldr.w	r7, [sp], #4
90006e1c:	4770      	bx	lr
90006e1e:	bf00      	nop
90006e20:	ff0f0fff 	.word	0xff0f0fff

90006e24 <FMC_SDRAM_SendCommand>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{ 
90006e24:	b480      	push	{r7}
90006e26:	b085      	sub	sp, #20
90006e28:	af00      	add	r7, sp, #0
90006e2a:	60f8      	str	r0, [r7, #12]
90006e2c:	60b9      	str	r1, [r7, #8]
90006e2e:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | 
90006e30:	68fb      	ldr	r3, [r7, #12]
90006e32:	691a      	ldr	r2, [r3, #16]
90006e34:	4b0c      	ldr	r3, [pc, #48]	; (90006e68 <FMC_SDRAM_SendCommand+0x44>)
90006e36:	4013      	ands	r3, r2
90006e38:	68ba      	ldr	r2, [r7, #8]
90006e3a:	6811      	ldr	r1, [r2, #0]
90006e3c:	68ba      	ldr	r2, [r7, #8]
90006e3e:	6852      	ldr	r2, [r2, #4]
90006e40:	4311      	orrs	r1, r2
90006e42:	68ba      	ldr	r2, [r7, #8]
90006e44:	6892      	ldr	r2, [r2, #8]
90006e46:	3a01      	subs	r2, #1
90006e48:	0152      	lsls	r2, r2, #5
90006e4a:	4311      	orrs	r1, r2
90006e4c:	68ba      	ldr	r2, [r7, #8]
90006e4e:	68d2      	ldr	r2, [r2, #12]
90006e50:	0252      	lsls	r2, r2, #9
90006e52:	430a      	orrs	r2, r1
90006e54:	431a      	orrs	r2, r3
90006e56:	68fb      	ldr	r3, [r7, #12]
90006e58:	611a      	str	r2, [r3, #16]
             FMC_SDCMR_NRFS | FMC_SDCMR_MRD), ((Command->CommandMode) | 
             (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
             ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  
  return HAL_OK;  
90006e5a:	2300      	movs	r3, #0
}
90006e5c:	4618      	mov	r0, r3
90006e5e:	3714      	adds	r7, #20
90006e60:	46bd      	mov	sp, r7
90006e62:	f85d 7b04 	ldr.w	r7, [sp], #4
90006e66:	4770      	bx	lr
90006e68:	ffc00000 	.word	0xffc00000

90006e6c <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance  
  * @param  RefreshRate The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
90006e6c:	b480      	push	{r7}
90006e6e:	b083      	sub	sp, #12
90006e70:	af00      	add	r7, sp, #0
90006e72:	6078      	str	r0, [r7, #4]
90006e74:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
90006e76:	687b      	ldr	r3, [r7, #4]
90006e78:	695a      	ldr	r2, [r3, #20]
90006e7a:	683b      	ldr	r3, [r7, #0]
90006e7c:	005b      	lsls	r3, r3, #1
90006e7e:	431a      	orrs	r2, r3
90006e80:	687b      	ldr	r3, [r7, #4]
90006e82:	615a      	str	r2, [r3, #20]
  
  return HAL_OK;   
90006e84:	2300      	movs	r3, #0
}
90006e86:	4618      	mov	r0, r3
90006e88:	370c      	adds	r7, #12
90006e8a:	46bd      	mov	sp, r7
90006e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
90006e90:	4770      	bx	lr

90006e92 <_ZN17SDRAM_DISCO_F7508C1Ev>:
*/
#include "SDRAM_DISCO_F7508.h"
#include "stm32f7508_discovery_sdram.h"

// Constructor
SDRAM_DISCO_F7508::SDRAM_DISCO_F7508()
90006e92:	b580      	push	{r7, lr}
90006e94:	b082      	sub	sp, #8
90006e96:	af00      	add	r7, sp, #0
90006e98:	6078      	str	r0, [r7, #4]
{
  BSP_SDRAM_Init();
90006e9a:	f7fc fa97 	bl	900033cc <BSP_SDRAM_Init>
}
90006e9e:	687b      	ldr	r3, [r7, #4]
90006ea0:	4618      	mov	r0, r3
90006ea2:	3708      	adds	r7, #8
90006ea4:	46bd      	mov	sp, r7
90006ea6:	bd80      	pop	{r7, pc}

90006ea8 <__libc_init_array>:
90006ea8:	b570      	push	{r4, r5, r6, lr}
90006eaa:	4d0d      	ldr	r5, [pc, #52]	; (90006ee0 <__libc_init_array+0x38>)
90006eac:	4c0d      	ldr	r4, [pc, #52]	; (90006ee4 <__libc_init_array+0x3c>)
90006eae:	1b64      	subs	r4, r4, r5
90006eb0:	10a4      	asrs	r4, r4, #2
90006eb2:	2600      	movs	r6, #0
90006eb4:	42a6      	cmp	r6, r4
90006eb6:	d109      	bne.n	90006ecc <__libc_init_array+0x24>
90006eb8:	4d0b      	ldr	r5, [pc, #44]	; (90006ee8 <__libc_init_array+0x40>)
90006eba:	4c0c      	ldr	r4, [pc, #48]	; (90006eec <__libc_init_array+0x44>)
90006ebc:	f000 f82e 	bl	90006f1c <_init>
90006ec0:	1b64      	subs	r4, r4, r5
90006ec2:	10a4      	asrs	r4, r4, #2
90006ec4:	2600      	movs	r6, #0
90006ec6:	42a6      	cmp	r6, r4
90006ec8:	d105      	bne.n	90006ed6 <__libc_init_array+0x2e>
90006eca:	bd70      	pop	{r4, r5, r6, pc}
90006ecc:	f855 3b04 	ldr.w	r3, [r5], #4
90006ed0:	4798      	blx	r3
90006ed2:	3601      	adds	r6, #1
90006ed4:	e7ee      	b.n	90006eb4 <__libc_init_array+0xc>
90006ed6:	f855 3b04 	ldr.w	r3, [r5], #4
90006eda:	4798      	blx	r3
90006edc:	3601      	adds	r6, #1
90006ede:	e7f2      	b.n	90006ec6 <__libc_init_array+0x1e>
90006ee0:	90006f54 	.word	0x90006f54
90006ee4:	90006f54 	.word	0x90006f54
90006ee8:	90006f54 	.word	0x90006f54
90006eec:	90006f58 	.word	0x90006f58

90006ef0 <memcpy>:
90006ef0:	440a      	add	r2, r1
90006ef2:	4291      	cmp	r1, r2
90006ef4:	f100 33ff 	add.w	r3, r0, #4294967295
90006ef8:	d100      	bne.n	90006efc <memcpy+0xc>
90006efa:	4770      	bx	lr
90006efc:	b510      	push	{r4, lr}
90006efe:	f811 4b01 	ldrb.w	r4, [r1], #1
90006f02:	f803 4f01 	strb.w	r4, [r3, #1]!
90006f06:	4291      	cmp	r1, r2
90006f08:	d1f9      	bne.n	90006efe <memcpy+0xe>
90006f0a:	bd10      	pop	{r4, pc}

90006f0c <memset>:
90006f0c:	4402      	add	r2, r0
90006f0e:	4603      	mov	r3, r0
90006f10:	4293      	cmp	r3, r2
90006f12:	d100      	bne.n	90006f16 <memset+0xa>
90006f14:	4770      	bx	lr
90006f16:	f803 1b01 	strb.w	r1, [r3], #1
90006f1a:	e7f9      	b.n	90006f10 <memset+0x4>

90006f1c <_init>:
90006f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90006f1e:	bf00      	nop
90006f20:	bcf8      	pop	{r3, r4, r5, r6, r7}
90006f22:	bc08      	pop	{r3}
90006f24:	469e      	mov	lr, r3
90006f26:	4770      	bx	lr

90006f28 <_fini>:
90006f28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90006f2a:	bf00      	nop
90006f2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
90006f2e:	bc08      	pop	{r3}
90006f30:	469e      	mov	lr, r3
90006f32:	4770      	bx	lr
